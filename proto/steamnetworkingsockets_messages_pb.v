// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum ESteamNetworkingSocketsCipher {
	k_esteamnetworkingsocketscipher_invalid = 0
	k_esteamnetworkingsocketscipher_null = 1
	k_esteamnetworkingsocketscipher_aes_256_gcm = 2
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_esteamnetworkingsocketscipher() ESteamNetworkingSocketsCipher {
	return .k_esteamnetworkingsocketscipher_invalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_esteamnetworkingsocketscipher(e ESteamNetworkingSocketsCipher, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_esteamnetworkingsocketscipher_packed(e []ESteamNetworkingSocketsCipher, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_esteamnetworkingsocketscipher(buf []byte, tag_wiretype vproto.WireType) ?(int, ESteamNetworkingSocketsCipher) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, ESteamNetworkingSocketsCipher(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_esteamnetworkingsocketscipher_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ESteamNetworkingSocketsCipher) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum CMsgSteamDatagramSessionCryptInfo_EKeyType {
	invalid = 0
	curve25519 = 1
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfo_ekeytype() CMsgSteamDatagramSessionCryptInfo_EKeyType {
	return .invalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfo_ekeytype(e CMsgSteamDatagramSessionCryptInfo_EKeyType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfo_ekeytype_packed(e []CMsgSteamDatagramSessionCryptInfo_EKeyType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfo_ekeytype(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramSessionCryptInfo_EKeyType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, CMsgSteamDatagramSessionCryptInfo_EKeyType(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfo_ekeytype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramSessionCryptInfo_EKeyType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramSessionCryptInfo {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	key_type         CMsgSteamDatagramSessionCryptInfo_EKeyType = .invalid
	key_data         []byte
	nonce            u64
	protocol_version u32
	ciphers          []ESteamNetworkingSocketsCipher
}

pub fn (o &CMsgSteamDatagramSessionCryptInfo) pack() []byte {
	mut res := []byte{}
	if o.key_type != zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfo_ekeytype() {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfo_ekeytype(o.key_type, 1)
	}
	if o.key_data != []byte{} {
		res << vproto.pack_bytes_field(o.key_data, 2)
	}
	if o.nonce != u64(0) {
		res << vproto.pack_64bit_field(o.nonce, 3)
	}
	if o.protocol_version != u32(0) {
		res << vproto.pack_uint32_field(o.protocol_version, 4)
	}
	// [packed=false]
	for _, x in o.ciphers {
		res << zzz_vproto_internal_pack_esteamnetworkingsocketscipher(x, 5)
	}
	return res
}

pub fn cmsgsteamdatagramsessioncryptinfo_unpack(buf []byte) ?CMsgSteamDatagramSessionCryptInfo {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.key_type = zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfo_ekeytype(cur_buf,
					tag_wiretype.wire_type) ?
			}
			2 {
				i, res.key_data = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.nonce = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.protocol_version = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_esteamnetworkingsocketscipher(cur_buf,
					tag_wiretype.wire_type) ?
				res.ciphers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramSessionCryptInfo) eq(b CMsgSteamDatagramSessionCryptInfo) bool {
	return true && a.key_type == b.key_type && a.key_data == b.key_data && a.nonce == b.nonce &&
		a.protocol_version == b.protocol_version && a.ciphers == b.ciphers
}

[inline]
pub fn (a CMsgSteamDatagramSessionCryptInfo) ne(b CMsgSteamDatagramSessionCryptInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramSessionCryptInfo) eq(b []CMsgSteamDatagramSessionCryptInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramSessionCryptInfo) ne(b []CMsgSteamDatagramSessionCryptInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfo() CMsgSteamDatagramSessionCryptInfo {
	return CMsgSteamDatagramSessionCryptInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfo(o CMsgSteamDatagramSessionCryptInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramSessionCryptInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramsessioncryptinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramSessionCryptInfoSigned {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	info           []byte
	signature      []byte
}

pub fn (o &CMsgSteamDatagramSessionCryptInfoSigned) pack() []byte {
	mut res := []byte{}
	if o.info != []byte{} {
		res << vproto.pack_bytes_field(o.info, 1)
	}
	if o.signature != []byte{} {
		res << vproto.pack_bytes_field(o.signature, 2)
	}
	return res
}

pub fn cmsgsteamdatagramsessioncryptinfosigned_unpack(buf []byte) ?CMsgSteamDatagramSessionCryptInfoSigned {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfosigned()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.info = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.signature = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramSessionCryptInfoSigned) eq(b CMsgSteamDatagramSessionCryptInfoSigned) bool {
	return true && a.info == b.info && a.signature == b.signature
}

[inline]
pub fn (a CMsgSteamDatagramSessionCryptInfoSigned) ne(b CMsgSteamDatagramSessionCryptInfoSigned) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramSessionCryptInfoSigned) eq(b []CMsgSteamDatagramSessionCryptInfoSigned) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramSessionCryptInfoSigned) ne(b []CMsgSteamDatagramSessionCryptInfoSigned) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfosigned() CMsgSteamDatagramSessionCryptInfoSigned {
	return CMsgSteamDatagramSessionCryptInfoSigned{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o CMsgSteamDatagramSessionCryptInfoSigned, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramSessionCryptInfoSigned) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramsessioncryptinfosigned_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramDiagnostic {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	severity       u32
	text           string
}

pub fn (o &CMsgSteamDatagramDiagnostic) pack() []byte {
	mut res := []byte{}
	if o.severity != u32(0) {
		res << vproto.pack_uint32_field(o.severity, 1)
	}
	if o.text != '' {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgsteamdatagramdiagnostic_unpack(buf []byte) ?CMsgSteamDatagramDiagnostic {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramdiagnostic()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.severity = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.text = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramDiagnostic) eq(b CMsgSteamDatagramDiagnostic) bool {
	return true && a.severity == b.severity && a.text == b.text
}

[inline]
pub fn (a CMsgSteamDatagramDiagnostic) ne(b CMsgSteamDatagramDiagnostic) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramDiagnostic) eq(b []CMsgSteamDatagramDiagnostic) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramDiagnostic) ne(b []CMsgSteamDatagramDiagnostic) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdiagnostic() CMsgSteamDatagramDiagnostic {
	return CMsgSteamDatagramDiagnostic{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdiagnostic(o CMsgSteamDatagramDiagnostic, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdiagnostic(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDiagnostic) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramdiagnostic_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramLinkInstantaneousStats {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	out_packets_per_sec_x10    u32
	out_bytes_per_sec          u32
	in_packets_per_sec_x10     u32
	in_bytes_per_sec           u32
	ping_ms                    u32
	packets_dropped_pct        u32
	packets_weird_sequence_pct u32
	peak_jitter_usec           u32
}

pub fn (o &CMsgSteamDatagramLinkInstantaneousStats) pack() []byte {
	mut res := []byte{}
	if o.out_packets_per_sec_x10 != u32(0) {
		res << vproto.pack_uint32_field(o.out_packets_per_sec_x10, 1)
	}
	if o.out_bytes_per_sec != u32(0) {
		res << vproto.pack_uint32_field(o.out_bytes_per_sec, 2)
	}
	if o.in_packets_per_sec_x10 != u32(0) {
		res << vproto.pack_uint32_field(o.in_packets_per_sec_x10, 3)
	}
	if o.in_bytes_per_sec != u32(0) {
		res << vproto.pack_uint32_field(o.in_bytes_per_sec, 4)
	}
	if o.ping_ms != u32(0) {
		res << vproto.pack_uint32_field(o.ping_ms, 5)
	}
	if o.packets_dropped_pct != u32(0) {
		res << vproto.pack_uint32_field(o.packets_dropped_pct, 6)
	}
	if o.packets_weird_sequence_pct != u32(0) {
		res << vproto.pack_uint32_field(o.packets_weird_sequence_pct, 7)
	}
	if o.peak_jitter_usec != u32(0) {
		res << vproto.pack_uint32_field(o.peak_jitter_usec, 8)
	}
	return res
}

pub fn cmsgsteamdatagramlinkinstantaneousstats_unpack(buf []byte) ?CMsgSteamDatagramLinkInstantaneousStats {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramlinkinstantaneousstats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.out_packets_per_sec_x10 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.out_bytes_per_sec = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.in_packets_per_sec_x10 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.in_bytes_per_sec = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.ping_ms = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.packets_dropped_pct = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.packets_weird_sequence_pct = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			8 {
				i, res.peak_jitter_usec = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramLinkInstantaneousStats) eq(b CMsgSteamDatagramLinkInstantaneousStats) bool {
	return true && a.out_packets_per_sec_x10 == b.out_packets_per_sec_x10 && a.out_bytes_per_sec ==
		b.out_bytes_per_sec && a.in_packets_per_sec_x10 == b.in_packets_per_sec_x10 && a.in_bytes_per_sec ==
		b.in_bytes_per_sec && a.ping_ms == b.ping_ms && a.packets_dropped_pct == b.packets_dropped_pct &&
		a.packets_weird_sequence_pct == b.packets_weird_sequence_pct && a.peak_jitter_usec == b.peak_jitter_usec
}

[inline]
pub fn (a CMsgSteamDatagramLinkInstantaneousStats) ne(b CMsgSteamDatagramLinkInstantaneousStats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramLinkInstantaneousStats) eq(b []CMsgSteamDatagramLinkInstantaneousStats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramLinkInstantaneousStats) ne(b []CMsgSteamDatagramLinkInstantaneousStats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramlinkinstantaneousstats() CMsgSteamDatagramLinkInstantaneousStats {
	return CMsgSteamDatagramLinkInstantaneousStats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramlinkinstantaneousstats(o CMsgSteamDatagramLinkInstantaneousStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramlinkinstantaneousstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramLinkInstantaneousStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramlinkinstantaneousstats_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramLinkLifetimeStats {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	connected_seconds           u32
	packets_sent                u64
	kb_sent                     u64
	packets_recv                u64
	kb_recv                     u64
	packets_recv_sequenced      u64
	packets_recv_dropped        u64
	packets_recv_out_of_order   u64
	packets_recv_duplicate      u64
	packets_recv_lurch          u64
	quality_histogram_100       u32
	quality_histogram_99        u32
	quality_histogram_97        u32
	quality_histogram_95        u32
	quality_histogram_90        u32
	quality_histogram_75        u32
	quality_histogram_50        u32
	quality_histogram_1         u32
	quality_histogram_dead      u32
	quality_ntile_2nd           u32
	quality_ntile_5th           u32
	quality_ntile_25th          u32
	quality_ntile_50th          u32
	ping_histogram_25           u32
	ping_histogram_50           u32
	ping_histogram_75           u32
	ping_histogram_100          u32
	ping_histogram_125          u32
	ping_histogram_150          u32
	ping_histogram_200          u32
	ping_histogram_300          u32
	ping_histogram_max          u32
	ping_ntile_5th              u32
	ping_ntile_50th             u32
	ping_ntile_75th             u32
	ping_ntile_95th             u32
	ping_ntile_98th             u32
	jitter_histogram_negligible u32
	jitter_histogram_1          u32
	jitter_histogram_2          u32
	jitter_histogram_5          u32
	jitter_histogram_10         u32
	jitter_histogram_20         u32
	txspeed_max                 u32
	txspeed_histogram_16        u32
	txspeed_histogram_32        u32
	txspeed_histogram_64        u32
	txspeed_histogram_128       u32
	txspeed_histogram_256       u32
	txspeed_histogram_512       u32
	txspeed_histogram_1024      u32
	txspeed_histogram_max       u32
	txspeed_ntile_5th           u32
	txspeed_ntile_50th          u32
	txspeed_ntile_75th          u32
	txspeed_ntile_95th          u32
	txspeed_ntile_98th          u32
	rxspeed_max                 u32
	rxspeed_histogram_16        u32
	rxspeed_histogram_32        u32
	rxspeed_histogram_64        u32
	rxspeed_histogram_128       u32
	rxspeed_histogram_256       u32
	rxspeed_histogram_512       u32
	rxspeed_histogram_1024      u32
	rxspeed_histogram_max       u32
	rxspeed_ntile_5th           u32
	rxspeed_ntile_50th          u32
	rxspeed_ntile_75th          u32
	rxspeed_ntile_95th          u32
	rxspeed_ntile_98th          u32
}

pub fn (o &CMsgSteamDatagramLinkLifetimeStats) pack() []byte {
	mut res := []byte{}
	if o.connected_seconds != u32(0) {
		res << vproto.pack_uint32_field(o.connected_seconds, 2)
	}
	if o.packets_sent != u64(0) {
		res << vproto.pack_uint64_field(o.packets_sent, 3)
	}
	if o.kb_sent != u64(0) {
		res << vproto.pack_uint64_field(o.kb_sent, 4)
	}
	if o.packets_recv != u64(0) {
		res << vproto.pack_uint64_field(o.packets_recv, 5)
	}
	if o.kb_recv != u64(0) {
		res << vproto.pack_uint64_field(o.kb_recv, 6)
	}
	if o.packets_recv_sequenced != u64(0) {
		res << vproto.pack_uint64_field(o.packets_recv_sequenced, 7)
	}
	if o.packets_recv_dropped != u64(0) {
		res << vproto.pack_uint64_field(o.packets_recv_dropped, 8)
	}
	if o.packets_recv_out_of_order != u64(0) {
		res << vproto.pack_uint64_field(o.packets_recv_out_of_order, 9)
	}
	if o.packets_recv_duplicate != u64(0) {
		res << vproto.pack_uint64_field(o.packets_recv_duplicate, 10)
	}
	if o.packets_recv_lurch != u64(0) {
		res << vproto.pack_uint64_field(o.packets_recv_lurch, 11)
	}
	if o.quality_histogram_100 != u32(0) {
		res << vproto.pack_uint32_field(o.quality_histogram_100, 21)
	}
	if o.quality_histogram_99 != u32(0) {
		res << vproto.pack_uint32_field(o.quality_histogram_99, 22)
	}
	if o.quality_histogram_97 != u32(0) {
		res << vproto.pack_uint32_field(o.quality_histogram_97, 23)
	}
	if o.quality_histogram_95 != u32(0) {
		res << vproto.pack_uint32_field(o.quality_histogram_95, 24)
	}
	if o.quality_histogram_90 != u32(0) {
		res << vproto.pack_uint32_field(o.quality_histogram_90, 25)
	}
	if o.quality_histogram_75 != u32(0) {
		res << vproto.pack_uint32_field(o.quality_histogram_75, 26)
	}
	if o.quality_histogram_50 != u32(0) {
		res << vproto.pack_uint32_field(o.quality_histogram_50, 27)
	}
	if o.quality_histogram_1 != u32(0) {
		res << vproto.pack_uint32_field(o.quality_histogram_1, 28)
	}
	if o.quality_histogram_dead != u32(0) {
		res << vproto.pack_uint32_field(o.quality_histogram_dead, 29)
	}
	if o.quality_ntile_2nd != u32(0) {
		res << vproto.pack_uint32_field(o.quality_ntile_2nd, 30)
	}
	if o.quality_ntile_5th != u32(0) {
		res << vproto.pack_uint32_field(o.quality_ntile_5th, 31)
	}
	if o.quality_ntile_25th != u32(0) {
		res << vproto.pack_uint32_field(o.quality_ntile_25th, 32)
	}
	if o.quality_ntile_50th != u32(0) {
		res << vproto.pack_uint32_field(o.quality_ntile_50th, 33)
	}
	if o.ping_histogram_25 != u32(0) {
		res << vproto.pack_uint32_field(o.ping_histogram_25, 41)
	}
	if o.ping_histogram_50 != u32(0) {
		res << vproto.pack_uint32_field(o.ping_histogram_50, 42)
	}
	if o.ping_histogram_75 != u32(0) {
		res << vproto.pack_uint32_field(o.ping_histogram_75, 43)
	}
	if o.ping_histogram_100 != u32(0) {
		res << vproto.pack_uint32_field(o.ping_histogram_100, 44)
	}
	if o.ping_histogram_125 != u32(0) {
		res << vproto.pack_uint32_field(o.ping_histogram_125, 45)
	}
	if o.ping_histogram_150 != u32(0) {
		res << vproto.pack_uint32_field(o.ping_histogram_150, 46)
	}
	if o.ping_histogram_200 != u32(0) {
		res << vproto.pack_uint32_field(o.ping_histogram_200, 47)
	}
	if o.ping_histogram_300 != u32(0) {
		res << vproto.pack_uint32_field(o.ping_histogram_300, 48)
	}
	if o.ping_histogram_max != u32(0) {
		res << vproto.pack_uint32_field(o.ping_histogram_max, 49)
	}
	if o.ping_ntile_5th != u32(0) {
		res << vproto.pack_uint32_field(o.ping_ntile_5th, 50)
	}
	if o.ping_ntile_50th != u32(0) {
		res << vproto.pack_uint32_field(o.ping_ntile_50th, 51)
	}
	if o.ping_ntile_75th != u32(0) {
		res << vproto.pack_uint32_field(o.ping_ntile_75th, 52)
	}
	if o.ping_ntile_95th != u32(0) {
		res << vproto.pack_uint32_field(o.ping_ntile_95th, 53)
	}
	if o.ping_ntile_98th != u32(0) {
		res << vproto.pack_uint32_field(o.ping_ntile_98th, 54)
	}
	if o.jitter_histogram_negligible != u32(0) {
		res << vproto.pack_uint32_field(o.jitter_histogram_negligible, 61)
	}
	if o.jitter_histogram_1 != u32(0) {
		res << vproto.pack_uint32_field(o.jitter_histogram_1, 62)
	}
	if o.jitter_histogram_2 != u32(0) {
		res << vproto.pack_uint32_field(o.jitter_histogram_2, 63)
	}
	if o.jitter_histogram_5 != u32(0) {
		res << vproto.pack_uint32_field(o.jitter_histogram_5, 64)
	}
	if o.jitter_histogram_10 != u32(0) {
		res << vproto.pack_uint32_field(o.jitter_histogram_10, 65)
	}
	if o.jitter_histogram_20 != u32(0) {
		res << vproto.pack_uint32_field(o.jitter_histogram_20, 66)
	}
	if o.txspeed_max != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_max, 67)
	}
	if o.txspeed_histogram_16 != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_histogram_16, 68)
	}
	if o.txspeed_histogram_32 != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_histogram_32, 69)
	}
	if o.txspeed_histogram_64 != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_histogram_64, 70)
	}
	if o.txspeed_histogram_128 != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_histogram_128, 71)
	}
	if o.txspeed_histogram_256 != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_histogram_256, 72)
	}
	if o.txspeed_histogram_512 != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_histogram_512, 73)
	}
	if o.txspeed_histogram_1024 != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_histogram_1024, 74)
	}
	if o.txspeed_histogram_max != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_histogram_max, 75)
	}
	if o.txspeed_ntile_5th != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_ntile_5th, 76)
	}
	if o.txspeed_ntile_50th != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_ntile_50th, 77)
	}
	if o.txspeed_ntile_75th != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_ntile_75th, 78)
	}
	if o.txspeed_ntile_95th != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_ntile_95th, 79)
	}
	if o.txspeed_ntile_98th != u32(0) {
		res << vproto.pack_uint32_field(o.txspeed_ntile_98th, 80)
	}
	if o.rxspeed_max != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_max, 81)
	}
	if o.rxspeed_histogram_16 != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_16, 82)
	}
	if o.rxspeed_histogram_32 != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_32, 83)
	}
	if o.rxspeed_histogram_64 != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_64, 84)
	}
	if o.rxspeed_histogram_128 != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_128, 85)
	}
	if o.rxspeed_histogram_256 != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_256, 86)
	}
	if o.rxspeed_histogram_512 != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_512, 87)
	}
	if o.rxspeed_histogram_1024 != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_1024, 88)
	}
	if o.rxspeed_histogram_max != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_max, 89)
	}
	if o.rxspeed_ntile_5th != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_ntile_5th, 90)
	}
	if o.rxspeed_ntile_50th != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_ntile_50th, 91)
	}
	if o.rxspeed_ntile_75th != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_ntile_75th, 92)
	}
	if o.rxspeed_ntile_95th != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_ntile_95th, 93)
	}
	if o.rxspeed_ntile_98th != u32(0) {
		res << vproto.pack_uint32_field(o.rxspeed_ntile_98th, 94)
	}
	return res
}

pub fn cmsgsteamdatagramlinklifetimestats_unpack(buf []byte) ?CMsgSteamDatagramLinkLifetimeStats {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramlinklifetimestats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				i, res.connected_seconds = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.packets_sent = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.kb_sent = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.packets_recv = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.kb_recv = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.packets_recv_sequenced = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.packets_recv_dropped = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.packets_recv_out_of_order = vproto.unpack_uint64_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			10 {
				i, res.packets_recv_duplicate = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				i, res.packets_recv_lurch = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			21 {
				i, res.quality_histogram_100 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			22 {
				i, res.quality_histogram_99 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			23 {
				i, res.quality_histogram_97 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			24 {
				i, res.quality_histogram_95 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			25 {
				i, res.quality_histogram_90 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			26 {
				i, res.quality_histogram_75 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			27 {
				i, res.quality_histogram_50 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			28 {
				i, res.quality_histogram_1 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			29 {
				i, res.quality_histogram_dead = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			30 {
				i, res.quality_ntile_2nd = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			31 {
				i, res.quality_ntile_5th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			32 {
				i, res.quality_ntile_25th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			33 {
				i, res.quality_ntile_50th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			41 {
				i, res.ping_histogram_25 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			42 {
				i, res.ping_histogram_50 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			43 {
				i, res.ping_histogram_75 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			44 {
				i, res.ping_histogram_100 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			45 {
				i, res.ping_histogram_125 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			46 {
				i, res.ping_histogram_150 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			47 {
				i, res.ping_histogram_200 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			48 {
				i, res.ping_histogram_300 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			49 {
				i, res.ping_histogram_max = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			50 {
				i, res.ping_ntile_5th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			51 {
				i, res.ping_ntile_50th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			52 {
				i, res.ping_ntile_75th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			53 {
				i, res.ping_ntile_95th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			54 {
				i, res.ping_ntile_98th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			61 {
				i, res.jitter_histogram_negligible = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			62 {
				i, res.jitter_histogram_1 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			63 {
				i, res.jitter_histogram_2 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			64 {
				i, res.jitter_histogram_5 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			65 {
				i, res.jitter_histogram_10 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			66 {
				i, res.jitter_histogram_20 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			67 {
				i, res.txspeed_max = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			68 {
				i, res.txspeed_histogram_16 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			69 {
				i, res.txspeed_histogram_32 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			70 {
				i, res.txspeed_histogram_64 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			71 {
				i, res.txspeed_histogram_128 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			72 {
				i, res.txspeed_histogram_256 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			73 {
				i, res.txspeed_histogram_512 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			74 {
				i, res.txspeed_histogram_1024 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			75 {
				i, res.txspeed_histogram_max = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			76 {
				i, res.txspeed_ntile_5th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			77 {
				i, res.txspeed_ntile_50th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			78 {
				i, res.txspeed_ntile_75th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			79 {
				i, res.txspeed_ntile_95th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			80 {
				i, res.txspeed_ntile_98th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			81 {
				i, res.rxspeed_max = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			82 {
				i, res.rxspeed_histogram_16 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			83 {
				i, res.rxspeed_histogram_32 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			84 {
				i, res.rxspeed_histogram_64 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			85 {
				i, res.rxspeed_histogram_128 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			86 {
				i, res.rxspeed_histogram_256 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			87 {
				i, res.rxspeed_histogram_512 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			88 {
				i, res.rxspeed_histogram_1024 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			89 {
				i, res.rxspeed_histogram_max = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			90 {
				i, res.rxspeed_ntile_5th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			91 {
				i, res.rxspeed_ntile_50th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			92 {
				i, res.rxspeed_ntile_75th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			93 {
				i, res.rxspeed_ntile_95th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			94 {
				i, res.rxspeed_ntile_98th = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramLinkLifetimeStats) eq(b CMsgSteamDatagramLinkLifetimeStats) bool {
	return false
}

[inline]
pub fn (a CMsgSteamDatagramLinkLifetimeStats) ne(b CMsgSteamDatagramLinkLifetimeStats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramLinkLifetimeStats) eq(b []CMsgSteamDatagramLinkLifetimeStats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramLinkLifetimeStats) ne(b []CMsgSteamDatagramLinkLifetimeStats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramlinklifetimestats() CMsgSteamDatagramLinkLifetimeStats {
	return CMsgSteamDatagramLinkLifetimeStats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramlinklifetimestats(o CMsgSteamDatagramLinkLifetimeStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramlinklifetimestats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramLinkLifetimeStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramlinklifetimestats_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramConnectionQuality {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	instantaneous  CMsgSteamDatagramLinkInstantaneousStats
	lifetime       CMsgSteamDatagramLinkLifetimeStats
}

pub fn (o &CMsgSteamDatagramConnectionQuality) pack() []byte {
	mut res := []byte{}
	if o.instantaneous.ne(zzz_vproto_internal_new_cmsgsteamdatagramlinkinstantaneousstats()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramlinkinstantaneousstats(o.instantaneous, 1)
	}
	if o.lifetime.ne(zzz_vproto_internal_new_cmsgsteamdatagramlinklifetimestats()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramlinklifetimestats(o.lifetime, 2)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionquality_unpack(buf []byte) ?CMsgSteamDatagramConnectionQuality {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.instantaneous = zzz_vproto_internal_unpack_cmsgsteamdatagramlinkinstantaneousstats(cur_buf,
					tag_wiretype.wire_type) ?
			}
			2 {
				i, res.lifetime = zzz_vproto_internal_unpack_cmsgsteamdatagramlinklifetimestats(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectionQuality) eq(b CMsgSteamDatagramConnectionQuality) bool {
	return true && a.instantaneous.eq(b.instantaneous) && a.lifetime.eq(b.lifetime)
}

[inline]
pub fn (a CMsgSteamDatagramConnectionQuality) ne(b CMsgSteamDatagramConnectionQuality) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionQuality) eq(b []CMsgSteamDatagramConnectionQuality) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionQuality) ne(b []CMsgSteamDatagramConnectionQuality) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality() CMsgSteamDatagramConnectionQuality {
	return CMsgSteamDatagramConnectionQuality{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o CMsgSteamDatagramConnectionQuality, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionQuality) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectionquality_unpack(v) ?
	return i, unpacked
}

pub struct CMsgICERendezvous_Auth {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	pwd_frag       string
}

pub fn (o &CMsgICERendezvous_Auth) pack() []byte {
	mut res := []byte{}
	if o.pwd_frag != '' {
		res << vproto.pack_string_field(o.pwd_frag, 1)
	}
	return res
}

pub fn cmsgicerendezvous_auth_unpack(buf []byte) ?CMsgICERendezvous_Auth {
	mut res := zzz_vproto_internal_new_cmsgicerendezvous_auth()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.pwd_frag = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgICERendezvous_Auth) eq(b CMsgICERendezvous_Auth) bool {
	return true && a.pwd_frag == b.pwd_frag
}

[inline]
pub fn (a CMsgICERendezvous_Auth) ne(b CMsgICERendezvous_Auth) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgICERendezvous_Auth) eq(b []CMsgICERendezvous_Auth) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgICERendezvous_Auth) ne(b []CMsgICERendezvous_Auth) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgicerendezvous_auth() CMsgICERendezvous_Auth {
	return CMsgICERendezvous_Auth{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgicerendezvous_auth(o CMsgICERendezvous_Auth, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgicerendezvous_auth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgICERendezvous_Auth) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgicerendezvous_auth_unpack(v) ?
	return i, unpacked
}

pub struct CMsgICERendezvous_Candidate {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	candidate      string
}

pub fn (o &CMsgICERendezvous_Candidate) pack() []byte {
	mut res := []byte{}
	if o.candidate != '' {
		res << vproto.pack_string_field(o.candidate, 3)
	}
	return res
}

pub fn cmsgicerendezvous_candidate_unpack(buf []byte) ?CMsgICERendezvous_Candidate {
	mut res := zzz_vproto_internal_new_cmsgicerendezvous_candidate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			3 {
				i, res.candidate = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgICERendezvous_Candidate) eq(b CMsgICERendezvous_Candidate) bool {
	return true && a.candidate == b.candidate
}

[inline]
pub fn (a CMsgICERendezvous_Candidate) ne(b CMsgICERendezvous_Candidate) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgICERendezvous_Candidate) eq(b []CMsgICERendezvous_Candidate) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgICERendezvous_Candidate) ne(b []CMsgICERendezvous_Candidate) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgicerendezvous_candidate() CMsgICERendezvous_Candidate {
	return CMsgICERendezvous_Candidate{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgicerendezvous_candidate(o CMsgICERendezvous_Candidate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgicerendezvous_candidate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgICERendezvous_Candidate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgicerendezvous_candidate_unpack(v) ?
	return i, unpacked
}

pub struct CMsgICERendezvous {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	auth           CMsgICERendezvous_Auth
	add_candidate  CMsgICERendezvous_Candidate
}

pub fn (o &CMsgICERendezvous) pack() []byte {
	mut res := []byte{}
	if o.auth.ne(zzz_vproto_internal_new_cmsgicerendezvous_auth()) {
		res << zzz_vproto_internal_pack_cmsgicerendezvous_auth(o.auth, 2)
	}
	if o.add_candidate.ne(zzz_vproto_internal_new_cmsgicerendezvous_candidate()) {
		res <<
			zzz_vproto_internal_pack_cmsgicerendezvous_candidate(o.add_candidate, 1)
	}
	return res
}

pub fn cmsgicerendezvous_unpack(buf []byte) ?CMsgICERendezvous {
	mut res := zzz_vproto_internal_new_cmsgicerendezvous()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				i, res.auth = zzz_vproto_internal_unpack_cmsgicerendezvous_auth(cur_buf,
					tag_wiretype.wire_type) ?
			}
			1 {
				i, res.add_candidate = zzz_vproto_internal_unpack_cmsgicerendezvous_candidate(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgICERendezvous) eq(b CMsgICERendezvous) bool {
	return true && a.auth.eq(b.auth) && a.add_candidate.eq(b.add_candidate)
}

[inline]
pub fn (a CMsgICERendezvous) ne(b CMsgICERendezvous) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgICERendezvous) eq(b []CMsgICERendezvous) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgICERendezvous) ne(b []CMsgICERendezvous) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgicerendezvous() CMsgICERendezvous {
	return CMsgICERendezvous{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgicerendezvous(o CMsgICERendezvous, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgicerendezvous(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgICERendezvous) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgicerendezvous_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	crypt          CMsgSteamDatagramSessionCryptInfoSigned
	cert           CMsgSteamDatagramCertificateSigned
	virtual_port   u32
}

pub fn (o &CMsgSteamNetworkingP2PRendezvous_ConnectRequest) pack() []byte {
	mut res := []byte{}
	if o.crypt.ne(zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfosigned()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o.crypt, 6)
	}
	if o.cert.ne(zzz_vproto_internal_new_cmsgsteamdatagramcertificatesigned()) {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 7)
	}
	if o.virtual_port != u32(0) {
		res << vproto.pack_uint32_field(o.virtual_port, 9)
	}
	return res
}

pub fn cmsgsteamnetworkingp2prendezvous_connectrequest_unpack(buf []byte) ?CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
	mut res := zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			6 {
				i, res.crypt = zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(cur_buf,
					tag_wiretype.wire_type) ?
			}
			7 {
				i, res.cert = zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type) ?
			}
			9 {
				i, res.virtual_port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamNetworkingP2PRendezvous_ConnectRequest) eq(b CMsgSteamNetworkingP2PRendezvous_ConnectRequest) bool {
	return true && a.crypt.eq(b.crypt) && a.cert.eq(b.cert) && a.virtual_port == b.virtual_port
}

[inline]
pub fn (a CMsgSteamNetworkingP2PRendezvous_ConnectRequest) ne(b CMsgSteamNetworkingP2PRendezvous_ConnectRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PRendezvous_ConnectRequest) eq(b []CMsgSteamNetworkingP2PRendezvous_ConnectRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PRendezvous_ConnectRequest) ne(b []CMsgSteamNetworkingP2PRendezvous_ConnectRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectrequest() CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
	return CMsgSteamNetworkingP2PRendezvous_ConnectRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectrequest(o CMsgSteamNetworkingP2PRendezvous_ConnectRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PRendezvous_ConnectRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamnetworkingp2prendezvous_connectrequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PRendezvous_ConnectOK {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	crypt          CMsgSteamDatagramSessionCryptInfoSigned
	cert           CMsgSteamDatagramCertificateSigned
}

pub fn (o &CMsgSteamNetworkingP2PRendezvous_ConnectOK) pack() []byte {
	mut res := []byte{}
	if o.crypt.ne(zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfosigned()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o.crypt, 5)
	}
	if o.cert.ne(zzz_vproto_internal_new_cmsgsteamdatagramcertificatesigned()) {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 6)
	}
	return res
}

pub fn cmsgsteamnetworkingp2prendezvous_connectok_unpack(buf []byte) ?CMsgSteamNetworkingP2PRendezvous_ConnectOK {
	mut res := zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectok()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			5 {
				i, res.crypt = zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(cur_buf,
					tag_wiretype.wire_type) ?
			}
			6 {
				i, res.cert = zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamNetworkingP2PRendezvous_ConnectOK) eq(b CMsgSteamNetworkingP2PRendezvous_ConnectOK) bool {
	return true && a.crypt.eq(b.crypt) && a.cert.eq(b.cert)
}

[inline]
pub fn (a CMsgSteamNetworkingP2PRendezvous_ConnectOK) ne(b CMsgSteamNetworkingP2PRendezvous_ConnectOK) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PRendezvous_ConnectOK) eq(b []CMsgSteamNetworkingP2PRendezvous_ConnectOK) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PRendezvous_ConnectOK) ne(b []CMsgSteamNetworkingP2PRendezvous_ConnectOK) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectok() CMsgSteamNetworkingP2PRendezvous_ConnectOK {
	return CMsgSteamNetworkingP2PRendezvous_ConnectOK{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectok(o CMsgSteamNetworkingP2PRendezvous_ConnectOK, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectok(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PRendezvous_ConnectOK) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamnetworkingp2prendezvous_connectok_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	debug          string
	reason_code    u32
}

pub fn (o &CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) pack() []byte {
	mut res := []byte{}
	if o.debug != '' {
		res << vproto.pack_string_field(o.debug, 5)
	}
	if o.reason_code != u32(0) {
		res << vproto.pack_uint32_field(o.reason_code, 6)
	}
	return res
}

pub fn cmsgsteamnetworkingp2prendezvous_connectionclosed_unpack(buf []byte) ?CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
	mut res := zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectionclosed()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			5 {
				i, res.debug = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.reason_code = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) eq(b CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) bool {
	return true && a.debug == b.debug && a.reason_code == b.reason_code
}

[inline]
pub fn (a CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) ne(b CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) eq(b []CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) ne(b []CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectionclosed() CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
	return CMsgSteamNetworkingP2PRendezvous_ConnectionClosed{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectionclosed(o CMsgSteamNetworkingP2PRendezvous_ConnectionClosed, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectionclosed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamnetworkingp2prendezvous_connectionclosed_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ice            CMsgICERendezvous
}

pub fn (o &CMsgSteamNetworkingP2PRendezvous_ReliableMessage) pack() []byte {
	mut res := []byte{}
	if o.ice.ne(zzz_vproto_internal_new_cmsgicerendezvous()) {
		res << zzz_vproto_internal_pack_cmsgicerendezvous(o.ice, 1)
	}
	return res
}

pub fn cmsgsteamnetworkingp2prendezvous_reliablemessage_unpack(buf []byte) ?CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
	mut res := zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_reliablemessage()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.ice = zzz_vproto_internal_unpack_cmsgicerendezvous(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamNetworkingP2PRendezvous_ReliableMessage) eq(b CMsgSteamNetworkingP2PRendezvous_ReliableMessage) bool {
	return true && a.ice.eq(b.ice)
}

[inline]
pub fn (a CMsgSteamNetworkingP2PRendezvous_ReliableMessage) ne(b CMsgSteamNetworkingP2PRendezvous_ReliableMessage) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PRendezvous_ReliableMessage) eq(b []CMsgSteamNetworkingP2PRendezvous_ReliableMessage) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PRendezvous_ReliableMessage) ne(b []CMsgSteamNetworkingP2PRendezvous_ReliableMessage) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_reliablemessage() CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
	return CMsgSteamNetworkingP2PRendezvous_ReliableMessage{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_reliablemessage(o CMsgSteamNetworkingP2PRendezvous_ReliableMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_reliablemessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PRendezvous_ReliableMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamnetworkingp2prendezvous_reliablemessage_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PRendezvous {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	from_identity            string
	from_connection_id       u32
	to_identity              string
	to_connection_id         u32
	sdr_routes               []byte
	ack_peer_routes_revision u32
	ice_enabled              bool
	connect_request          CMsgSteamNetworkingP2PRendezvous_ConnectRequest
	connect_ok               CMsgSteamNetworkingP2PRendezvous_ConnectOK
	connection_closed        CMsgSteamNetworkingP2PRendezvous_ConnectionClosed
	ack_reliable_msg         u32
	first_reliable_msg       u32
	reliable_messages        []CMsgSteamNetworkingP2PRendezvous_ReliableMessage
}

pub fn (o &CMsgSteamNetworkingP2PRendezvous) pack() []byte {
	mut res := []byte{}
	if o.from_identity != '' {
		res << vproto.pack_string_field(o.from_identity, 8)
	}
	if o.from_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.from_connection_id, 9)
	}
	if o.to_identity != '' {
		res << vproto.pack_string_field(o.to_identity, 10)
	}
	if o.to_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.to_connection_id, 1)
	}
	if o.sdr_routes != []byte{} {
		res << vproto.pack_bytes_field(o.sdr_routes, 2)
	}
	if o.ack_peer_routes_revision != u32(0) {
		res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 3)
	}
	if o.ice_enabled != false {
		res << vproto.pack_bool_field(o.ice_enabled, 7)
	}
	if o.connect_request.ne(zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectrequest()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectrequest(o.connect_request, 4)
	}
	if o.connect_ok.ne(zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectok()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectok(o.connect_ok, 5)
	}
	if o.connection_closed.ne(zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectionclosed()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectionclosed(o.connection_closed, 6)
	}
	if o.ack_reliable_msg != u32(0) {
		res << vproto.pack_uint32_field(o.ack_reliable_msg, 11)
	}
	if o.first_reliable_msg != u32(0) {
		res << vproto.pack_uint32_field(o.first_reliable_msg, 12)
	}
	// [packed=false]
	for _, x in o.reliable_messages {
		res <<
			zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_reliablemessage(x, 13)
	}
	return res
}

pub fn cmsgsteamnetworkingp2prendezvous_unpack(buf []byte) ?CMsgSteamNetworkingP2PRendezvous {
	mut res := zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			8 {
				i, res.from_identity = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.from_connection_id = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.to_identity = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			1 {
				i, res.to_connection_id = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.sdr_routes = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.ack_peer_routes_revision = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			7 {
				i, res.ice_enabled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.connect_request = zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectrequest(cur_buf,
					tag_wiretype.wire_type) ?
			}
			5 {
				i, res.connect_ok = zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectok(cur_buf,
					tag_wiretype.wire_type) ?
			}
			6 {
				i, res.connection_closed = zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectionclosed(cur_buf,
					tag_wiretype.wire_type) ?
			}
			11 {
				i, res.ack_reliable_msg = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			12 {
				i, res.first_reliable_msg = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			13 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_reliablemessage(cur_buf,
					tag_wiretype.wire_type) ?
				res.reliable_messages << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamNetworkingP2PRendezvous) eq(b CMsgSteamNetworkingP2PRendezvous) bool {
	return true && a.from_identity == b.from_identity && a.from_connection_id == b.from_connection_id &&
		a.to_identity == b.to_identity && a.to_connection_id == b.to_connection_id && a.sdr_routes ==
		b.sdr_routes && a.ack_peer_routes_revision == b.ack_peer_routes_revision && a.ice_enabled == b.ice_enabled &&
		a.connect_request.eq(b.connect_request) && a.connect_ok.eq(b.connect_ok) && a.connection_closed.eq(b.connection_closed) &&
		a.ack_reliable_msg == b.ack_reliable_msg && a.first_reliable_msg == b.first_reliable_msg && a.reliable_messages.eq(b.reliable_messages)
}

[inline]
pub fn (a CMsgSteamNetworkingP2PRendezvous) ne(b CMsgSteamNetworkingP2PRendezvous) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PRendezvous) eq(b []CMsgSteamNetworkingP2PRendezvous) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PRendezvous) ne(b []CMsgSteamNetworkingP2PRendezvous) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous() CMsgSteamNetworkingP2PRendezvous {
	return CMsgSteamNetworkingP2PRendezvous{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous(o CMsgSteamNetworkingP2PRendezvous, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PRendezvous) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamnetworkingp2prendezvous_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamNetworkingICESessionSummary {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	failure_reason_code    u32
	local_candidate_types  u32
	remote_candidate_types u32
	initial_route_kind     u32
	initial_ping           u32
	initial_score          u32
	negotiation_ms         u32
	selected_seconds       u32
}

pub fn (o &CMsgSteamNetworkingICESessionSummary) pack() []byte {
	mut res := []byte{}
	if o.failure_reason_code != u32(0) {
		res << vproto.pack_uint32_field(o.failure_reason_code, 7)
	}
	if o.local_candidate_types != u32(0) {
		res << vproto.pack_uint32_field(o.local_candidate_types, 1)
	}
	if o.remote_candidate_types != u32(0) {
		res << vproto.pack_uint32_field(o.remote_candidate_types, 2)
	}
	if o.initial_route_kind != u32(0) {
		res << vproto.pack_uint32_field(o.initial_route_kind, 3)
	}
	if o.initial_ping != u32(0) {
		res << vproto.pack_uint32_field(o.initial_ping, 4)
	}
	if o.initial_score != u32(0) {
		res << vproto.pack_uint32_field(o.initial_score, 6)
	}
	if o.negotiation_ms != u32(0) {
		res << vproto.pack_uint32_field(o.negotiation_ms, 5)
	}
	if o.selected_seconds != u32(0) {
		res << vproto.pack_uint32_field(o.selected_seconds, 12)
	}
	return res
}

pub fn cmsgsteamnetworkingicesessionsummary_unpack(buf []byte) ?CMsgSteamNetworkingICESessionSummary {
	mut res := zzz_vproto_internal_new_cmsgsteamnetworkingicesessionsummary()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			7 {
				i, res.failure_reason_code = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			1 {
				i, res.local_candidate_types = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.remote_candidate_types = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.initial_route_kind = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.initial_ping = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.initial_score = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.negotiation_ms = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			12 {
				i, res.selected_seconds = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamNetworkingICESessionSummary) eq(b CMsgSteamNetworkingICESessionSummary) bool {
	return true && a.failure_reason_code == b.failure_reason_code && a.local_candidate_types ==
		b.local_candidate_types && a.remote_candidate_types == b.remote_candidate_types && a.initial_route_kind ==
		b.initial_route_kind && a.initial_ping == b.initial_ping && a.initial_score == b.initial_score &&
		a.negotiation_ms == b.negotiation_ms && a.selected_seconds == b.selected_seconds
}

[inline]
pub fn (a CMsgSteamNetworkingICESessionSummary) ne(b CMsgSteamNetworkingICESessionSummary) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamNetworkingICESessionSummary) eq(b []CMsgSteamNetworkingICESessionSummary) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamNetworkingICESessionSummary) ne(b []CMsgSteamNetworkingICESessionSummary) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingicesessionsummary() CMsgSteamNetworkingICESessionSummary {
	return CMsgSteamNetworkingICESessionSummary{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingicesessionsummary(o CMsgSteamNetworkingICESessionSummary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingicesessionsummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingICESessionSummary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamnetworkingicesessionsummary_unpack(v) ?
	return i, unpacked
}
