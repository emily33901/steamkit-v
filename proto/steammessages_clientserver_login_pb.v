// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CMsgClientHeartBeat {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientHeartBeat) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientheartbeat_unpack(buf []byte) ?CMsgClientHeartBeat {
	res := zzz_vproto_internal_new_cmsgclientheartbeat()
	return res
}

[inline]
pub fn (a CMsgClientHeartBeat) eq(b CMsgClientHeartBeat) bool {
	return true
}

[inline]
pub fn (a CMsgClientHeartBeat) ne(b CMsgClientHeartBeat) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientHeartBeat) eq(b []CMsgClientHeartBeat) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientHeartBeat) ne(b []CMsgClientHeartBeat) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientheartbeat() CMsgClientHeartBeat {
	return CMsgClientHeartBeat{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientheartbeat(o CMsgClientHeartBeat, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientheartbeat(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientHeartBeat) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientheartbeat_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientServerTimestampRequest {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	client_request_timestamp u64
}

pub fn (o &CMsgClientServerTimestampRequest) pack() []byte {
	mut res := []byte{}
	if o.client_request_timestamp != u64(0) {
		res << vproto.pack_uint64_field(o.client_request_timestamp, 1)
	}
	return res
}

pub fn cmsgclientservertimestamprequest_unpack(buf []byte) ?CMsgClientServerTimestampRequest {
	mut res := zzz_vproto_internal_new_cmsgclientservertimestamprequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.client_request_timestamp = vproto.unpack_uint64_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientServerTimestampRequest) eq(b CMsgClientServerTimestampRequest) bool {
	return true && a.client_request_timestamp == b.client_request_timestamp
}

[inline]
pub fn (a CMsgClientServerTimestampRequest) ne(b CMsgClientServerTimestampRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientServerTimestampRequest) eq(b []CMsgClientServerTimestampRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientServerTimestampRequest) ne(b []CMsgClientServerTimestampRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientservertimestamprequest() CMsgClientServerTimestampRequest {
	return CMsgClientServerTimestampRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientservertimestamprequest(o CMsgClientServerTimestampRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientservertimestamprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServerTimestampRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientservertimestamprequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientServerTimestampResponse {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	client_request_timestamp u64
	server_timestamp_ms      u64
}

pub fn (o &CMsgClientServerTimestampResponse) pack() []byte {
	mut res := []byte{}
	if o.client_request_timestamp != u64(0) {
		res << vproto.pack_uint64_field(o.client_request_timestamp, 1)
	}
	if o.server_timestamp_ms != u64(0) {
		res << vproto.pack_uint64_field(o.server_timestamp_ms, 2)
	}
	return res
}

pub fn cmsgclientservertimestampresponse_unpack(buf []byte) ?CMsgClientServerTimestampResponse {
	mut res := zzz_vproto_internal_new_cmsgclientservertimestampresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.client_request_timestamp = vproto.unpack_uint64_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			2 {
				i, res.server_timestamp_ms = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientServerTimestampResponse) eq(b CMsgClientServerTimestampResponse) bool {
	return true && a.client_request_timestamp == b.client_request_timestamp && a.server_timestamp_ms ==
		b.server_timestamp_ms
}

[inline]
pub fn (a CMsgClientServerTimestampResponse) ne(b CMsgClientServerTimestampResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientServerTimestampResponse) eq(b []CMsgClientServerTimestampResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientServerTimestampResponse) ne(b []CMsgClientServerTimestampResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientservertimestampresponse() CMsgClientServerTimestampResponse {
	return CMsgClientServerTimestampResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientservertimestampresponse(o CMsgClientServerTimestampResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientservertimestampresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServerTimestampResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientservertimestampresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSecret {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	version        u32
	appid          u32
	deviceid       u32
	nonce          u64
	hmac           []byte
}

pub fn (o &CMsgClientSecret) pack() []byte {
	mut res := []byte{}
	if o.version != u32(0) {
		res << vproto.pack_uint32_field(o.version, 1)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.deviceid != u32(0) {
		res << vproto.pack_uint32_field(o.deviceid, 3)
	}
	if o.nonce != u64(0) {
		res << vproto.pack_64bit_field(o.nonce, 4)
	}
	if o.hmac != []byte{} {
		res << vproto.pack_bytes_field(o.hmac, 5)
	}
	return res
}

pub fn cmsgclientsecret_unpack(buf []byte) ?CMsgClientSecret {
	mut res := zzz_vproto_internal_new_cmsgclientsecret()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.version = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.deviceid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.nonce = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.hmac = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSecret) eq(b CMsgClientSecret) bool {
	return true && a.version == b.version && a.appid == b.appid && a.deviceid == b.deviceid &&
		a.nonce == b.nonce && a.hmac == b.hmac
}

[inline]
pub fn (a CMsgClientSecret) ne(b CMsgClientSecret) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSecret) eq(b []CMsgClientSecret) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSecret) ne(b []CMsgClientSecret) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsecret() CMsgClientSecret {
	return CMsgClientSecret{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsecret(o CMsgClientSecret, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsecret(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSecret) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsecret_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLogon {
mut:
	unknown_fields                          []vproto.UnknownField
pub mut:
	protocol_version                        u32
	deprecated_obfustucated_private_ip      u32
	cell_id                                 u32
	last_session_id                         u32
	client_package_version                  u32
	client_language                         string
	client_os_type                          u32
	should_remember_password                bool
	wine_version                            string
	deprecated_10                           u32
	obfuscated_private_ip                   CMsgIPAddress
	deprecated_public_ip                    u32
	qos_level                               u32
	client_supplied_steam_id                u64
	public_ip                               CMsgIPAddress
	machine_id                              []byte
	launcher_type                           u32
	ui_mode                                 u32
	chat_mode                               u32
	steam2_auth_ticket                      []byte
	email_address                           string
	rtime32_account_creation                u32
	account_name                            string
	password                                string
	game_server_token                       string
	login_key                               string
	was_converted_deprecated_msg            bool
	anon_user_target_account_name           string
	resolved_user_steam_id                  u64
	eresult_sentryfile                      int
	sha_sentryfile                          []byte
	auth_code                               string
	otp_type                                int
	otp_value                               u32
	otp_identifier                          string
	steam2_ticket_request                   bool
	sony_psn_ticket                         []byte
	sony_psn_service_id                     string
	create_new_psn_linked_account_if_needed bool
	sony_psn_name                           string
	game_server_app_id                      int
	steamguard_dont_remember_computer       bool
	machine_name                            string
	machine_name_userchosen                 string
	country_override                        string
	is_steam_box                            bool
	client_instance_id                      u64
	two_factor_code                         string
	supports_rate_limit_response            bool
	web_logon_nonce                         string
	priority_reason                         int
	embedded_client_secret                  CMsgClientSecret
	disable_partner_autogrants              bool
}

pub fn (o &CMsgClientLogon) pack() []byte {
	mut res := []byte{}
	if o.protocol_version != u32(0) {
		res << vproto.pack_uint32_field(o.protocol_version, 1)
	}
	if o.deprecated_obfustucated_private_ip != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_obfustucated_private_ip, 2)
	}
	if o.cell_id != u32(0) {
		res << vproto.pack_uint32_field(o.cell_id, 3)
	}
	if o.last_session_id != u32(0) {
		res << vproto.pack_uint32_field(o.last_session_id, 4)
	}
	if o.client_package_version != u32(0) {
		res << vproto.pack_uint32_field(o.client_package_version, 5)
	}
	if o.client_language != '' {
		res << vproto.pack_string_field(o.client_language, 6)
	}
	if o.client_os_type != u32(0) {
		res << vproto.pack_uint32_field(o.client_os_type, 7)
	}
	if o.should_remember_password != false {
		res << vproto.pack_bool_field(o.should_remember_password, 8)
	}
	if o.wine_version != '' {
		res << vproto.pack_string_field(o.wine_version, 9)
	}
	if o.deprecated_10 != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_10, 10)
	}
	if o.obfuscated_private_ip.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.obfuscated_private_ip, 11)
	}
	if o.deprecated_public_ip != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 20)
	}
	if o.qos_level != u32(0) {
		res << vproto.pack_uint32_field(o.qos_level, 21)
	}
	if o.client_supplied_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.client_supplied_steam_id, 22)
	}
	if o.public_ip.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 23)
	}
	if o.machine_id != []byte{} {
		res << vproto.pack_bytes_field(o.machine_id, 30)
	}
	if o.launcher_type != u32(0) {
		res << vproto.pack_uint32_field(o.launcher_type, 31)
	}
	if o.ui_mode != u32(0) {
		res << vproto.pack_uint32_field(o.ui_mode, 32)
	}
	if o.chat_mode != u32(0) {
		res << vproto.pack_uint32_field(o.chat_mode, 33)
	}
	if o.steam2_auth_ticket != []byte{} {
		res << vproto.pack_bytes_field(o.steam2_auth_ticket, 41)
	}
	if o.email_address != '' {
		res << vproto.pack_string_field(o.email_address, 42)
	}
	if o.rtime32_account_creation != u32(0) {
		res << vproto.pack_32bit_field(o.rtime32_account_creation, 43)
	}
	if o.account_name != '' {
		res << vproto.pack_string_field(o.account_name, 50)
	}
	if o.password != '' {
		res << vproto.pack_string_field(o.password, 51)
	}
	if o.game_server_token != '' {
		res << vproto.pack_string_field(o.game_server_token, 52)
	}
	if o.login_key != '' {
		res << vproto.pack_string_field(o.login_key, 60)
	}
	if o.was_converted_deprecated_msg != false {
		res << vproto.pack_bool_field(o.was_converted_deprecated_msg, 70)
	}
	if o.anon_user_target_account_name != '' {
		res << vproto.pack_string_field(o.anon_user_target_account_name, 80)
	}
	if o.resolved_user_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.resolved_user_steam_id, 81)
	}
	if o.eresult_sentryfile != int(0) {
		res << vproto.pack_int32_field(o.eresult_sentryfile, 82)
	}
	if o.sha_sentryfile != []byte{} {
		res << vproto.pack_bytes_field(o.sha_sentryfile, 83)
	}
	if o.auth_code != '' {
		res << vproto.pack_string_field(o.auth_code, 84)
	}
	if o.otp_type != int(0) {
		res << vproto.pack_int32_field(o.otp_type, 85)
	}
	if o.otp_value != u32(0) {
		res << vproto.pack_uint32_field(o.otp_value, 86)
	}
	if o.otp_identifier != '' {
		res << vproto.pack_string_field(o.otp_identifier, 87)
	}
	if o.steam2_ticket_request != false {
		res << vproto.pack_bool_field(o.steam2_ticket_request, 88)
	}
	if o.sony_psn_ticket != []byte{} {
		res << vproto.pack_bytes_field(o.sony_psn_ticket, 90)
	}
	if o.sony_psn_service_id != '' {
		res << vproto.pack_string_field(o.sony_psn_service_id, 91)
	}
	if o.create_new_psn_linked_account_if_needed != false {
		res << vproto.pack_bool_field(o.create_new_psn_linked_account_if_needed, 92)
	}
	if o.sony_psn_name != '' {
		res << vproto.pack_string_field(o.sony_psn_name, 93)
	}
	if o.game_server_app_id != int(0) {
		res << vproto.pack_int32_field(o.game_server_app_id, 94)
	}
	if o.steamguard_dont_remember_computer != false {
		res << vproto.pack_bool_field(o.steamguard_dont_remember_computer, 95)
	}
	if o.machine_name != '' {
		res << vproto.pack_string_field(o.machine_name, 96)
	}
	if o.machine_name_userchosen != '' {
		res << vproto.pack_string_field(o.machine_name_userchosen, 97)
	}
	if o.country_override != '' {
		res << vproto.pack_string_field(o.country_override, 98)
	}
	if o.is_steam_box != false {
		res << vproto.pack_bool_field(o.is_steam_box, 99)
	}
	if o.client_instance_id != u64(0) {
		res << vproto.pack_uint64_field(o.client_instance_id, 100)
	}
	if o.two_factor_code != '' {
		res << vproto.pack_string_field(o.two_factor_code, 101)
	}
	if o.supports_rate_limit_response != false {
		res << vproto.pack_bool_field(o.supports_rate_limit_response, 102)
	}
	if o.web_logon_nonce != '' {
		res << vproto.pack_string_field(o.web_logon_nonce, 103)
	}
	if o.priority_reason != int(0) {
		res << vproto.pack_int32_field(o.priority_reason, 104)
	}
	if o.embedded_client_secret.ne(zzz_vproto_internal_new_cmsgclientsecret()) {
		res <<
			zzz_vproto_internal_pack_cmsgclientsecret(o.embedded_client_secret, 105)
	}
	if o.disable_partner_autogrants != false {
		res << vproto.pack_bool_field(o.disable_partner_autogrants, 106)
	}
	return res
}

pub fn cmsgclientlogon_unpack(buf []byte) ?CMsgClientLogon {
	mut res := zzz_vproto_internal_new_cmsgclientlogon()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.protocol_version = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.deprecated_obfustucated_private_ip = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			3 {
				i, res.cell_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.last_session_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.client_package_version = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.client_language = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.client_os_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.should_remember_password = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.wine_version = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.deprecated_10 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				i, res.obfuscated_private_ip = zzz_vproto_internal_unpack_cmsgipaddress(cur_buf,
					tag_wiretype.wire_type) ?
			}
			20 {
				i, res.deprecated_public_ip = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			21 {
				i, res.qos_level = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			22 {
				i, res.client_supplied_steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			23 {
				i, res.public_ip = zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type) ?
			}
			30 {
				i, res.machine_id = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			31 {
				i, res.launcher_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			32 {
				i, res.ui_mode = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			33 {
				i, res.chat_mode = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			41 {
				i, res.steam2_auth_ticket = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			42 {
				i, res.email_address = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			43 {
				i, res.rtime32_account_creation = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			50 {
				i, res.account_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			51 {
				i, res.password = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			52 {
				i, res.game_server_token = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			60 {
				i, res.login_key = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			70 {
				i, res.was_converted_deprecated_msg = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			80 {
				i, res.anon_user_target_account_name = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			81 {
				i, res.resolved_user_steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			82 {
				i, res.eresult_sentryfile = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			83 {
				i, res.sha_sentryfile = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			84 {
				i, res.auth_code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			85 {
				i, res.otp_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			86 {
				i, res.otp_value = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			87 {
				i, res.otp_identifier = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			88 {
				i, res.steam2_ticket_request = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			90 {
				i, res.sony_psn_ticket = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			91 {
				i, res.sony_psn_service_id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			92 {
				i, res.create_new_psn_linked_account_if_needed = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			93 {
				i, res.sony_psn_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			94 {
				i, res.game_server_app_id = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			95 {
				i, res.steamguard_dont_remember_computer = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			96 {
				i, res.machine_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			97 {
				i, res.machine_name_userchosen = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			98 {
				i, res.country_override = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			99 {
				i, res.is_steam_box = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			100 {
				i, res.client_instance_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			101 {
				i, res.two_factor_code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			102 {
				i, res.supports_rate_limit_response = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			103 {
				i, res.web_logon_nonce = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			104 {
				i, res.priority_reason = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			105 {
				i, res.embedded_client_secret = zzz_vproto_internal_unpack_cmsgclientsecret(cur_buf,
					tag_wiretype.wire_type) ?
			}
			106 {
				i, res.disable_partner_autogrants = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLogon) eq(b CMsgClientLogon) bool {
	return true && a.protocol_version == b.protocol_version && a.deprecated_obfustucated_private_ip ==
		b.deprecated_obfustucated_private_ip && a.cell_id == b.cell_id && a.last_session_id == b.last_session_id &&
		a.client_package_version == b.client_package_version && a.client_language == b.client_language &&
		a.client_os_type == b.client_os_type && a.should_remember_password == b.should_remember_password &&
		a.wine_version == b.wine_version && a.deprecated_10 == b.deprecated_10 && a.obfuscated_private_ip.eq(b.obfuscated_private_ip) &&
		a.deprecated_public_ip == b.deprecated_public_ip && a.qos_level == b.qos_level && a.client_supplied_steam_id ==
		b.client_supplied_steam_id && a.public_ip.eq(b.public_ip) && a.machine_id == b.machine_id &&
		a.launcher_type == b.launcher_type && a.ui_mode == b.ui_mode && a.chat_mode == b.chat_mode &&
		a.steam2_auth_ticket == b.steam2_auth_ticket && a.email_address == b.email_address &&
		a.rtime32_account_creation == b.rtime32_account_creation && a.account_name == b.account_name &&
		a.password == b.password && a.game_server_token == b.game_server_token && a.login_key == b.login_key &&
		a.was_converted_deprecated_msg == b.was_converted_deprecated_msg && a.anon_user_target_account_name ==
		b.anon_user_target_account_name && a.resolved_user_steam_id == b.resolved_user_steam_id &&
		a.eresult_sentryfile == b.eresult_sentryfile && a.sha_sentryfile == b.sha_sentryfile &&
		a.auth_code == b.auth_code && a.otp_type == b.otp_type && a.otp_value == b.otp_value &&
		a.otp_identifier == b.otp_identifier && a.steam2_ticket_request == b.steam2_ticket_request &&
		a.sony_psn_ticket == b.sony_psn_ticket && a.sony_psn_service_id == b.sony_psn_service_id &&
		a.create_new_psn_linked_account_if_needed == b.create_new_psn_linked_account_if_needed &&
		a.sony_psn_name == b.sony_psn_name && a.game_server_app_id == b.game_server_app_id &&
		a.steamguard_dont_remember_computer == b.steamguard_dont_remember_computer && a.machine_name ==
		b.machine_name && a.machine_name_userchosen == b.machine_name_userchosen && a.country_override ==
		b.country_override && a.is_steam_box == b.is_steam_box && a.client_instance_id == b.client_instance_id &&
		a.two_factor_code == b.two_factor_code && a.supports_rate_limit_response == b.supports_rate_limit_response &&
		a.web_logon_nonce == b.web_logon_nonce && a.priority_reason == b.priority_reason &&
		a.embedded_client_secret.eq(b.embedded_client_secret) && a.disable_partner_autogrants == b.disable_partner_autogrants
}

[inline]
pub fn (a CMsgClientLogon) ne(b CMsgClientLogon) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLogon) eq(b []CMsgClientLogon) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLogon) ne(b []CMsgClientLogon) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlogon() CMsgClientLogon {
	return CMsgClientLogon{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlogon(o CMsgClientLogon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlogon(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLogon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlogon_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLogonResponse {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	eresult                        int = 2
	out_of_game_heartbeat_seconds  int
	in_game_heartbeat_seconds      int
	deprecated_public_ip           u32
	rtime32_server_time            u32
	account_flags                  u32
	cell_id                        u32
	email_domain                   string
	steam2_ticket                  []byte
	eresult_extended               int
	webapi_authenticate_user_nonce string
	cell_id_ping_threshold         u32
	deprecated_use_pics            bool
	vanity_url                     string
	public_ip                      CMsgIPAddress
	client_supplied_steamid        u64
	ip_country_code                string
	parental_settings              []byte
	parental_setting_signature     []byte
	count_loginfailures_to_migrate int
	count_disconnects_to_migrate   int
	ogs_data_report_time_window    int
	client_instance_id             u64
	force_client_update_check      bool
}

pub fn (o &CMsgClientLogonResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.out_of_game_heartbeat_seconds != int(0) {
		res << vproto.pack_int32_field(o.out_of_game_heartbeat_seconds, 2)
	}
	if o.in_game_heartbeat_seconds != int(0) {
		res << vproto.pack_int32_field(o.in_game_heartbeat_seconds, 3)
	}
	if o.deprecated_public_ip != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 4)
	}
	if o.rtime32_server_time != u32(0) {
		res << vproto.pack_32bit_field(o.rtime32_server_time, 5)
	}
	if o.account_flags != u32(0) {
		res << vproto.pack_uint32_field(o.account_flags, 6)
	}
	if o.cell_id != u32(0) {
		res << vproto.pack_uint32_field(o.cell_id, 7)
	}
	if o.email_domain != '' {
		res << vproto.pack_string_field(o.email_domain, 8)
	}
	if o.steam2_ticket != []byte{} {
		res << vproto.pack_bytes_field(o.steam2_ticket, 9)
	}
	if o.eresult_extended != int(0) {
		res << vproto.pack_int32_field(o.eresult_extended, 10)
	}
	if o.webapi_authenticate_user_nonce != '' {
		res << vproto.pack_string_field(o.webapi_authenticate_user_nonce, 11)
	}
	if o.cell_id_ping_threshold != u32(0) {
		res << vproto.pack_uint32_field(o.cell_id_ping_threshold, 12)
	}
	if o.deprecated_use_pics != false {
		res << vproto.pack_bool_field(o.deprecated_use_pics, 13)
	}
	if o.vanity_url != '' {
		res << vproto.pack_string_field(o.vanity_url, 14)
	}
	if o.public_ip.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 15)
	}
	if o.client_supplied_steamid != u64(0) {
		res << vproto.pack_64bit_field(o.client_supplied_steamid, 20)
	}
	if o.ip_country_code != '' {
		res << vproto.pack_string_field(o.ip_country_code, 21)
	}
	if o.parental_settings != []byte{} {
		res << vproto.pack_bytes_field(o.parental_settings, 22)
	}
	if o.parental_setting_signature != []byte{} {
		res << vproto.pack_bytes_field(o.parental_setting_signature, 23)
	}
	if o.count_loginfailures_to_migrate != int(0) {
		res << vproto.pack_int32_field(o.count_loginfailures_to_migrate, 24)
	}
	if o.count_disconnects_to_migrate != int(0) {
		res << vproto.pack_int32_field(o.count_disconnects_to_migrate, 25)
	}
	if o.ogs_data_report_time_window != int(0) {
		res << vproto.pack_int32_field(o.ogs_data_report_time_window, 26)
	}
	if o.client_instance_id != u64(0) {
		res << vproto.pack_uint64_field(o.client_instance_id, 27)
	}
	if o.force_client_update_check != false {
		res << vproto.pack_bool_field(o.force_client_update_check, 28)
	}
	return res
}

pub fn cmsgclientlogonresponse_unpack(buf []byte) ?CMsgClientLogonResponse {
	mut res := zzz_vproto_internal_new_cmsgclientlogonresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.out_of_game_heartbeat_seconds = vproto.unpack_int32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			3 {
				i, res.in_game_heartbeat_seconds = vproto.unpack_int32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			4 {
				i, res.deprecated_public_ip = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.rtime32_server_time = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.account_flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.cell_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.email_domain = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.steam2_ticket = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.eresult_extended = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				i, res.webapi_authenticate_user_nonce = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			12 {
				i, res.cell_id_ping_threshold = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			13 {
				i, res.deprecated_use_pics = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			14 {
				i, res.vanity_url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			15 {
				i, res.public_ip = zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type) ?
			}
			20 {
				i, res.client_supplied_steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			21 {
				i, res.ip_country_code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			22 {
				i, res.parental_settings = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			23 {
				i, res.parental_setting_signature = vproto.unpack_bytes_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			24 {
				i, res.count_loginfailures_to_migrate = vproto.unpack_int32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			25 {
				i, res.count_disconnects_to_migrate = vproto.unpack_int32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			26 {
				i, res.ogs_data_report_time_window = vproto.unpack_int32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			27 {
				i, res.client_instance_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			28 {
				i, res.force_client_update_check = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLogonResponse) eq(b CMsgClientLogonResponse) bool {
	return true && a.eresult == b.eresult && a.out_of_game_heartbeat_seconds == b.out_of_game_heartbeat_seconds &&
		a.in_game_heartbeat_seconds == b.in_game_heartbeat_seconds && a.deprecated_public_ip == b.deprecated_public_ip &&
		a.rtime32_server_time == b.rtime32_server_time && a.account_flags == b.account_flags &&
		a.cell_id == b.cell_id && a.email_domain == b.email_domain && a.steam2_ticket == b.steam2_ticket &&
		a.eresult_extended == b.eresult_extended && a.webapi_authenticate_user_nonce == b.webapi_authenticate_user_nonce &&
		a.cell_id_ping_threshold == b.cell_id_ping_threshold && a.deprecated_use_pics == b.deprecated_use_pics &&
		a.vanity_url == b.vanity_url && a.public_ip.eq(b.public_ip) && a.client_supplied_steamid == b.client_supplied_steamid &&
		a.ip_country_code == b.ip_country_code && a.parental_settings == b.parental_settings &&
		a.parental_setting_signature == b.parental_setting_signature && a.count_loginfailures_to_migrate ==
		b.count_loginfailures_to_migrate && a.count_disconnects_to_migrate == b.count_disconnects_to_migrate &&
		a.ogs_data_report_time_window == b.ogs_data_report_time_window && a.client_instance_id == b.client_instance_id &&
		a.force_client_update_check == b.force_client_update_check
}

[inline]
pub fn (a CMsgClientLogonResponse) ne(b CMsgClientLogonResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLogonResponse) eq(b []CMsgClientLogonResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLogonResponse) ne(b []CMsgClientLogonResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlogonresponse() CMsgClientLogonResponse {
	return CMsgClientLogonResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlogonresponse(o CMsgClientLogonResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlogonresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLogonResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlogonresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRequestWebAPIAuthenticateUserNonce {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	token_type     int = -1
}

pub fn (o &CMsgClientRequestWebAPIAuthenticateUserNonce) pack() []byte {
	mut res := []byte{}
	if o.token_type != int(0) {
		res << vproto.pack_int32_field(o.token_type, 1)
	}
	return res
}

pub fn cmsgclientrequestwebapiauthenticateusernonce_unpack(buf []byte) ?CMsgClientRequestWebAPIAuthenticateUserNonce {
	mut res := zzz_vproto_internal_new_cmsgclientrequestwebapiauthenticateusernonce()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.token_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRequestWebAPIAuthenticateUserNonce) eq(b CMsgClientRequestWebAPIAuthenticateUserNonce) bool {
	return true && a.token_type == b.token_type
}

[inline]
pub fn (a CMsgClientRequestWebAPIAuthenticateUserNonce) ne(b CMsgClientRequestWebAPIAuthenticateUserNonce) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRequestWebAPIAuthenticateUserNonce) eq(b []CMsgClientRequestWebAPIAuthenticateUserNonce) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRequestWebAPIAuthenticateUserNonce) ne(b []CMsgClientRequestWebAPIAuthenticateUserNonce) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientrequestwebapiauthenticateusernonce() CMsgClientRequestWebAPIAuthenticateUserNonce {
	return CMsgClientRequestWebAPIAuthenticateUserNonce{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientrequestwebapiauthenticateusernonce(o CMsgClientRequestWebAPIAuthenticateUserNonce, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientrequestwebapiauthenticateusernonce(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestWebAPIAuthenticateUserNonce) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientrequestwebapiauthenticateusernonce_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	eresult                        int = 2
	webapi_authenticate_user_nonce string
	token_type                     int = -1
}

pub fn (o &CMsgClientRequestWebAPIAuthenticateUserNonceResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.webapi_authenticate_user_nonce != '' {
		res << vproto.pack_string_field(o.webapi_authenticate_user_nonce, 11)
	}
	if o.token_type != int(0) {
		res << vproto.pack_int32_field(o.token_type, 3)
	}
	return res
}

pub fn cmsgclientrequestwebapiauthenticateusernonceresponse_unpack(buf []byte) ?CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
	mut res := zzz_vproto_internal_new_cmsgclientrequestwebapiauthenticateusernonceresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				i, res.webapi_authenticate_user_nonce = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			3 {
				i, res.token_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRequestWebAPIAuthenticateUserNonceResponse) eq(b CMsgClientRequestWebAPIAuthenticateUserNonceResponse) bool {
	return true && a.eresult == b.eresult && a.webapi_authenticate_user_nonce == b.webapi_authenticate_user_nonce &&
		a.token_type == b.token_type
}

[inline]
pub fn (a CMsgClientRequestWebAPIAuthenticateUserNonceResponse) ne(b CMsgClientRequestWebAPIAuthenticateUserNonceResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRequestWebAPIAuthenticateUserNonceResponse) eq(b []CMsgClientRequestWebAPIAuthenticateUserNonceResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRequestWebAPIAuthenticateUserNonceResponse) ne(b []CMsgClientRequestWebAPIAuthenticateUserNonceResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientrequestwebapiauthenticateusernonceresponse() CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
	return CMsgClientRequestWebAPIAuthenticateUserNonceResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientrequestwebapiauthenticateusernonceresponse(o CMsgClientRequestWebAPIAuthenticateUserNonceResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientrequestwebapiauthenticateusernonceresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestWebAPIAuthenticateUserNonceResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientrequestwebapiauthenticateusernonceresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLogOff {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientLogOff) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientlogoff_unpack(buf []byte) ?CMsgClientLogOff {
	res := zzz_vproto_internal_new_cmsgclientlogoff()
	return res
}

[inline]
pub fn (a CMsgClientLogOff) eq(b CMsgClientLogOff) bool {
	return true
}

[inline]
pub fn (a CMsgClientLogOff) ne(b CMsgClientLogOff) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLogOff) eq(b []CMsgClientLogOff) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLogOff) ne(b []CMsgClientLogOff) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlogoff() CMsgClientLogOff {
	return CMsgClientLogOff{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlogoff(o CMsgClientLogOff, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlogoff(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLogOff) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlogoff_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLoggedOff {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
}

pub fn (o &CMsgClientLoggedOff) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientloggedoff_unpack(buf []byte) ?CMsgClientLoggedOff {
	mut res := zzz_vproto_internal_new_cmsgclientloggedoff()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLoggedOff) eq(b CMsgClientLoggedOff) bool {
	return true && a.eresult == b.eresult
}

[inline]
pub fn (a CMsgClientLoggedOff) ne(b CMsgClientLoggedOff) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLoggedOff) eq(b []CMsgClientLoggedOff) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLoggedOff) ne(b []CMsgClientLoggedOff) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientloggedoff() CMsgClientLoggedOff {
	return CMsgClientLoggedOff{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientloggedoff(o CMsgClientLoggedOff, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientloggedoff(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLoggedOff) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientloggedoff_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientNewLoginKey {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	unique_id      u32
	login_key      string
}

pub fn (o &CMsgClientNewLoginKey) pack() []byte {
	mut res := []byte{}
	if o.unique_id != u32(0) {
		res << vproto.pack_uint32_field(o.unique_id, 1)
	}
	if o.login_key != '' {
		res << vproto.pack_string_field(o.login_key, 2)
	}
	return res
}

pub fn cmsgclientnewloginkey_unpack(buf []byte) ?CMsgClientNewLoginKey {
	mut res := zzz_vproto_internal_new_cmsgclientnewloginkey()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.unique_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.login_key = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientNewLoginKey) eq(b CMsgClientNewLoginKey) bool {
	return true && a.unique_id == b.unique_id && a.login_key == b.login_key
}

[inline]
pub fn (a CMsgClientNewLoginKey) ne(b CMsgClientNewLoginKey) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientNewLoginKey) eq(b []CMsgClientNewLoginKey) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientNewLoginKey) ne(b []CMsgClientNewLoginKey) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientnewloginkey() CMsgClientNewLoginKey {
	return CMsgClientNewLoginKey{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientnewloginkey(o CMsgClientNewLoginKey, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientnewloginkey(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNewLoginKey) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientnewloginkey_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientNewLoginKeyAccepted {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	unique_id      u32
}

pub fn (o &CMsgClientNewLoginKeyAccepted) pack() []byte {
	mut res := []byte{}
	if o.unique_id != u32(0) {
		res << vproto.pack_uint32_field(o.unique_id, 1)
	}
	return res
}

pub fn cmsgclientnewloginkeyaccepted_unpack(buf []byte) ?CMsgClientNewLoginKeyAccepted {
	mut res := zzz_vproto_internal_new_cmsgclientnewloginkeyaccepted()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.unique_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientNewLoginKeyAccepted) eq(b CMsgClientNewLoginKeyAccepted) bool {
	return true && a.unique_id == b.unique_id
}

[inline]
pub fn (a CMsgClientNewLoginKeyAccepted) ne(b CMsgClientNewLoginKeyAccepted) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientNewLoginKeyAccepted) eq(b []CMsgClientNewLoginKeyAccepted) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientNewLoginKeyAccepted) ne(b []CMsgClientNewLoginKeyAccepted) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientnewloginkeyaccepted() CMsgClientNewLoginKeyAccepted {
	return CMsgClientNewLoginKeyAccepted{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientnewloginkeyaccepted(o CMsgClientNewLoginKeyAccepted, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientnewloginkeyaccepted(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNewLoginKeyAccepted) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientnewloginkeyaccepted_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAccountInfo {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	persona_name                        string
	ip_country                          string
	count_authed_computers              int
	account_flags                       u32
	facebook_id                         u64
	facebook_name                       string
	steamguard_notify_newmachines       bool
	steamguard_machine_name_user_chosen string
	is_phone_verified                   bool
	two_factor_state                    u32
	is_phone_identifying                bool
	is_phone_needing_reverify           bool
}

pub fn (o &CMsgClientAccountInfo) pack() []byte {
	mut res := []byte{}
	if o.persona_name != '' {
		res << vproto.pack_string_field(o.persona_name, 1)
	}
	if o.ip_country != '' {
		res << vproto.pack_string_field(o.ip_country, 2)
	}
	if o.count_authed_computers != int(0) {
		res << vproto.pack_int32_field(o.count_authed_computers, 5)
	}
	if o.account_flags != u32(0) {
		res << vproto.pack_uint32_field(o.account_flags, 7)
	}
	if o.facebook_id != u64(0) {
		res << vproto.pack_uint64_field(o.facebook_id, 8)
	}
	if o.facebook_name != '' {
		res << vproto.pack_string_field(o.facebook_name, 9)
	}
	if o.steamguard_notify_newmachines != false {
		res << vproto.pack_bool_field(o.steamguard_notify_newmachines, 14)
	}
	if o.steamguard_machine_name_user_chosen != '' {
		res << vproto.pack_string_field(o.steamguard_machine_name_user_chosen, 15)
	}
	if o.is_phone_verified != false {
		res << vproto.pack_bool_field(o.is_phone_verified, 16)
	}
	if o.two_factor_state != u32(0) {
		res << vproto.pack_uint32_field(o.two_factor_state, 17)
	}
	if o.is_phone_identifying != false {
		res << vproto.pack_bool_field(o.is_phone_identifying, 18)
	}
	if o.is_phone_needing_reverify != false {
		res << vproto.pack_bool_field(o.is_phone_needing_reverify, 19)
	}
	return res
}

pub fn cmsgclientaccountinfo_unpack(buf []byte) ?CMsgClientAccountInfo {
	mut res := zzz_vproto_internal_new_cmsgclientaccountinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.persona_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.ip_country = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.count_authed_computers = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.account_flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.facebook_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.facebook_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			14 {
				i, res.steamguard_notify_newmachines = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			15 {
				i, res.steamguard_machine_name_user_chosen = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			16 {
				i, res.is_phone_verified = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			17 {
				i, res.two_factor_state = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			18 {
				i, res.is_phone_identifying = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			19 {
				i, res.is_phone_needing_reverify = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAccountInfo) eq(b CMsgClientAccountInfo) bool {
	return true && a.persona_name == b.persona_name && a.ip_country == b.ip_country &&
		a.count_authed_computers == b.count_authed_computers && a.account_flags == b.account_flags &&
		a.facebook_id == b.facebook_id && a.facebook_name == b.facebook_name && a.steamguard_notify_newmachines ==
		b.steamguard_notify_newmachines && a.steamguard_machine_name_user_chosen == b.steamguard_machine_name_user_chosen &&
		a.is_phone_verified == b.is_phone_verified && a.two_factor_state == b.two_factor_state &&
		a.is_phone_identifying == b.is_phone_identifying && a.is_phone_needing_reverify == b.is_phone_needing_reverify
}

[inline]
pub fn (a CMsgClientAccountInfo) ne(b CMsgClientAccountInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAccountInfo) eq(b []CMsgClientAccountInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAccountInfo) ne(b []CMsgClientAccountInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientaccountinfo() CMsgClientAccountInfo {
	return CMsgClientAccountInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientaccountinfo(o CMsgClientAccountInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientaccountinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAccountInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientaccountinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientChallengeRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
}

pub fn (o &CMsgClientChallengeRequest) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cmsgclientchallengerequest_unpack(buf []byte) ?CMsgClientChallengeRequest {
	mut res := zzz_vproto_internal_new_cmsgclientchallengerequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientChallengeRequest) eq(b CMsgClientChallengeRequest) bool {
	return true && a.steamid == b.steamid
}

[inline]
pub fn (a CMsgClientChallengeRequest) ne(b CMsgClientChallengeRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientChallengeRequest) eq(b []CMsgClientChallengeRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientChallengeRequest) ne(b []CMsgClientChallengeRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientchallengerequest() CMsgClientChallengeRequest {
	return CMsgClientChallengeRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientchallengerequest(o CMsgClientChallengeRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientchallengerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChallengeRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientchallengerequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientChallengeResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	challenge      u64
}

pub fn (o &CMsgClientChallengeResponse) pack() []byte {
	mut res := []byte{}
	if o.challenge != u64(0) {
		res << vproto.pack_64bit_field(o.challenge, 1)
	}
	return res
}

pub fn cmsgclientchallengeresponse_unpack(buf []byte) ?CMsgClientChallengeResponse {
	mut res := zzz_vproto_internal_new_cmsgclientchallengeresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.challenge = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientChallengeResponse) eq(b CMsgClientChallengeResponse) bool {
	return true && a.challenge == b.challenge
}

[inline]
pub fn (a CMsgClientChallengeResponse) ne(b CMsgClientChallengeResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientChallengeResponse) eq(b []CMsgClientChallengeResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientChallengeResponse) ne(b []CMsgClientChallengeResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientchallengeresponse() CMsgClientChallengeResponse {
	return CMsgClientChallengeResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientchallengeresponse(o CMsgClientChallengeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientchallengeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChallengeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientchallengeresponse_unpack(v) ?
	return i, unpacked
}
