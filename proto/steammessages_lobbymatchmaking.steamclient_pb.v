// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum ELobbyStatus {
	k_elobbystatusinvalid = 0
	k_elobbystatusexists = 1
	k_elobbystatusdoesnotexist = 2
	k_elobbystatusnotamember = 3
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_elobbystatus() ELobbyStatus {
	return .k_elobbystatusinvalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_elobbystatus(e ELobbyStatus, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_elobbystatus_packed(e []ELobbyStatus, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_elobbystatus(buf []byte, tag_wiretype vproto.WireType) ?(int, ELobbyStatus) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, ELobbyStatus(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_elobbystatus_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ELobbyStatus) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct LobbyMatchmakingLegacy_GetLobbyStatus_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	app_id           u32
	steamid_lobby    u64
	claim_ownership  bool
	claim_membership bool
	version_num      u32
}

pub fn (o &LobbyMatchmakingLegacy_GetLobbyStatus_Request) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steamid_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_lobby, 2)
	}
	if o.claim_ownership != false {
		res << vproto.pack_bool_field(o.claim_ownership, 3)
	}
	if o.claim_membership != false {
		res << vproto.pack_bool_field(o.claim_membership, 4)
	}
	if o.version_num != u32(0) {
		res << vproto.pack_uint32_field(o.version_num, 5)
	}
	return res
}

pub fn lobbymatchmakinglegacy_getlobbystatus_request_unpack(buf []byte) ?LobbyMatchmakingLegacy_GetLobbyStatus_Request {
	mut res := zzz_vproto_internal_new_lobbymatchmakinglegacy_getlobbystatus_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steamid_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.claim_ownership = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.claim_membership = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.version_num = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a LobbyMatchmakingLegacy_GetLobbyStatus_Request) eq(b LobbyMatchmakingLegacy_GetLobbyStatus_Request) bool {
	return true && a.app_id == b.app_id && a.steamid_lobby == b.steamid_lobby && a.claim_ownership ==
		b.claim_ownership && a.claim_membership == b.claim_membership && a.version_num == b.version_num
}

[inline]
pub fn (a LobbyMatchmakingLegacy_GetLobbyStatus_Request) ne(b LobbyMatchmakingLegacy_GetLobbyStatus_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []LobbyMatchmakingLegacy_GetLobbyStatus_Request) eq(b []LobbyMatchmakingLegacy_GetLobbyStatus_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []LobbyMatchmakingLegacy_GetLobbyStatus_Request) ne(b []LobbyMatchmakingLegacy_GetLobbyStatus_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_lobbymatchmakinglegacy_getlobbystatus_request() LobbyMatchmakingLegacy_GetLobbyStatus_Request {
	return LobbyMatchmakingLegacy_GetLobbyStatus_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_lobbymatchmakinglegacy_getlobbystatus_request(o LobbyMatchmakingLegacy_GetLobbyStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_lobbymatchmakinglegacy_getlobbystatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, LobbyMatchmakingLegacy_GetLobbyStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := lobbymatchmakinglegacy_getlobbystatus_request_unpack(v) ?
	return i, unpacked
}

pub struct LobbyMatchmakingLegacy_GetLobbyStatus_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steamid_lobby  u64
	lobby_status   ELobbyStatus = .k_elobbystatusinvalid
}

pub fn (o &LobbyMatchmakingLegacy_GetLobbyStatus_Response) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steamid_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_lobby, 2)
	}
	if o.lobby_status != zzz_vproto_internal_new_elobbystatus() {
		res << zzz_vproto_internal_pack_elobbystatus(o.lobby_status, 3)
	}
	return res
}

pub fn lobbymatchmakinglegacy_getlobbystatus_response_unpack(buf []byte) ?LobbyMatchmakingLegacy_GetLobbyStatus_Response {
	mut res := zzz_vproto_internal_new_lobbymatchmakinglegacy_getlobbystatus_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steamid_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.lobby_status = zzz_vproto_internal_unpack_elobbystatus(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a LobbyMatchmakingLegacy_GetLobbyStatus_Response) eq(b LobbyMatchmakingLegacy_GetLobbyStatus_Response) bool {
	return true && a.app_id == b.app_id && a.steamid_lobby == b.steamid_lobby && a.lobby_status ==
		b.lobby_status
}

[inline]
pub fn (a LobbyMatchmakingLegacy_GetLobbyStatus_Response) ne(b LobbyMatchmakingLegacy_GetLobbyStatus_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []LobbyMatchmakingLegacy_GetLobbyStatus_Response) eq(b []LobbyMatchmakingLegacy_GetLobbyStatus_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []LobbyMatchmakingLegacy_GetLobbyStatus_Response) ne(b []LobbyMatchmakingLegacy_GetLobbyStatus_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_lobbymatchmakinglegacy_getlobbystatus_response() LobbyMatchmakingLegacy_GetLobbyStatus_Response {
	return LobbyMatchmakingLegacy_GetLobbyStatus_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_lobbymatchmakinglegacy_getlobbystatus_response(o LobbyMatchmakingLegacy_GetLobbyStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_lobbymatchmakinglegacy_getlobbystatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, LobbyMatchmakingLegacy_GetLobbyStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := lobbymatchmakinglegacy_getlobbystatus_response_unpack(v) ?
	return i, unpacked
}
