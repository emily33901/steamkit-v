// Generated by vproto - Do not modify
module protobuf

import emily33901.vproto

pub struct FileDescriptorSet {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	file           []FileDescriptorProto
}

pub fn (o &FileDescriptorSet) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.file {
		res << zzz_vproto_internal_pack_filedescriptorproto(x, 1)
	}
	return res
}

pub fn filedescriptorset_unpack(buf []byte) ?FileDescriptorSet {
	mut res := zzz_vproto_internal_new_filedescriptorset()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_filedescriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.file << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a FileDescriptorSet) eq(b FileDescriptorSet) bool {
	return true && a.file.eq(b.file)
}

[inline]
pub fn (a FileDescriptorSet) ne(b FileDescriptorSet) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []FileDescriptorSet) eq(b []FileDescriptorSet) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []FileDescriptorSet) ne(b []FileDescriptorSet) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_filedescriptorset() FileDescriptorSet {
	return FileDescriptorSet{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_filedescriptorset(o FileDescriptorSet, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_filedescriptorset(buf []byte, tag_wiretype vproto.WireType) ?(int, FileDescriptorSet) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := filedescriptorset_unpack(v) ?
	return i, unpacked
}

pub struct FileDescriptorProto {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	name              string
	package           string
	dependency        []string
	public_dependency []int
	weak_dependency   []int
	message_type      []DescriptorProto
	enum_type         []EnumDescriptorProto
	service           []ServiceDescriptorProto
	extension         []FieldDescriptorProto
	options           FileOptions
	source_code_info  SourceCodeInfo
}

pub fn (o &FileDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.package != '' {
		res << vproto.pack_string_field(o.package, 2)
	}
	// [packed=false]
	for _, x in o.dependency {
		res << vproto.pack_string_field(x, 3)
	}
	// [packed=false]
	for _, x in o.public_dependency {
		res << vproto.pack_int32_field(x, 10)
	}
	// [packed=false]
	for _, x in o.weak_dependency {
		res << vproto.pack_int32_field(x, 11)
	}
	// [packed=false]
	for _, x in o.message_type {
		res << zzz_vproto_internal_pack_descriptorproto(x, 4)
	}
	// [packed=false]
	for _, x in o.enum_type {
		res << zzz_vproto_internal_pack_enumdescriptorproto(x, 5)
	}
	// [packed=false]
	for _, x in o.service {
		res << zzz_vproto_internal_pack_servicedescriptorproto(x, 6)
	}
	// [packed=false]
	for _, x in o.extension {
		res << zzz_vproto_internal_pack_fielddescriptorproto(x, 7)
	}
	if o.options.ne(zzz_vproto_internal_new_fileoptions()) {
		res << zzz_vproto_internal_pack_fileoptions(o.options, 8)
	}
	if o.source_code_info.ne(zzz_vproto_internal_new_sourcecodeinfo()) {
		res << zzz_vproto_internal_pack_sourcecodeinfo(o.source_code_info, 9)
	}
	return res
}

pub fn filedescriptorproto_unpack(buf []byte) ?FileDescriptorProto {
	mut res := zzz_vproto_internal_new_filedescriptorproto()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.name = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.package = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.dependency << v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
				res.public_dependency << v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
				res.weak_dependency << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_descriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.message_type << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_enumdescriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.enum_type << v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_servicedescriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.service << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_fielddescriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.extension << v
				i = ii
			}
			8 {
				ii, v := zzz_vproto_internal_unpack_fileoptions(cur_buf, tag_wiretype.wire_type) ?
				res.options = v
				i = ii
			}
			9 {
				ii, v := zzz_vproto_internal_unpack_sourcecodeinfo(cur_buf, tag_wiretype.wire_type) ?
				res.source_code_info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a FileDescriptorProto) eq(b FileDescriptorProto) bool {
	return true && a.name == b.name && a.package == b.package && a.dependency == b.dependency &&
		a.public_dependency == b.public_dependency && a.weak_dependency == b.weak_dependency && a.message_type.eq(b.message_type) &&
		a.enum_type.eq(b.enum_type) && a.service.eq(b.service) && a.extension.eq(b.extension) && a.options.eq(b.options) &&
		a.source_code_info.eq(b.source_code_info)
}

[inline]
pub fn (a FileDescriptorProto) ne(b FileDescriptorProto) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []FileDescriptorProto) eq(b []FileDescriptorProto) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []FileDescriptorProto) ne(b []FileDescriptorProto) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_filedescriptorproto() FileDescriptorProto {
	return FileDescriptorProto{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_filedescriptorproto(o FileDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_filedescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, FileDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := filedescriptorproto_unpack(v) ?
	return i, unpacked
}

pub struct DescriptorProto_ExtensionRange {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	start          int
	end            int
}

pub fn (o &DescriptorProto_ExtensionRange) pack() []byte {
	mut res := []byte{}
	if o.start != int(0) {
		res << vproto.pack_int32_field(o.start, 1)
	}
	if o.end != int(0) {
		res << vproto.pack_int32_field(o.end, 2)
	}
	return res
}

pub fn descriptorproto_extensionrange_unpack(buf []byte) ?DescriptorProto_ExtensionRange {
	mut res := zzz_vproto_internal_new_descriptorproto_extensionrange()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
				res.start = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
				res.end = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a DescriptorProto_ExtensionRange) eq(b DescriptorProto_ExtensionRange) bool {
	return true && a.start == b.start && a.end == b.end
}

[inline]
pub fn (a DescriptorProto_ExtensionRange) ne(b DescriptorProto_ExtensionRange) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []DescriptorProto_ExtensionRange) eq(b []DescriptorProto_ExtensionRange) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []DescriptorProto_ExtensionRange) ne(b []DescriptorProto_ExtensionRange) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_descriptorproto_extensionrange() DescriptorProto_ExtensionRange {
	return DescriptorProto_ExtensionRange{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_descriptorproto_extensionrange(o DescriptorProto_ExtensionRange, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_descriptorproto_extensionrange(buf []byte, tag_wiretype vproto.WireType) ?(int, DescriptorProto_ExtensionRange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := descriptorproto_extensionrange_unpack(v) ?
	return i, unpacked
}

pub struct DescriptorProto {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	name            string
	field           []FieldDescriptorProto
	extension       []FieldDescriptorProto
	nested_type     []DescriptorProto
	enum_type       []EnumDescriptorProto
	extension_range []DescriptorProto_ExtensionRange
	oneof_decl      []OneofDescriptorProto
	options         MessageOptions
}

pub fn (o &DescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	// [packed=false]
	for _, x in o.field {
		res << zzz_vproto_internal_pack_fielddescriptorproto(x, 2)
	}
	// [packed=false]
	for _, x in o.extension {
		res << zzz_vproto_internal_pack_fielddescriptorproto(x, 6)
	}
	// [packed=false]
	for _, x in o.nested_type {
		res << zzz_vproto_internal_pack_descriptorproto(x, 3)
	}
	// [packed=false]
	for _, x in o.enum_type {
		res << zzz_vproto_internal_pack_enumdescriptorproto(x, 4)
	}
	// [packed=false]
	for _, x in o.extension_range {
		res << zzz_vproto_internal_pack_descriptorproto_extensionrange(x, 5)
	}
	// [packed=false]
	for _, x in o.oneof_decl {
		res << zzz_vproto_internal_pack_oneofdescriptorproto(x, 8)
	}
	if o.options.ne(zzz_vproto_internal_new_messageoptions()) {
		res << zzz_vproto_internal_pack_messageoptions(o.options, 7)
	}
	return res
}

pub fn descriptorproto_unpack(buf []byte) ?DescriptorProto {
	mut res := zzz_vproto_internal_new_descriptorproto()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.name = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_fielddescriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.field << v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_fielddescriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.extension << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_descriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.nested_type << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_enumdescriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.enum_type << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_descriptorproto_extensionrange(cur_buf,
					tag_wiretype.wire_type) ?
				res.extension_range << v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_oneofdescriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.oneof_decl << v
				i = ii
			}
			7 {
				ii, v := zzz_vproto_internal_unpack_messageoptions(cur_buf, tag_wiretype.wire_type) ?
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a DescriptorProto) eq(b DescriptorProto) bool {
	return true && a.name == b.name && a.field.eq(b.field) && a.extension.eq(b.extension) && a.nested_type.eq(b.nested_type) &&
		a.enum_type.eq(b.enum_type) && a.extension_range.eq(b.extension_range) && a.oneof_decl.eq(b.oneof_decl) &&
		a.options.eq(b.options)
}

[inline]
pub fn (a DescriptorProto) ne(b DescriptorProto) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []DescriptorProto) eq(b []DescriptorProto) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []DescriptorProto) ne(b []DescriptorProto) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_descriptorproto() DescriptorProto {
	return DescriptorProto{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_descriptorproto(o DescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_descriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, DescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := descriptorproto_unpack(v) ?
	return i, unpacked
}

enum FieldDescriptorProto_Type {
	type_double = 1
	type_float = 2
	type_int64 = 3
	type_uint64 = 4
	type_int32 = 5
	type_fixed64 = 6
	type_fixed32 = 7
	type_bool = 8
	type_string = 9
	type_group = 10
	type_message = 11
	type_bytes = 12
	type_uint32 = 13
	type_enum = 14
	type_sfixed32 = 15
	type_sfixed64 = 16
	type_sint32 = 17
	type_sint64 = 18
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_fielddescriptorproto_type() FieldDescriptorProto_Type {
	return .type_double
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_fielddescriptorproto_type(e FieldDescriptorProto_Type, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_fielddescriptorproto_type_packed(e []FieldDescriptorProto_Type, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_fielddescriptorproto_type(buf []byte, tag_wiretype vproto.WireType) ?(int, FieldDescriptorProto_Type) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, FieldDescriptorProto_Type(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_fielddescriptorproto_type_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []FieldDescriptorProto_Type) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

enum FieldDescriptorProto_Label {
	label_optional = 1
	label_required = 2
	label_repeated = 3
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_fielddescriptorproto_label() FieldDescriptorProto_Label {
	return .label_optional
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_fielddescriptorproto_label(e FieldDescriptorProto_Label, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_fielddescriptorproto_label_packed(e []FieldDescriptorProto_Label, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_fielddescriptorproto_label(buf []byte, tag_wiretype vproto.WireType) ?(int, FieldDescriptorProto_Label) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, FieldDescriptorProto_Label(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_fielddescriptorproto_label_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []FieldDescriptorProto_Label) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct FieldDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	number         int
	label          FieldDescriptorProto_Label = .label_optional
	@type          FieldDescriptorProto_Type = .type_double
	type_name      string
	extendee       string
	default_value  string
	oneof_index    int
	options        FieldOptions
}

pub fn (o &FieldDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.number != int(0) {
		res << vproto.pack_int32_field(o.number, 3)
	}
	if o.label != zzz_vproto_internal_new_fielddescriptorproto_label() {
		res << zzz_vproto_internal_pack_fielddescriptorproto_label(o.label, 4)
	}
	if o.@type != zzz_vproto_internal_new_fielddescriptorproto_type() {
		res << zzz_vproto_internal_pack_fielddescriptorproto_type(o.@type, 5)
	}
	if o.type_name != '' {
		res << vproto.pack_string_field(o.type_name, 6)
	}
	if o.extendee != '' {
		res << vproto.pack_string_field(o.extendee, 2)
	}
	if o.default_value != '' {
		res << vproto.pack_string_field(o.default_value, 7)
	}
	if o.oneof_index != int(0) {
		res << vproto.pack_int32_field(o.oneof_index, 9)
	}
	if o.options.ne(zzz_vproto_internal_new_fieldoptions()) {
		res << zzz_vproto_internal_pack_fieldoptions(o.options, 8)
	}
	return res
}

pub fn fielddescriptorproto_unpack(buf []byte) ?FieldDescriptorProto {
	mut res := zzz_vproto_internal_new_fielddescriptorproto()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.name = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
				res.number = v
				i = ii
			}
			4 {
				ii, v := zzz_vproto_internal_unpack_fielddescriptorproto_label(cur_buf,
					tag_wiretype.wire_type) ?
				res.label = v
				i = ii
			}
			5 {
				ii, v := zzz_vproto_internal_unpack_fielddescriptorproto_type(cur_buf,
					tag_wiretype.wire_type) ?
				res.@type = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.type_name = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.extendee = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.default_value = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
				res.oneof_index = v
				i = ii
			}
			8 {
				ii, v := zzz_vproto_internal_unpack_fieldoptions(cur_buf, tag_wiretype.wire_type) ?
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a FieldDescriptorProto) eq(b FieldDescriptorProto) bool {
	return true && a.name == b.name && a.number == b.number && a.label == b.label && a.@type ==
		b.@type && a.type_name == b.type_name && a.extendee == b.extendee && a.default_value == b.default_value &&
		a.oneof_index == b.oneof_index && a.options.eq(b.options)
}

[inline]
pub fn (a FieldDescriptorProto) ne(b FieldDescriptorProto) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []FieldDescriptorProto) eq(b []FieldDescriptorProto) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []FieldDescriptorProto) ne(b []FieldDescriptorProto) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_fielddescriptorproto() FieldDescriptorProto {
	return FieldDescriptorProto{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_fielddescriptorproto(o FieldDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_fielddescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, FieldDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := fielddescriptorproto_unpack(v) ?
	return i, unpacked
}

pub struct OneofDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
}

pub fn (o &OneofDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	return res
}

pub fn oneofdescriptorproto_unpack(buf []byte) ?OneofDescriptorProto {
	mut res := zzz_vproto_internal_new_oneofdescriptorproto()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a OneofDescriptorProto) eq(b OneofDescriptorProto) bool {
	return true && a.name == b.name
}

[inline]
pub fn (a OneofDescriptorProto) ne(b OneofDescriptorProto) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []OneofDescriptorProto) eq(b []OneofDescriptorProto) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []OneofDescriptorProto) ne(b []OneofDescriptorProto) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_oneofdescriptorproto() OneofDescriptorProto {
	return OneofDescriptorProto{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_oneofdescriptorproto(o OneofDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_oneofdescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, OneofDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := oneofdescriptorproto_unpack(v) ?
	return i, unpacked
}

pub struct EnumDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	value          []EnumValueDescriptorProto
	options        EnumOptions
}

pub fn (o &EnumDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	// [packed=false]
	for _, x in o.value {
		res << zzz_vproto_internal_pack_enumvaluedescriptorproto(x, 2)
	}
	if o.options.ne(zzz_vproto_internal_new_enumoptions()) {
		res << zzz_vproto_internal_pack_enumoptions(o.options, 3)
	}
	return res
}

pub fn enumdescriptorproto_unpack(buf []byte) ?EnumDescriptorProto {
	mut res := zzz_vproto_internal_new_enumdescriptorproto()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.name = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_enumvaluedescriptorproto(cur_buf,
					tag_wiretype.wire_type) ?
				res.value << v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_enumoptions(cur_buf, tag_wiretype.wire_type) ?
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a EnumDescriptorProto) eq(b EnumDescriptorProto) bool {
	return true && a.name == b.name && a.value.eq(b.value) && a.options.eq(b.options)
}

[inline]
pub fn (a EnumDescriptorProto) ne(b EnumDescriptorProto) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []EnumDescriptorProto) eq(b []EnumDescriptorProto) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []EnumDescriptorProto) ne(b []EnumDescriptorProto) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_enumdescriptorproto() EnumDescriptorProto {
	return EnumDescriptorProto{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_enumdescriptorproto(o EnumDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_enumdescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, EnumDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := enumdescriptorproto_unpack(v) ?
	return i, unpacked
}

pub struct EnumValueDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	number         int
	options        EnumValueOptions
}

pub fn (o &EnumValueDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.number != int(0) {
		res << vproto.pack_int32_field(o.number, 2)
	}
	if o.options.ne(zzz_vproto_internal_new_enumvalueoptions()) {
		res << zzz_vproto_internal_pack_enumvalueoptions(o.options, 3)
	}
	return res
}

pub fn enumvaluedescriptorproto_unpack(buf []byte) ?EnumValueDescriptorProto {
	mut res := zzz_vproto_internal_new_enumvaluedescriptorproto()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.name = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
				res.number = v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_enumvalueoptions(cur_buf, tag_wiretype.wire_type) ?
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a EnumValueDescriptorProto) eq(b EnumValueDescriptorProto) bool {
	return true && a.name == b.name && a.number == b.number && a.options.eq(b.options)
}

[inline]
pub fn (a EnumValueDescriptorProto) ne(b EnumValueDescriptorProto) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []EnumValueDescriptorProto) eq(b []EnumValueDescriptorProto) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []EnumValueDescriptorProto) ne(b []EnumValueDescriptorProto) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_enumvaluedescriptorproto() EnumValueDescriptorProto {
	return EnumValueDescriptorProto{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_enumvaluedescriptorproto(o EnumValueDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_enumvaluedescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, EnumValueDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := enumvaluedescriptorproto_unpack(v) ?
	return i, unpacked
}

pub struct ServiceDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	method         []MethodDescriptorProto
	options        ServiceOptions
}

pub fn (o &ServiceDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	// [packed=false]
	for _, x in o.method {
		res << zzz_vproto_internal_pack_methoddescriptorproto(x, 2)
	}
	if o.options.ne(zzz_vproto_internal_new_serviceoptions()) {
		res << zzz_vproto_internal_pack_serviceoptions(o.options, 3)
	}
	return res
}

pub fn servicedescriptorproto_unpack(buf []byte) ?ServiceDescriptorProto {
	mut res := zzz_vproto_internal_new_servicedescriptorproto()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.name = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_methoddescriptorproto(cur_buf, tag_wiretype.wire_type) ?
				res.method << v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_serviceoptions(cur_buf, tag_wiretype.wire_type) ?
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ServiceDescriptorProto) eq(b ServiceDescriptorProto) bool {
	return true && a.name == b.name && a.method.eq(b.method) && a.options.eq(b.options)
}

[inline]
pub fn (a ServiceDescriptorProto) ne(b ServiceDescriptorProto) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ServiceDescriptorProto) eq(b []ServiceDescriptorProto) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ServiceDescriptorProto) ne(b []ServiceDescriptorProto) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_servicedescriptorproto() ServiceDescriptorProto {
	return ServiceDescriptorProto{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_servicedescriptorproto(o ServiceDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_servicedescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, ServiceDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := servicedescriptorproto_unpack(v) ?
	return i, unpacked
}

pub struct MethodDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	input_type     string
	output_type    string
	options        MethodOptions
}

pub fn (o &MethodDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.input_type != '' {
		res << vproto.pack_string_field(o.input_type, 2)
	}
	if o.output_type != '' {
		res << vproto.pack_string_field(o.output_type, 3)
	}
	if o.options.ne(zzz_vproto_internal_new_methodoptions()) {
		res << zzz_vproto_internal_pack_methodoptions(o.options, 4)
	}
	return res
}

pub fn methoddescriptorproto_unpack(buf []byte) ?MethodDescriptorProto {
	mut res := zzz_vproto_internal_new_methoddescriptorproto()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.name = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.input_type = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.output_type = v
				i = ii
			}
			4 {
				ii, v := zzz_vproto_internal_unpack_methodoptions(cur_buf, tag_wiretype.wire_type) ?
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a MethodDescriptorProto) eq(b MethodDescriptorProto) bool {
	return true && a.name == b.name && a.input_type == b.input_type && a.output_type == b.output_type &&
		a.options.eq(b.options)
}

[inline]
pub fn (a MethodDescriptorProto) ne(b MethodDescriptorProto) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []MethodDescriptorProto) eq(b []MethodDescriptorProto) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []MethodDescriptorProto) ne(b []MethodDescriptorProto) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_methoddescriptorproto() MethodDescriptorProto {
	return MethodDescriptorProto{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_methoddescriptorproto(o MethodDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_methoddescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, MethodDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := methoddescriptorproto_unpack(v) ?
	return i, unpacked
}

enum FileOptions_OptimizeMode {
	speed = 1
	code_size = 2
	lite_runtime = 3
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_fileoptions_optimizemode() FileOptions_OptimizeMode {
	return .speed
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_fileoptions_optimizemode(e FileOptions_OptimizeMode, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_fileoptions_optimizemode_packed(e []FileOptions_OptimizeMode, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_fileoptions_optimizemode(buf []byte, tag_wiretype vproto.WireType) ?(int, FileOptions_OptimizeMode) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, FileOptions_OptimizeMode(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_fileoptions_optimizemode_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []FileOptions_OptimizeMode) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct FileOptions {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	java_package                  string
	java_outer_classname          string
	java_multiple_files           bool
	java_generate_equals_and_hash bool
	java_string_check_utf8        bool
	optimize_for                  FileOptions_OptimizeMode = .speed
	go_package                    string
	cc_generic_services           bool
	java_generic_services         bool
	py_generic_services           bool
	deprecated                    bool
	uninterpreted_option          []UninterpretedOption
}

pub fn (o &FileOptions) pack() []byte {
	mut res := []byte{}
	if o.java_package != '' {
		res << vproto.pack_string_field(o.java_package, 1)
	}
	if o.java_outer_classname != '' {
		res << vproto.pack_string_field(o.java_outer_classname, 8)
	}
	if o.java_multiple_files != false {
		res << vproto.pack_bool_field(o.java_multiple_files, 10)
	}
	if o.java_generate_equals_and_hash != false {
		res << vproto.pack_bool_field(o.java_generate_equals_and_hash, 20)
	}
	if o.java_string_check_utf8 != false {
		res << vproto.pack_bool_field(o.java_string_check_utf8, 27)
	}
	if o.optimize_for != zzz_vproto_internal_new_fileoptions_optimizemode() {
		res << zzz_vproto_internal_pack_fileoptions_optimizemode(o.optimize_for, 9)
	}
	if o.go_package != '' {
		res << vproto.pack_string_field(o.go_package, 11)
	}
	if o.cc_generic_services != false {
		res << vproto.pack_bool_field(o.cc_generic_services, 16)
	}
	if o.java_generic_services != false {
		res << vproto.pack_bool_field(o.java_generic_services, 17)
	}
	if o.py_generic_services != false {
		res << vproto.pack_bool_field(o.py_generic_services, 18)
	}
	if o.deprecated != false {
		res << vproto.pack_bool_field(o.deprecated, 23)
	}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn fileoptions_unpack(buf []byte) ?FileOptions {
	mut res := zzz_vproto_internal_new_fileoptions()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.java_package = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.java_outer_classname = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.java_multiple_files = v
				i = ii
			}
			20 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.java_generate_equals_and_hash = v
				i = ii
			}
			27 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.java_string_check_utf8 = v
				i = ii
			}
			9 {
				ii, v := zzz_vproto_internal_unpack_fileoptions_optimizemode(cur_buf,
					tag_wiretype.wire_type) ?
				res.optimize_for = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.go_package = v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.cc_generic_services = v
				i = ii
			}
			17 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.java_generic_services = v
				i = ii
			}
			18 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.py_generic_services = v
				i = ii
			}
			23 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.deprecated = v
				i = ii
			}
			999 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type) ?
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a FileOptions) eq(b FileOptions) bool {
	return true && a.java_package == b.java_package && a.java_outer_classname == b.java_outer_classname &&
		a.java_multiple_files == b.java_multiple_files && a.java_generate_equals_and_hash == b.java_generate_equals_and_hash &&
		a.java_string_check_utf8 == b.java_string_check_utf8 && a.optimize_for == b.optimize_for &&
		a.go_package == b.go_package && a.cc_generic_services == b.cc_generic_services && a.java_generic_services ==
		b.java_generic_services && a.py_generic_services == b.py_generic_services && a.deprecated == b.deprecated &&
		a.uninterpreted_option.eq(b.uninterpreted_option)
}

[inline]
pub fn (a FileOptions) ne(b FileOptions) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []FileOptions) eq(b []FileOptions) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []FileOptions) ne(b []FileOptions) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_fileoptions() FileOptions {
	return FileOptions{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_fileoptions(o FileOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_fileoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, FileOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := fileoptions_unpack(v) ?
	return i, unpacked
}

pub struct MessageOptions {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	message_set_wire_format         bool
	no_standard_descriptor_accessor bool
	deprecated                      bool
	uninterpreted_option            []UninterpretedOption
}

pub fn (o &MessageOptions) pack() []byte {
	mut res := []byte{}
	if o.message_set_wire_format != false {
		res << vproto.pack_bool_field(o.message_set_wire_format, 1)
	}
	if o.no_standard_descriptor_accessor != false {
		res << vproto.pack_bool_field(o.no_standard_descriptor_accessor, 2)
	}
	if o.deprecated != false {
		res << vproto.pack_bool_field(o.deprecated, 3)
	}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn messageoptions_unpack(buf []byte) ?MessageOptions {
	mut res := zzz_vproto_internal_new_messageoptions()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.message_set_wire_format = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.no_standard_descriptor_accessor = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.deprecated = v
				i = ii
			}
			999 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type) ?
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a MessageOptions) eq(b MessageOptions) bool {
	return true && a.message_set_wire_format == b.message_set_wire_format && a.no_standard_descriptor_accessor ==
		b.no_standard_descriptor_accessor && a.deprecated == b.deprecated && a.uninterpreted_option.eq(b.uninterpreted_option)
}

[inline]
pub fn (a MessageOptions) ne(b MessageOptions) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []MessageOptions) eq(b []MessageOptions) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []MessageOptions) ne(b []MessageOptions) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_messageoptions() MessageOptions {
	return MessageOptions{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_messageoptions(o MessageOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_messageoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, MessageOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := messageoptions_unpack(v) ?
	return i, unpacked
}

enum FieldOptions_CType {
	string = 0
	cord = 1
	string_piece = 2
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_fieldoptions_ctype() FieldOptions_CType {
	return .string
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_fieldoptions_ctype(e FieldOptions_CType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_fieldoptions_ctype_packed(e []FieldOptions_CType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_fieldoptions_ctype(buf []byte, tag_wiretype vproto.WireType) ?(int, FieldOptions_CType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, FieldOptions_CType(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_fieldoptions_ctype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []FieldOptions_CType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct FieldOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	ctype                FieldOptions_CType = .string
	packed               bool
	lazy                 bool
	deprecated           bool
	experimental_map_key string
	weak                 bool
	uninterpreted_option []UninterpretedOption
}

pub fn (o &FieldOptions) pack() []byte {
	mut res := []byte{}
	if o.ctype != zzz_vproto_internal_new_fieldoptions_ctype() {
		res << zzz_vproto_internal_pack_fieldoptions_ctype(o.ctype, 1)
	}
	if o.packed != false {
		res << vproto.pack_bool_field(o.packed, 2)
	}
	if o.lazy != false {
		res << vproto.pack_bool_field(o.lazy, 5)
	}
	if o.deprecated != false {
		res << vproto.pack_bool_field(o.deprecated, 3)
	}
	if o.experimental_map_key != '' {
		res << vproto.pack_string_field(o.experimental_map_key, 9)
	}
	if o.weak != false {
		res << vproto.pack_bool_field(o.weak, 10)
	}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn fieldoptions_unpack(buf []byte) ?FieldOptions {
	mut res := zzz_vproto_internal_new_fieldoptions()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_fieldoptions_ctype(cur_buf, tag_wiretype.wire_type) ?
				res.ctype = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.packed = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.lazy = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.deprecated = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.experimental_map_key = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.weak = v
				i = ii
			}
			999 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type) ?
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a FieldOptions) eq(b FieldOptions) bool {
	return true && a.ctype == b.ctype && a.packed == b.packed && a.lazy == b.lazy && a.deprecated ==
		b.deprecated && a.experimental_map_key == b.experimental_map_key && a.weak == b.weak && a.uninterpreted_option.eq(b.uninterpreted_option)
}

[inline]
pub fn (a FieldOptions) ne(b FieldOptions) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []FieldOptions) eq(b []FieldOptions) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []FieldOptions) ne(b []FieldOptions) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_fieldoptions() FieldOptions {
	return FieldOptions{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_fieldoptions(o FieldOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_fieldoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, FieldOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := fieldoptions_unpack(v) ?
	return i, unpacked
}

pub struct EnumOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	allow_alias          bool
	deprecated           bool
	uninterpreted_option []UninterpretedOption
}

pub fn (o &EnumOptions) pack() []byte {
	mut res := []byte{}
	if o.allow_alias != false {
		res << vproto.pack_bool_field(o.allow_alias, 2)
	}
	if o.deprecated != false {
		res << vproto.pack_bool_field(o.deprecated, 3)
	}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn enumoptions_unpack(buf []byte) ?EnumOptions {
	mut res := zzz_vproto_internal_new_enumoptions()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.allow_alias = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.deprecated = v
				i = ii
			}
			999 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type) ?
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a EnumOptions) eq(b EnumOptions) bool {
	return true && a.allow_alias == b.allow_alias && a.deprecated == b.deprecated && a.uninterpreted_option.eq(b.uninterpreted_option)
}

[inline]
pub fn (a EnumOptions) ne(b EnumOptions) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []EnumOptions) eq(b []EnumOptions) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []EnumOptions) ne(b []EnumOptions) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_enumoptions() EnumOptions {
	return EnumOptions{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_enumoptions(o EnumOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_enumoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, EnumOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := enumoptions_unpack(v) ?
	return i, unpacked
}

pub struct EnumValueOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	deprecated           bool
	uninterpreted_option []UninterpretedOption
}

pub fn (o &EnumValueOptions) pack() []byte {
	mut res := []byte{}
	if o.deprecated != false {
		res << vproto.pack_bool_field(o.deprecated, 1)
	}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn enumvalueoptions_unpack(buf []byte) ?EnumValueOptions {
	mut res := zzz_vproto_internal_new_enumvalueoptions()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.deprecated = v
				i = ii
			}
			999 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type) ?
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a EnumValueOptions) eq(b EnumValueOptions) bool {
	return true && a.deprecated == b.deprecated && a.uninterpreted_option.eq(b.uninterpreted_option)
}

[inline]
pub fn (a EnumValueOptions) ne(b EnumValueOptions) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []EnumValueOptions) eq(b []EnumValueOptions) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []EnumValueOptions) ne(b []EnumValueOptions) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_enumvalueoptions() EnumValueOptions {
	return EnumValueOptions{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_enumvalueoptions(o EnumValueOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_enumvalueoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, EnumValueOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := enumvalueoptions_unpack(v) ?
	return i, unpacked
}

pub struct ServiceOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	deprecated           bool
	uninterpreted_option []UninterpretedOption
}

pub fn (o &ServiceOptions) pack() []byte {
	mut res := []byte{}
	if o.deprecated != false {
		res << vproto.pack_bool_field(o.deprecated, 33)
	}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn serviceoptions_unpack(buf []byte) ?ServiceOptions {
	mut res := zzz_vproto_internal_new_serviceoptions()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			33 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.deprecated = v
				i = ii
			}
			999 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type) ?
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ServiceOptions) eq(b ServiceOptions) bool {
	return true && a.deprecated == b.deprecated && a.uninterpreted_option.eq(b.uninterpreted_option)
}

[inline]
pub fn (a ServiceOptions) ne(b ServiceOptions) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ServiceOptions) eq(b []ServiceOptions) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ServiceOptions) ne(b []ServiceOptions) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_serviceoptions() ServiceOptions {
	return ServiceOptions{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_serviceoptions(o ServiceOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_serviceoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, ServiceOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := serviceoptions_unpack(v) ?
	return i, unpacked
}

pub struct MethodOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	deprecated           bool
	uninterpreted_option []UninterpretedOption
}

pub fn (o &MethodOptions) pack() []byte {
	mut res := []byte{}
	if o.deprecated != false {
		res << vproto.pack_bool_field(o.deprecated, 33)
	}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn methodoptions_unpack(buf []byte) ?MethodOptions {
	mut res := zzz_vproto_internal_new_methodoptions()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			33 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.deprecated = v
				i = ii
			}
			999 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type) ?
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a MethodOptions) eq(b MethodOptions) bool {
	return true && a.deprecated == b.deprecated && a.uninterpreted_option.eq(b.uninterpreted_option)
}

[inline]
pub fn (a MethodOptions) ne(b MethodOptions) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []MethodOptions) eq(b []MethodOptions) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []MethodOptions) ne(b []MethodOptions) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_methodoptions() MethodOptions {
	return MethodOptions{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_methodoptions(o MethodOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_methodoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, MethodOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := methodoptions_unpack(v) ?
	return i, unpacked
}

pub struct UninterpretedOption_NamePart {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name_part      string
	is_extension   bool
}

pub fn (o &UninterpretedOption_NamePart) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_string_field(o.name_part, 1)
	res << vproto.pack_bool_field(o.is_extension, 2)
	return res
}

pub fn uninterpretedoption_namepart_unpack(buf []byte) ?UninterpretedOption_NamePart {
	mut res := zzz_vproto_internal_new_uninterpretedoption_namepart()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.name_part = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.is_extension = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a UninterpretedOption_NamePart) eq(b UninterpretedOption_NamePart) bool {
	return true && a.name_part == b.name_part && a.is_extension == b.is_extension
}

[inline]
pub fn (a UninterpretedOption_NamePart) ne(b UninterpretedOption_NamePart) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []UninterpretedOption_NamePart) eq(b []UninterpretedOption_NamePart) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []UninterpretedOption_NamePart) ne(b []UninterpretedOption_NamePart) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_uninterpretedoption_namepart() UninterpretedOption_NamePart {
	return UninterpretedOption_NamePart{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_uninterpretedoption_namepart(o UninterpretedOption_NamePart, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_uninterpretedoption_namepart(buf []byte, tag_wiretype vproto.WireType) ?(int, UninterpretedOption_NamePart) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := uninterpretedoption_namepart_unpack(v) ?
	return i, unpacked
}

pub struct UninterpretedOption {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	name               []UninterpretedOption_NamePart
	identifier_value   string
	positive_int_value u64
	negative_int_value i64
	double_value       f64
	string_value       []byte
	aggregate_value    string
}

pub fn (o &UninterpretedOption) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.name {
		res << zzz_vproto_internal_pack_uninterpretedoption_namepart(x, 2)
	}
	if o.identifier_value != '' {
		res << vproto.pack_string_field(o.identifier_value, 3)
	}
	if o.positive_int_value != u64(0) {
		res << vproto.pack_uint64_field(o.positive_int_value, 4)
	}
	if o.negative_int_value != i64(0) {
		res << vproto.pack_int64_field(o.negative_int_value, 5)
	}
	if o.double_value != f64(0) {
		res << vproto.pack_double_field(o.double_value, 6)
	}
	if o.string_value != []byte{} {
		res << vproto.pack_bytes_field(o.string_value, 7)
	}
	if o.aggregate_value != '' {
		res << vproto.pack_string_field(o.aggregate_value, 8)
	}
	return res
}

pub fn uninterpretedoption_unpack(buf []byte) ?UninterpretedOption {
	mut res := zzz_vproto_internal_new_uninterpretedoption()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_uninterpretedoption_namepart(cur_buf,
					tag_wiretype.wire_type) ?
				res.name << v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.identifier_value = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.positive_int_value = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type) ?
				res.negative_int_value = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type) ?
				res.double_value = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.string_value = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.aggregate_value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a UninterpretedOption) eq(b UninterpretedOption) bool {
	return true && a.name.eq(b.name) && a.identifier_value == b.identifier_value && a.positive_int_value ==
		b.positive_int_value && a.negative_int_value == b.negative_int_value && a.double_value == b.double_value &&
		a.string_value == b.string_value && a.aggregate_value == b.aggregate_value
}

[inline]
pub fn (a UninterpretedOption) ne(b UninterpretedOption) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []UninterpretedOption) eq(b []UninterpretedOption) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []UninterpretedOption) ne(b []UninterpretedOption) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_uninterpretedoption() UninterpretedOption {
	return UninterpretedOption{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_uninterpretedoption(o UninterpretedOption, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_uninterpretedoption(buf []byte, tag_wiretype vproto.WireType) ?(int, UninterpretedOption) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := uninterpretedoption_unpack(v) ?
	return i, unpacked
}

pub struct SourceCodeInfo_Location {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	path              []int
	span              []int
	leading_comments  string
	trailing_comments string
}

pub fn (o &SourceCodeInfo_Location) pack() []byte {
	mut res := []byte{}
	// [packed=true]
	res << vproto.pack_int32_field_packed(o.path, 1)
	// [packed=true]
	res << vproto.pack_int32_field_packed(o.span, 2)
	if o.leading_comments != '' {
		res << vproto.pack_string_field(o.leading_comments, 3)
	}
	if o.trailing_comments != '' {
		res << vproto.pack_string_field(o.trailing_comments, 4)
	}
	return res
}

pub fn sourcecodeinfo_location_unpack(buf []byte) ?SourceCodeInfo_Location {
	mut res := zzz_vproto_internal_new_sourcecodeinfo_location()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=true]
				ii, v := vproto.unpack_int32_field_packed(cur_buf, tag_wiretype.wire_type) ?
				res.path << v
				i = ii
			}
			2 {
				// [packed=true]
				ii, v := vproto.unpack_int32_field_packed(cur_buf, tag_wiretype.wire_type) ?
				res.span << v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.leading_comments = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.trailing_comments = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SourceCodeInfo_Location) eq(b SourceCodeInfo_Location) bool {
	return true && a.path == b.path && a.span == b.span && a.leading_comments == b.leading_comments &&
		a.trailing_comments == b.trailing_comments
}

[inline]
pub fn (a SourceCodeInfo_Location) ne(b SourceCodeInfo_Location) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SourceCodeInfo_Location) eq(b []SourceCodeInfo_Location) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SourceCodeInfo_Location) ne(b []SourceCodeInfo_Location) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_sourcecodeinfo_location() SourceCodeInfo_Location {
	return SourceCodeInfo_Location{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_sourcecodeinfo_location(o SourceCodeInfo_Location, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_sourcecodeinfo_location(buf []byte, tag_wiretype vproto.WireType) ?(int, SourceCodeInfo_Location) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := sourcecodeinfo_location_unpack(v) ?
	return i, unpacked
}

pub struct SourceCodeInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	location       []SourceCodeInfo_Location
}

pub fn (o &SourceCodeInfo) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.location {
		res << zzz_vproto_internal_pack_sourcecodeinfo_location(x, 1)
	}
	return res
}

pub fn sourcecodeinfo_unpack(buf []byte) ?SourceCodeInfo {
	mut res := zzz_vproto_internal_new_sourcecodeinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_sourcecodeinfo_location(cur_buf, tag_wiretype.wire_type) ?
				res.location << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SourceCodeInfo) eq(b SourceCodeInfo) bool {
	return true && a.location.eq(b.location)
}

[inline]
pub fn (a SourceCodeInfo) ne(b SourceCodeInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SourceCodeInfo) eq(b []SourceCodeInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SourceCodeInfo) ne(b []SourceCodeInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_sourcecodeinfo() SourceCodeInfo {
	return SourceCodeInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_sourcecodeinfo(o SourceCodeInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_sourcecodeinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, SourceCodeInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := sourcecodeinfo_unpack(v) ?
	return i, unpacked
}
