// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CTwoFactor_Status_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
}

pub fn (o &CTwoFactor_Status_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn ctwofactor_status_request_unpack(buf []byte) ?CTwoFactor_Status_Request {
	mut res := zzz_vproto_internal_new_ctwofactor_status_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_Status_Request) eq(b CTwoFactor_Status_Request) bool {
	return true && a.steamid == b.steamid
}

[inline]
pub fn (a CTwoFactor_Status_Request) ne(b CTwoFactor_Status_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_Status_Request) eq(b []CTwoFactor_Status_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_Status_Request) ne(b []CTwoFactor_Status_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_status_request() CTwoFactor_Status_Request {
	return CTwoFactor_Status_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_status_request(o CTwoFactor_Status_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_status_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_Status_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_status_request_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_Status_Response {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	state                         u32
	inactivation_reason           u32
	authenticator_type            u32
	authenticator_allowed         bool
	steamguard_scheme             u32
	token_gid                     string
	email_validated               bool
	device_identifier             string
	time_created                  u32
	revocation_attempts_remaining u32
	classified_agent              string
	allow_external_authenticator  bool
	time_transferred              u32
}

pub fn (o &CTwoFactor_Status_Response) pack() []byte {
	mut res := []byte{}
	if o.state != u32(0) {
		res << vproto.pack_uint32_field(o.state, 1)
	}
	if o.inactivation_reason != u32(0) {
		res << vproto.pack_uint32_field(o.inactivation_reason, 2)
	}
	if o.authenticator_type != u32(0) {
		res << vproto.pack_uint32_field(o.authenticator_type, 3)
	}
	if o.authenticator_allowed != false {
		res << vproto.pack_bool_field(o.authenticator_allowed, 4)
	}
	if o.steamguard_scheme != u32(0) {
		res << vproto.pack_uint32_field(o.steamguard_scheme, 5)
	}
	if o.token_gid != '' {
		res << vproto.pack_string_field(o.token_gid, 6)
	}
	if o.email_validated != false {
		res << vproto.pack_bool_field(o.email_validated, 7)
	}
	if o.device_identifier != '' {
		res << vproto.pack_string_field(o.device_identifier, 8)
	}
	if o.time_created != u32(0) {
		res << vproto.pack_uint32_field(o.time_created, 9)
	}
	if o.revocation_attempts_remaining != u32(0) {
		res << vproto.pack_uint32_field(o.revocation_attempts_remaining, 10)
	}
	if o.classified_agent != '' {
		res << vproto.pack_string_field(o.classified_agent, 11)
	}
	if o.allow_external_authenticator != false {
		res << vproto.pack_bool_field(o.allow_external_authenticator, 12)
	}
	if o.time_transferred != u32(0) {
		res << vproto.pack_uint32_field(o.time_transferred, 13)
	}
	return res
}

pub fn ctwofactor_status_response_unpack(buf []byte) ?CTwoFactor_Status_Response {
	mut res := zzz_vproto_internal_new_ctwofactor_status_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.state = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.inactivation_reason = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.authenticator_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.authenticator_allowed = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.steamguard_scheme = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.token_gid = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.email_validated = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.device_identifier = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.time_created = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.revocation_attempts_remaining = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			11 {
				i, res.classified_agent = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			12 {
				i, res.allow_external_authenticator = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			13 {
				i, res.time_transferred = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_Status_Response) eq(b CTwoFactor_Status_Response) bool {
	return true && a.state == b.state && a.inactivation_reason == b.inactivation_reason &&
		a.authenticator_type == b.authenticator_type && a.authenticator_allowed == b.authenticator_allowed &&
		a.steamguard_scheme == b.steamguard_scheme && a.token_gid == b.token_gid && a.email_validated ==
		b.email_validated && a.device_identifier == b.device_identifier && a.time_created == b.time_created &&
		a.revocation_attempts_remaining == b.revocation_attempts_remaining && a.classified_agent == b.classified_agent &&
		a.allow_external_authenticator == b.allow_external_authenticator && a.time_transferred == b.time_transferred
}

[inline]
pub fn (a CTwoFactor_Status_Response) ne(b CTwoFactor_Status_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_Status_Response) eq(b []CTwoFactor_Status_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_Status_Response) ne(b []CTwoFactor_Status_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_status_response() CTwoFactor_Status_Response {
	return CTwoFactor_Status_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_status_response(o CTwoFactor_Status_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_status_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_Status_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_status_response_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_AddAuthenticator_Request {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steamid            u64
	authenticator_time u64
	serial_number      u64
	authenticator_type u32
	device_identifier  string
	sms_phone_id       string
	http_headers       []string
}

pub fn (o &CTwoFactor_AddAuthenticator_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.authenticator_time != u64(0) {
		res << vproto.pack_uint64_field(o.authenticator_time, 2)
	}
	if o.serial_number != u64(0) {
		res << vproto.pack_64bit_field(o.serial_number, 3)
	}
	if o.authenticator_type != u32(0) {
		res << vproto.pack_uint32_field(o.authenticator_type, 4)
	}
	if o.device_identifier != '' {
		res << vproto.pack_string_field(o.device_identifier, 5)
	}
	if o.sms_phone_id != '' {
		res << vproto.pack_string_field(o.sms_phone_id, 6)
	}
	// [packed=false]
	for _, x in o.http_headers {
		res << vproto.pack_string_field(x, 7)
	}
	return res
}

pub fn ctwofactor_addauthenticator_request_unpack(buf []byte) ?CTwoFactor_AddAuthenticator_Request {
	mut res := zzz_vproto_internal_new_ctwofactor_addauthenticator_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.authenticator_time = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.serial_number = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.authenticator_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.device_identifier = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.sms_phone_id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.http_headers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_AddAuthenticator_Request) eq(b CTwoFactor_AddAuthenticator_Request) bool {
	return true && a.steamid == b.steamid && a.authenticator_time == b.authenticator_time &&
		a.serial_number == b.serial_number && a.authenticator_type == b.authenticator_type &&
		a.device_identifier == b.device_identifier && a.sms_phone_id == b.sms_phone_id && a.http_headers ==
		b.http_headers
}

[inline]
pub fn (a CTwoFactor_AddAuthenticator_Request) ne(b CTwoFactor_AddAuthenticator_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_AddAuthenticator_Request) eq(b []CTwoFactor_AddAuthenticator_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_AddAuthenticator_Request) ne(b []CTwoFactor_AddAuthenticator_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_addauthenticator_request() CTwoFactor_AddAuthenticator_Request {
	return CTwoFactor_AddAuthenticator_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_addauthenticator_request(o CTwoFactor_AddAuthenticator_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_addauthenticator_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_AddAuthenticator_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_addauthenticator_request_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_AddAuthenticator_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	shared_secret   []byte
	serial_number   u64
	revocation_code string
	uri             string
	server_time     u64
	account_name    string
	token_gid       string
	identity_secret []byte
	secret_1        []byte
	status          int
}

pub fn (o &CTwoFactor_AddAuthenticator_Response) pack() []byte {
	mut res := []byte{}
	if o.shared_secret != []byte{} {
		res << vproto.pack_bytes_field(o.shared_secret, 1)
	}
	if o.serial_number != u64(0) {
		res << vproto.pack_64bit_field(o.serial_number, 2)
	}
	if o.revocation_code != '' {
		res << vproto.pack_string_field(o.revocation_code, 3)
	}
	if o.uri != '' {
		res << vproto.pack_string_field(o.uri, 4)
	}
	if o.server_time != u64(0) {
		res << vproto.pack_uint64_field(o.server_time, 5)
	}
	if o.account_name != '' {
		res << vproto.pack_string_field(o.account_name, 6)
	}
	if o.token_gid != '' {
		res << vproto.pack_string_field(o.token_gid, 7)
	}
	if o.identity_secret != []byte{} {
		res << vproto.pack_bytes_field(o.identity_secret, 8)
	}
	if o.secret_1 != []byte{} {
		res << vproto.pack_bytes_field(o.secret_1, 9)
	}
	if o.status != int(0) {
		res << vproto.pack_int32_field(o.status, 10)
	}
	return res
}

pub fn ctwofactor_addauthenticator_response_unpack(buf []byte) ?CTwoFactor_AddAuthenticator_Response {
	mut res := zzz_vproto_internal_new_ctwofactor_addauthenticator_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.shared_secret = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.serial_number = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.revocation_code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.uri = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.server_time = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.account_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.token_gid = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.identity_secret = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.secret_1 = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.status = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_AddAuthenticator_Response) eq(b CTwoFactor_AddAuthenticator_Response) bool {
	return true && a.shared_secret == b.shared_secret && a.serial_number == b.serial_number &&
		a.revocation_code == b.revocation_code && a.uri == b.uri && a.server_time == b.server_time &&
		a.account_name == b.account_name && a.token_gid == b.token_gid && a.identity_secret == b.identity_secret &&
		a.secret_1 == b.secret_1 && a.status == b.status
}

[inline]
pub fn (a CTwoFactor_AddAuthenticator_Response) ne(b CTwoFactor_AddAuthenticator_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_AddAuthenticator_Response) eq(b []CTwoFactor_AddAuthenticator_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_AddAuthenticator_Response) ne(b []CTwoFactor_AddAuthenticator_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_addauthenticator_response() CTwoFactor_AddAuthenticator_Response {
	return CTwoFactor_AddAuthenticator_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_addauthenticator_response(o CTwoFactor_AddAuthenticator_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_addauthenticator_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_AddAuthenticator_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_addauthenticator_response_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_SendEmail_Request {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	steamid                 u64
	email_type              u32
	include_activation_code bool
}

pub fn (o &CTwoFactor_SendEmail_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.email_type != u32(0) {
		res << vproto.pack_uint32_field(o.email_type, 2)
	}
	if o.include_activation_code != false {
		res << vproto.pack_bool_field(o.include_activation_code, 3)
	}
	return res
}

pub fn ctwofactor_sendemail_request_unpack(buf []byte) ?CTwoFactor_SendEmail_Request {
	mut res := zzz_vproto_internal_new_ctwofactor_sendemail_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.email_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.include_activation_code = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_SendEmail_Request) eq(b CTwoFactor_SendEmail_Request) bool {
	return true && a.steamid == b.steamid && a.email_type == b.email_type && a.include_activation_code ==
		b.include_activation_code
}

[inline]
pub fn (a CTwoFactor_SendEmail_Request) ne(b CTwoFactor_SendEmail_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_SendEmail_Request) eq(b []CTwoFactor_SendEmail_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_SendEmail_Request) ne(b []CTwoFactor_SendEmail_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_sendemail_request() CTwoFactor_SendEmail_Request {
	return CTwoFactor_SendEmail_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_sendemail_request(o CTwoFactor_SendEmail_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_sendemail_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_SendEmail_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_sendemail_request_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_SendEmail_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CTwoFactor_SendEmail_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn ctwofactor_sendemail_response_unpack(buf []byte) ?CTwoFactor_SendEmail_Response {
	res := zzz_vproto_internal_new_ctwofactor_sendemail_response()
	return res
}

[inline]
pub fn (a CTwoFactor_SendEmail_Response) eq(b CTwoFactor_SendEmail_Response) bool {
	return true
}

[inline]
pub fn (a CTwoFactor_SendEmail_Response) ne(b CTwoFactor_SendEmail_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_SendEmail_Response) eq(b []CTwoFactor_SendEmail_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_SendEmail_Response) ne(b []CTwoFactor_SendEmail_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_sendemail_response() CTwoFactor_SendEmail_Response {
	return CTwoFactor_SendEmail_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_sendemail_response(o CTwoFactor_SendEmail_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_sendemail_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_SendEmail_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_sendemail_response_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_FinalizeAddAuthenticator_Request {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steamid            u64
	authenticator_code string
	authenticator_time u64
	activation_code    string
	http_headers       []string
}

pub fn (o &CTwoFactor_FinalizeAddAuthenticator_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.authenticator_code != '' {
		res << vproto.pack_string_field(o.authenticator_code, 2)
	}
	if o.authenticator_time != u64(0) {
		res << vproto.pack_uint64_field(o.authenticator_time, 3)
	}
	if o.activation_code != '' {
		res << vproto.pack_string_field(o.activation_code, 4)
	}
	// [packed=false]
	for _, x in o.http_headers {
		res << vproto.pack_string_field(x, 5)
	}
	return res
}

pub fn ctwofactor_finalizeaddauthenticator_request_unpack(buf []byte) ?CTwoFactor_FinalizeAddAuthenticator_Request {
	mut res := zzz_vproto_internal_new_ctwofactor_finalizeaddauthenticator_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.authenticator_code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.authenticator_time = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.activation_code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.http_headers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_FinalizeAddAuthenticator_Request) eq(b CTwoFactor_FinalizeAddAuthenticator_Request) bool {
	return true && a.steamid == b.steamid && a.authenticator_code == b.authenticator_code &&
		a.authenticator_time == b.authenticator_time && a.activation_code == b.activation_code &&
		a.http_headers == b.http_headers
}

[inline]
pub fn (a CTwoFactor_FinalizeAddAuthenticator_Request) ne(b CTwoFactor_FinalizeAddAuthenticator_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_FinalizeAddAuthenticator_Request) eq(b []CTwoFactor_FinalizeAddAuthenticator_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_FinalizeAddAuthenticator_Request) ne(b []CTwoFactor_FinalizeAddAuthenticator_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_finalizeaddauthenticator_request() CTwoFactor_FinalizeAddAuthenticator_Request {
	return CTwoFactor_FinalizeAddAuthenticator_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_finalizeaddauthenticator_request(o CTwoFactor_FinalizeAddAuthenticator_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_finalizeaddauthenticator_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_FinalizeAddAuthenticator_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_finalizeaddauthenticator_request_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_FinalizeAddAuthenticator_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	success        bool
	want_more      bool
	server_time    u64
	status         int
}

pub fn (o &CTwoFactor_FinalizeAddAuthenticator_Response) pack() []byte {
	mut res := []byte{}
	if o.success != false {
		res << vproto.pack_bool_field(o.success, 1)
	}
	if o.want_more != false {
		res << vproto.pack_bool_field(o.want_more, 2)
	}
	if o.server_time != u64(0) {
		res << vproto.pack_uint64_field(o.server_time, 3)
	}
	if o.status != int(0) {
		res << vproto.pack_int32_field(o.status, 4)
	}
	return res
}

pub fn ctwofactor_finalizeaddauthenticator_response_unpack(buf []byte) ?CTwoFactor_FinalizeAddAuthenticator_Response {
	mut res := zzz_vproto_internal_new_ctwofactor_finalizeaddauthenticator_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.success = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.want_more = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.server_time = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.status = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_FinalizeAddAuthenticator_Response) eq(b CTwoFactor_FinalizeAddAuthenticator_Response) bool {
	return true && a.success == b.success && a.want_more == b.want_more && a.server_time == b.server_time &&
		a.status == b.status
}

[inline]
pub fn (a CTwoFactor_FinalizeAddAuthenticator_Response) ne(b CTwoFactor_FinalizeAddAuthenticator_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_FinalizeAddAuthenticator_Response) eq(b []CTwoFactor_FinalizeAddAuthenticator_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_FinalizeAddAuthenticator_Response) ne(b []CTwoFactor_FinalizeAddAuthenticator_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_finalizeaddauthenticator_response() CTwoFactor_FinalizeAddAuthenticator_Response {
	return CTwoFactor_FinalizeAddAuthenticator_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_finalizeaddauthenticator_response(o CTwoFactor_FinalizeAddAuthenticator_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_finalizeaddauthenticator_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_FinalizeAddAuthenticator_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_finalizeaddauthenticator_response_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_RemoveAuthenticator_Request {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	revocation_code               string
	revocation_reason             u32
	steamguard_scheme             u32
	remove_all_steamguard_cookies bool
}

pub fn (o &CTwoFactor_RemoveAuthenticator_Request) pack() []byte {
	mut res := []byte{}
	if o.revocation_code != '' {
		res << vproto.pack_string_field(o.revocation_code, 2)
	}
	if o.revocation_reason != u32(0) {
		res << vproto.pack_uint32_field(o.revocation_reason, 5)
	}
	if o.steamguard_scheme != u32(0) {
		res << vproto.pack_uint32_field(o.steamguard_scheme, 6)
	}
	if o.remove_all_steamguard_cookies != false {
		res << vproto.pack_bool_field(o.remove_all_steamguard_cookies, 7)
	}
	return res
}

pub fn ctwofactor_removeauthenticator_request_unpack(buf []byte) ?CTwoFactor_RemoveAuthenticator_Request {
	mut res := zzz_vproto_internal_new_ctwofactor_removeauthenticator_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				i, res.revocation_code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.revocation_reason = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.steamguard_scheme = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.remove_all_steamguard_cookies = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_RemoveAuthenticator_Request) eq(b CTwoFactor_RemoveAuthenticator_Request) bool {
	return true && a.revocation_code == b.revocation_code && a.revocation_reason == b.revocation_reason &&
		a.steamguard_scheme == b.steamguard_scheme && a.remove_all_steamguard_cookies == b.remove_all_steamguard_cookies
}

[inline]
pub fn (a CTwoFactor_RemoveAuthenticator_Request) ne(b CTwoFactor_RemoveAuthenticator_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_RemoveAuthenticator_Request) eq(b []CTwoFactor_RemoveAuthenticator_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_RemoveAuthenticator_Request) ne(b []CTwoFactor_RemoveAuthenticator_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_removeauthenticator_request() CTwoFactor_RemoveAuthenticator_Request {
	return CTwoFactor_RemoveAuthenticator_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_removeauthenticator_request(o CTwoFactor_RemoveAuthenticator_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_removeauthenticator_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_RemoveAuthenticator_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_removeauthenticator_request_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_RemoveAuthenticator_Response {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	success                       bool
	server_time                   u64
	revocation_attempts_remaining u32
}

pub fn (o &CTwoFactor_RemoveAuthenticator_Response) pack() []byte {
	mut res := []byte{}
	if o.success != false {
		res << vproto.pack_bool_field(o.success, 1)
	}
	if o.server_time != u64(0) {
		res << vproto.pack_uint64_field(o.server_time, 3)
	}
	if o.revocation_attempts_remaining != u32(0) {
		res << vproto.pack_uint32_field(o.revocation_attempts_remaining, 5)
	}
	return res
}

pub fn ctwofactor_removeauthenticator_response_unpack(buf []byte) ?CTwoFactor_RemoveAuthenticator_Response {
	mut res := zzz_vproto_internal_new_ctwofactor_removeauthenticator_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.success = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.server_time = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.revocation_attempts_remaining = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_RemoveAuthenticator_Response) eq(b CTwoFactor_RemoveAuthenticator_Response) bool {
	return true && a.success == b.success && a.server_time == b.server_time && a.revocation_attempts_remaining ==
		b.revocation_attempts_remaining
}

[inline]
pub fn (a CTwoFactor_RemoveAuthenticator_Response) ne(b CTwoFactor_RemoveAuthenticator_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_RemoveAuthenticator_Response) eq(b []CTwoFactor_RemoveAuthenticator_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_RemoveAuthenticator_Response) ne(b []CTwoFactor_RemoveAuthenticator_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_removeauthenticator_response() CTwoFactor_RemoveAuthenticator_Response {
	return CTwoFactor_RemoveAuthenticator_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_removeauthenticator_response(o CTwoFactor_RemoveAuthenticator_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_removeauthenticator_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_RemoveAuthenticator_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_removeauthenticator_response_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_CreateEmergencyCodes_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	code           string
}

pub fn (o &CTwoFactor_CreateEmergencyCodes_Request) pack() []byte {
	mut res := []byte{}
	if o.code != '' {
		res << vproto.pack_string_field(o.code, 1)
	}
	return res
}

pub fn ctwofactor_createemergencycodes_request_unpack(buf []byte) ?CTwoFactor_CreateEmergencyCodes_Request {
	mut res := zzz_vproto_internal_new_ctwofactor_createemergencycodes_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_CreateEmergencyCodes_Request) eq(b CTwoFactor_CreateEmergencyCodes_Request) bool {
	return true && a.code == b.code
}

[inline]
pub fn (a CTwoFactor_CreateEmergencyCodes_Request) ne(b CTwoFactor_CreateEmergencyCodes_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_CreateEmergencyCodes_Request) eq(b []CTwoFactor_CreateEmergencyCodes_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_CreateEmergencyCodes_Request) ne(b []CTwoFactor_CreateEmergencyCodes_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_createemergencycodes_request() CTwoFactor_CreateEmergencyCodes_Request {
	return CTwoFactor_CreateEmergencyCodes_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_createemergencycodes_request(o CTwoFactor_CreateEmergencyCodes_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_createemergencycodes_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_CreateEmergencyCodes_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_createemergencycodes_request_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_CreateEmergencyCodes_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	codes          []string
}

pub fn (o &CTwoFactor_CreateEmergencyCodes_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.codes {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn ctwofactor_createemergencycodes_response_unpack(buf []byte) ?CTwoFactor_CreateEmergencyCodes_Response {
	mut res := zzz_vproto_internal_new_ctwofactor_createemergencycodes_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.codes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_CreateEmergencyCodes_Response) eq(b CTwoFactor_CreateEmergencyCodes_Response) bool {
	return true && a.codes == b.codes
}

[inline]
pub fn (a CTwoFactor_CreateEmergencyCodes_Response) ne(b CTwoFactor_CreateEmergencyCodes_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_CreateEmergencyCodes_Response) eq(b []CTwoFactor_CreateEmergencyCodes_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_CreateEmergencyCodes_Response) ne(b []CTwoFactor_CreateEmergencyCodes_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_createemergencycodes_response() CTwoFactor_CreateEmergencyCodes_Response {
	return CTwoFactor_CreateEmergencyCodes_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_createemergencycodes_response(o CTwoFactor_CreateEmergencyCodes_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_createemergencycodes_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_CreateEmergencyCodes_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_createemergencycodes_response_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_DestroyEmergencyCodes_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
}

pub fn (o &CTwoFactor_DestroyEmergencyCodes_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn ctwofactor_destroyemergencycodes_request_unpack(buf []byte) ?CTwoFactor_DestroyEmergencyCodes_Request {
	mut res := zzz_vproto_internal_new_ctwofactor_destroyemergencycodes_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_DestroyEmergencyCodes_Request) eq(b CTwoFactor_DestroyEmergencyCodes_Request) bool {
	return true && a.steamid == b.steamid
}

[inline]
pub fn (a CTwoFactor_DestroyEmergencyCodes_Request) ne(b CTwoFactor_DestroyEmergencyCodes_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_DestroyEmergencyCodes_Request) eq(b []CTwoFactor_DestroyEmergencyCodes_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_DestroyEmergencyCodes_Request) ne(b []CTwoFactor_DestroyEmergencyCodes_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_destroyemergencycodes_request() CTwoFactor_DestroyEmergencyCodes_Request {
	return CTwoFactor_DestroyEmergencyCodes_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_destroyemergencycodes_request(o CTwoFactor_DestroyEmergencyCodes_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_destroyemergencycodes_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_DestroyEmergencyCodes_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_destroyemergencycodes_request_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_DestroyEmergencyCodes_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CTwoFactor_DestroyEmergencyCodes_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn ctwofactor_destroyemergencycodes_response_unpack(buf []byte) ?CTwoFactor_DestroyEmergencyCodes_Response {
	res := zzz_vproto_internal_new_ctwofactor_destroyemergencycodes_response()
	return res
}

[inline]
pub fn (a CTwoFactor_DestroyEmergencyCodes_Response) eq(b CTwoFactor_DestroyEmergencyCodes_Response) bool {
	return true
}

[inline]
pub fn (a CTwoFactor_DestroyEmergencyCodes_Response) ne(b CTwoFactor_DestroyEmergencyCodes_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_DestroyEmergencyCodes_Response) eq(b []CTwoFactor_DestroyEmergencyCodes_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_DestroyEmergencyCodes_Response) ne(b []CTwoFactor_DestroyEmergencyCodes_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_destroyemergencycodes_response() CTwoFactor_DestroyEmergencyCodes_Response {
	return CTwoFactor_DestroyEmergencyCodes_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_destroyemergencycodes_response(o CTwoFactor_DestroyEmergencyCodes_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_destroyemergencycodes_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_DestroyEmergencyCodes_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_destroyemergencycodes_response_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_ValidateToken_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	code           string
}

pub fn (o &CTwoFactor_ValidateToken_Request) pack() []byte {
	mut res := []byte{}
	if o.code != '' {
		res << vproto.pack_string_field(o.code, 1)
	}
	return res
}

pub fn ctwofactor_validatetoken_request_unpack(buf []byte) ?CTwoFactor_ValidateToken_Request {
	mut res := zzz_vproto_internal_new_ctwofactor_validatetoken_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_ValidateToken_Request) eq(b CTwoFactor_ValidateToken_Request) bool {
	return true && a.code == b.code
}

[inline]
pub fn (a CTwoFactor_ValidateToken_Request) ne(b CTwoFactor_ValidateToken_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_ValidateToken_Request) eq(b []CTwoFactor_ValidateToken_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_ValidateToken_Request) ne(b []CTwoFactor_ValidateToken_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_validatetoken_request() CTwoFactor_ValidateToken_Request {
	return CTwoFactor_ValidateToken_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_validatetoken_request(o CTwoFactor_ValidateToken_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_validatetoken_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_ValidateToken_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_validatetoken_request_unpack(v) ?
	return i, unpacked
}

pub struct CTwoFactor_ValidateToken_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	valid          bool
}

pub fn (o &CTwoFactor_ValidateToken_Response) pack() []byte {
	mut res := []byte{}
	if o.valid != false {
		res << vproto.pack_bool_field(o.valid, 1)
	}
	return res
}

pub fn ctwofactor_validatetoken_response_unpack(buf []byte) ?CTwoFactor_ValidateToken_Response {
	mut res := zzz_vproto_internal_new_ctwofactor_validatetoken_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.valid = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CTwoFactor_ValidateToken_Response) eq(b CTwoFactor_ValidateToken_Response) bool {
	return true && a.valid == b.valid
}

[inline]
pub fn (a CTwoFactor_ValidateToken_Response) ne(b CTwoFactor_ValidateToken_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CTwoFactor_ValidateToken_Response) eq(b []CTwoFactor_ValidateToken_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CTwoFactor_ValidateToken_Response) ne(b []CTwoFactor_ValidateToken_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ctwofactor_validatetoken_response() CTwoFactor_ValidateToken_Response {
	return CTwoFactor_ValidateToken_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ctwofactor_validatetoken_response(o CTwoFactor_ValidateToken_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ctwofactor_validatetoken_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_ValidateToken_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ctwofactor_validatetoken_response_unpack(v) ?
	return i, unpacked
}
