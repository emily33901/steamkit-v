// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CCredentials_TestAvailablePassword_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	password            string
	sha_digest_password []byte
	account_name        string
}

pub fn (o &CCredentials_TestAvailablePassword_Request) pack() []byte {
	mut res := []byte{}
	if o.password != '' {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.sha_digest_password != []byte{} {
		res << vproto.pack_bytes_field(o.sha_digest_password, 2)
	}
	if o.account_name != '' {
		res << vproto.pack_string_field(o.account_name, 3)
	}
	return res
}

pub fn ccredentials_testavailablepassword_request_unpack(buf []byte) ?CCredentials_TestAvailablePassword_Request {
	mut res := zzz_vproto_internal_new_ccredentials_testavailablepassword_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.password = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.sha_digest_password = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.account_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_TestAvailablePassword_Request) eq(b CCredentials_TestAvailablePassword_Request) bool {
	return true && a.password == b.password && a.sha_digest_password == b.sha_digest_password &&
		a.account_name == b.account_name
}

[inline]
pub fn (a CCredentials_TestAvailablePassword_Request) ne(b CCredentials_TestAvailablePassword_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_TestAvailablePassword_Request) eq(b []CCredentials_TestAvailablePassword_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_TestAvailablePassword_Request) ne(b []CCredentials_TestAvailablePassword_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_testavailablepassword_request() CCredentials_TestAvailablePassword_Request {
	return CCredentials_TestAvailablePassword_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_testavailablepassword_request(o CCredentials_TestAvailablePassword_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_testavailablepassword_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_TestAvailablePassword_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_testavailablepassword_request_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_TestAvailablePassword_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	is_valid       bool
}

pub fn (o &CCredentials_TestAvailablePassword_Response) pack() []byte {
	mut res := []byte{}
	if o.is_valid != false {
		res << vproto.pack_bool_field(o.is_valid, 3)
	}
	return res
}

pub fn ccredentials_testavailablepassword_response_unpack(buf []byte) ?CCredentials_TestAvailablePassword_Response {
	mut res := zzz_vproto_internal_new_ccredentials_testavailablepassword_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			3 {
				i, res.is_valid = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_TestAvailablePassword_Response) eq(b CCredentials_TestAvailablePassword_Response) bool {
	return true && a.is_valid == b.is_valid
}

[inline]
pub fn (a CCredentials_TestAvailablePassword_Response) ne(b CCredentials_TestAvailablePassword_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_TestAvailablePassword_Response) eq(b []CCredentials_TestAvailablePassword_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_TestAvailablePassword_Response) ne(b []CCredentials_TestAvailablePassword_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_testavailablepassword_response() CCredentials_TestAvailablePassword_Response {
	return CCredentials_TestAvailablePassword_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_testavailablepassword_response(o CCredentials_TestAvailablePassword_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_testavailablepassword_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_TestAvailablePassword_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_testavailablepassword_response_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_GetSteamGuardDetails_Request {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	include_new_authentications bool = true
	webcookie                   string
	timestamp_minimum_wanted    u32
	ipaddress                   int
}

pub fn (o &CCredentials_GetSteamGuardDetails_Request) pack() []byte {
	mut res := []byte{}
	if o.include_new_authentications != false {
		res << vproto.pack_bool_field(o.include_new_authentications, 1)
	}
	if o.webcookie != '' {
		res << vproto.pack_string_field(o.webcookie, 2)
	}
	if o.timestamp_minimum_wanted != u32(0) {
		res << vproto.pack_32bit_field(o.timestamp_minimum_wanted, 3)
	}
	if o.ipaddress != int(0) {
		res << vproto.pack_int32_field(o.ipaddress, 4)
	}
	return res
}

pub fn ccredentials_getsteamguarddetails_request_unpack(buf []byte) ?CCredentials_GetSteamGuardDetails_Request {
	mut res := zzz_vproto_internal_new_ccredentials_getsteamguarddetails_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.include_new_authentications = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			2 {
				i, res.webcookie = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.timestamp_minimum_wanted = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.ipaddress = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_GetSteamGuardDetails_Request) eq(b CCredentials_GetSteamGuardDetails_Request) bool {
	return true && a.include_new_authentications == b.include_new_authentications && a.webcookie ==
		b.webcookie && a.timestamp_minimum_wanted == b.timestamp_minimum_wanted && a.ipaddress == b.ipaddress
}

[inline]
pub fn (a CCredentials_GetSteamGuardDetails_Request) ne(b CCredentials_GetSteamGuardDetails_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_GetSteamGuardDetails_Request) eq(b []CCredentials_GetSteamGuardDetails_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_GetSteamGuardDetails_Request) ne(b []CCredentials_GetSteamGuardDetails_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_getsteamguarddetails_request() CCredentials_GetSteamGuardDetails_Request {
	return CCredentials_GetSteamGuardDetails_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_request(o CCredentials_GetSteamGuardDetails_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetSteamGuardDetails_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_getsteamguarddetails_request_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_GetSteamGuardDetails_Response_NewAuthentication {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	timestamp_steamguard_enabled u32
	is_web_cookie                bool
	ipaddress                    int
	geoloc_info                  string
	is_remembered                bool
	machine_name_user_supplied   string
	status                       int
}

pub fn (o &CCredentials_GetSteamGuardDetails_Response_NewAuthentication) pack() []byte {
	mut res := []byte{}
	if o.timestamp_steamguard_enabled != u32(0) {
		res << vproto.pack_32bit_field(o.timestamp_steamguard_enabled, 1)
	}
	if o.is_web_cookie != false {
		res << vproto.pack_bool_field(o.is_web_cookie, 2)
	}
	if o.ipaddress != int(0) {
		res << vproto.pack_int32_field(o.ipaddress, 3)
	}
	if o.geoloc_info != '' {
		res << vproto.pack_string_field(o.geoloc_info, 4)
	}
	if o.is_remembered != false {
		res << vproto.pack_bool_field(o.is_remembered, 5)
	}
	if o.machine_name_user_supplied != '' {
		res << vproto.pack_string_field(o.machine_name_user_supplied, 6)
	}
	if o.status != int(0) {
		res << vproto.pack_int32_field(o.status, 7)
	}
	return res
}

pub fn ccredentials_getsteamguarddetails_response_newauthentication_unpack(buf []byte) ?CCredentials_GetSteamGuardDetails_Response_NewAuthentication {
	mut res := zzz_vproto_internal_new_ccredentials_getsteamguarddetails_response_newauthentication()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.timestamp_steamguard_enabled = vproto.unpack_32bit_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			2 {
				i, res.is_web_cookie = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.ipaddress = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.geoloc_info = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.is_remembered = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.machine_name_user_supplied = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			7 {
				i, res.status = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_GetSteamGuardDetails_Response_NewAuthentication) eq(b CCredentials_GetSteamGuardDetails_Response_NewAuthentication) bool {
	return true && a.timestamp_steamguard_enabled == b.timestamp_steamguard_enabled &&
		a.is_web_cookie == b.is_web_cookie && a.ipaddress == b.ipaddress && a.geoloc_info == b.geoloc_info &&
		a.is_remembered == b.is_remembered && a.machine_name_user_supplied == b.machine_name_user_supplied &&
		a.status == b.status
}

[inline]
pub fn (a CCredentials_GetSteamGuardDetails_Response_NewAuthentication) ne(b CCredentials_GetSteamGuardDetails_Response_NewAuthentication) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_GetSteamGuardDetails_Response_NewAuthentication) eq(b []CCredentials_GetSteamGuardDetails_Response_NewAuthentication) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_GetSteamGuardDetails_Response_NewAuthentication) ne(b []CCredentials_GetSteamGuardDetails_Response_NewAuthentication) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_getsteamguarddetails_response_newauthentication() CCredentials_GetSteamGuardDetails_Response_NewAuthentication {
	return CCredentials_GetSteamGuardDetails_Response_NewAuthentication{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response_newauthentication(o CCredentials_GetSteamGuardDetails_Response_NewAuthentication, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response_newauthentication(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetSteamGuardDetails_Response_NewAuthentication) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_getsteamguarddetails_response_newauthentication_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_GetSteamGuardDetails_Response_SessionData {
mut:
	unknown_fields                                    []vproto.UnknownField
pub mut:
	machine_id                                        u64
	machine_name_userchosen                           string
	timestamp_machine_steamguard_enabled              u32
	authentication_exists_from_geoloc_before_mintime  bool
	newauthentication                                 []CCredentials_GetSteamGuardDetails_Response_NewAuthentication
	authentication_exists_from_same_ip_before_mintime bool
	public_ipv4                                       u32
	public_ip_address                                 string
}

pub fn (o &CCredentials_GetSteamGuardDetails_Response_SessionData) pack() []byte {
	mut res := []byte{}
	if o.machine_id != u64(0) {
		res << vproto.pack_uint64_field(o.machine_id, 1)
	}
	if o.machine_name_userchosen != '' {
		res << vproto.pack_string_field(o.machine_name_userchosen, 2)
	}
	if o.timestamp_machine_steamguard_enabled != u32(0) {
		res << vproto.pack_32bit_field(o.timestamp_machine_steamguard_enabled, 3)
	}
	if o.authentication_exists_from_geoloc_before_mintime != false {
		res <<
			vproto.pack_bool_field(o.authentication_exists_from_geoloc_before_mintime, 4)
	}
	// [packed=false]
	for _, x in o.newauthentication {
		res <<
			zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response_newauthentication(x, 5)
	}
	if o.authentication_exists_from_same_ip_before_mintime != false {
		res <<
			vproto.pack_bool_field(o.authentication_exists_from_same_ip_before_mintime, 6)
	}
	if o.public_ipv4 != u32(0) {
		res << vproto.pack_uint32_field(o.public_ipv4, 7)
	}
	if o.public_ip_address != '' {
		res << vproto.pack_string_field(o.public_ip_address, 8)
	}
	return res
}

pub fn ccredentials_getsteamguarddetails_response_sessiondata_unpack(buf []byte) ?CCredentials_GetSteamGuardDetails_Response_SessionData {
	mut res := zzz_vproto_internal_new_ccredentials_getsteamguarddetails_response_sessiondata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.machine_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.machine_name_userchosen = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.timestamp_machine_steamguard_enabled = vproto.unpack_32bit_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			4 {
				i, res.authentication_exists_from_geoloc_before_mintime = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response_newauthentication(cur_buf,
					tag_wiretype.wire_type) ?
				res.newauthentication << v
				i = ii
			}
			6 {
				i, res.authentication_exists_from_same_ip_before_mintime = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			7 {
				i, res.public_ipv4 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.public_ip_address = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_GetSteamGuardDetails_Response_SessionData) eq(b CCredentials_GetSteamGuardDetails_Response_SessionData) bool {
	return true && a.machine_id == b.machine_id && a.machine_name_userchosen == b.machine_name_userchosen &&
		a.timestamp_machine_steamguard_enabled == b.timestamp_machine_steamguard_enabled && a.authentication_exists_from_geoloc_before_mintime ==
		b.authentication_exists_from_geoloc_before_mintime && a.newauthentication.eq(b.newauthentication) &&
		a.authentication_exists_from_same_ip_before_mintime == b.authentication_exists_from_same_ip_before_mintime &&
		a.public_ipv4 == b.public_ipv4 && a.public_ip_address == b.public_ip_address
}

[inline]
pub fn (a CCredentials_GetSteamGuardDetails_Response_SessionData) ne(b CCredentials_GetSteamGuardDetails_Response_SessionData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_GetSteamGuardDetails_Response_SessionData) eq(b []CCredentials_GetSteamGuardDetails_Response_SessionData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_GetSteamGuardDetails_Response_SessionData) ne(b []CCredentials_GetSteamGuardDetails_Response_SessionData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_getsteamguarddetails_response_sessiondata() CCredentials_GetSteamGuardDetails_Response_SessionData {
	return CCredentials_GetSteamGuardDetails_Response_SessionData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response_sessiondata(o CCredentials_GetSteamGuardDetails_Response_SessionData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response_sessiondata(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetSteamGuardDetails_Response_SessionData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_getsteamguarddetails_response_sessiondata_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_GetSteamGuardDetails_Response {
mut:
	unknown_fields                                              []vproto.UnknownField
pub mut:
	is_steamguard_enabled                                       bool
	timestamp_steamguard_enabled                                u32
	deprecated_newauthentication                                []CCredentials_GetSteamGuardDetails_Response_NewAuthentication
	deprecated_machine_name_userchosen                          string
	deprecated_timestamp_machine_steamguard_enabled             u32
	deprecated_authentication_exists_from_geoloc_before_mintime bool
	deprecated_machine_id                                       u64
	session_data                                                []CCredentials_GetSteamGuardDetails_Response_SessionData
	is_twofactor_enabled                                        bool
	timestamp_twofactor_enabled                                 u32
	is_phone_verified                                           bool
}

pub fn (o &CCredentials_GetSteamGuardDetails_Response) pack() []byte {
	mut res := []byte{}
	if o.is_steamguard_enabled != false {
		res << vproto.pack_bool_field(o.is_steamguard_enabled, 1)
	}
	if o.timestamp_steamguard_enabled != u32(0) {
		res << vproto.pack_32bit_field(o.timestamp_steamguard_enabled, 2)
	}
	// [packed=false]
	for _, x in o.deprecated_newauthentication {
		res <<
			zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response_newauthentication(x, 3)
	}
	if o.deprecated_machine_name_userchosen != '' {
		res << vproto.pack_string_field(o.deprecated_machine_name_userchosen, 4)
	}
	if o.deprecated_timestamp_machine_steamguard_enabled != u32(0) {
		res <<
			vproto.pack_32bit_field(o.deprecated_timestamp_machine_steamguard_enabled, 5)
	}
	if o.deprecated_authentication_exists_from_geoloc_before_mintime != false {
		res <<
			vproto.pack_bool_field(o.deprecated_authentication_exists_from_geoloc_before_mintime, 6)
	}
	if o.deprecated_machine_id != u64(0) {
		res << vproto.pack_uint64_field(o.deprecated_machine_id, 7)
	}
	// [packed=false]
	for _, x in o.session_data {
		res <<
			zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response_sessiondata(x, 8)
	}
	if o.is_twofactor_enabled != false {
		res << vproto.pack_bool_field(o.is_twofactor_enabled, 9)
	}
	if o.timestamp_twofactor_enabled != u32(0) {
		res << vproto.pack_32bit_field(o.timestamp_twofactor_enabled, 10)
	}
	if o.is_phone_verified != false {
		res << vproto.pack_bool_field(o.is_phone_verified, 11)
	}
	return res
}

pub fn ccredentials_getsteamguarddetails_response_unpack(buf []byte) ?CCredentials_GetSteamGuardDetails_Response {
	mut res := zzz_vproto_internal_new_ccredentials_getsteamguarddetails_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.is_steamguard_enabled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.timestamp_steamguard_enabled = vproto.unpack_32bit_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response_newauthentication(cur_buf,
					tag_wiretype.wire_type) ?
				res.deprecated_newauthentication << v
				i = ii
			}
			4 {
				i, res.deprecated_machine_name_userchosen = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			5 {
				i, res.deprecated_timestamp_machine_steamguard_enabled = vproto.unpack_32bit_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			6 {
				i, res.deprecated_authentication_exists_from_geoloc_before_mintime = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			7 {
				i, res.deprecated_machine_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response_sessiondata(cur_buf,
					tag_wiretype.wire_type) ?
				res.session_data << v
				i = ii
			}
			9 {
				i, res.is_twofactor_enabled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.timestamp_twofactor_enabled = vproto.unpack_32bit_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			11 {
				i, res.is_phone_verified = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_GetSteamGuardDetails_Response) eq(b CCredentials_GetSteamGuardDetails_Response) bool {
	return true && a.is_steamguard_enabled == b.is_steamguard_enabled && a.timestamp_steamguard_enabled ==
		b.timestamp_steamguard_enabled && a.deprecated_newauthentication.eq(b.deprecated_newauthentication) &&
		a.deprecated_machine_name_userchosen == b.deprecated_machine_name_userchosen && a.deprecated_timestamp_machine_steamguard_enabled ==
		b.deprecated_timestamp_machine_steamguard_enabled &&
		a.deprecated_authentication_exists_from_geoloc_before_mintime ==
		b.deprecated_authentication_exists_from_geoloc_before_mintime && a.deprecated_machine_id == b.deprecated_machine_id &&
		a.session_data.eq(b.session_data) && a.is_twofactor_enabled == b.is_twofactor_enabled &&
		a.timestamp_twofactor_enabled == b.timestamp_twofactor_enabled && a.is_phone_verified == b.is_phone_verified
}

[inline]
pub fn (a CCredentials_GetSteamGuardDetails_Response) ne(b CCredentials_GetSteamGuardDetails_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_GetSteamGuardDetails_Response) eq(b []CCredentials_GetSteamGuardDetails_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_GetSteamGuardDetails_Response) ne(b []CCredentials_GetSteamGuardDetails_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_getsteamguarddetails_response() CCredentials_GetSteamGuardDetails_Response {
	return CCredentials_GetSteamGuardDetails_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response(o CCredentials_GetSteamGuardDetails_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetSteamGuardDetails_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_getsteamguarddetails_response_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_NewMachineNotificationDialog_Request {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	is_approved        bool
	is_wizard_complete bool
}

pub fn (o &CCredentials_NewMachineNotificationDialog_Request) pack() []byte {
	mut res := []byte{}
	if o.is_approved != false {
		res << vproto.pack_bool_field(o.is_approved, 1)
	}
	if o.is_wizard_complete != false {
		res << vproto.pack_bool_field(o.is_wizard_complete, 2)
	}
	return res
}

pub fn ccredentials_newmachinenotificationdialog_request_unpack(buf []byte) ?CCredentials_NewMachineNotificationDialog_Request {
	mut res := zzz_vproto_internal_new_ccredentials_newmachinenotificationdialog_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.is_approved = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.is_wizard_complete = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_NewMachineNotificationDialog_Request) eq(b CCredentials_NewMachineNotificationDialog_Request) bool {
	return true && a.is_approved == b.is_approved && a.is_wizard_complete == b.is_wizard_complete
}

[inline]
pub fn (a CCredentials_NewMachineNotificationDialog_Request) ne(b CCredentials_NewMachineNotificationDialog_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_NewMachineNotificationDialog_Request) eq(b []CCredentials_NewMachineNotificationDialog_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_NewMachineNotificationDialog_Request) ne(b []CCredentials_NewMachineNotificationDialog_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_newmachinenotificationdialog_request() CCredentials_NewMachineNotificationDialog_Request {
	return CCredentials_NewMachineNotificationDialog_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_newmachinenotificationdialog_request(o CCredentials_NewMachineNotificationDialog_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_newmachinenotificationdialog_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_NewMachineNotificationDialog_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_newmachinenotificationdialog_request_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_NewMachineNotificationDialog_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCredentials_NewMachineNotificationDialog_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccredentials_newmachinenotificationdialog_response_unpack(buf []byte) ?CCredentials_NewMachineNotificationDialog_Response {
	res := zzz_vproto_internal_new_ccredentials_newmachinenotificationdialog_response()
	return res
}

[inline]
pub fn (a CCredentials_NewMachineNotificationDialog_Response) eq(b CCredentials_NewMachineNotificationDialog_Response) bool {
	return true
}

[inline]
pub fn (a CCredentials_NewMachineNotificationDialog_Response) ne(b CCredentials_NewMachineNotificationDialog_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_NewMachineNotificationDialog_Response) eq(b []CCredentials_NewMachineNotificationDialog_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_NewMachineNotificationDialog_Response) ne(b []CCredentials_NewMachineNotificationDialog_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_newmachinenotificationdialog_response() CCredentials_NewMachineNotificationDialog_Response {
	return CCredentials_NewMachineNotificationDialog_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_newmachinenotificationdialog_response(o CCredentials_NewMachineNotificationDialog_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_newmachinenotificationdialog_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_NewMachineNotificationDialog_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_newmachinenotificationdialog_response_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_ValidateEmailAddress_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stoken         string
}

pub fn (o &CCredentials_ValidateEmailAddress_Request) pack() []byte {
	mut res := []byte{}
	if o.stoken != '' {
		res << vproto.pack_string_field(o.stoken, 1)
	}
	return res
}

pub fn ccredentials_validateemailaddress_request_unpack(buf []byte) ?CCredentials_ValidateEmailAddress_Request {
	mut res := zzz_vproto_internal_new_ccredentials_validateemailaddress_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.stoken = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_ValidateEmailAddress_Request) eq(b CCredentials_ValidateEmailAddress_Request) bool {
	return true && a.stoken == b.stoken
}

[inline]
pub fn (a CCredentials_ValidateEmailAddress_Request) ne(b CCredentials_ValidateEmailAddress_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_ValidateEmailAddress_Request) eq(b []CCredentials_ValidateEmailAddress_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_ValidateEmailAddress_Request) ne(b []CCredentials_ValidateEmailAddress_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_validateemailaddress_request() CCredentials_ValidateEmailAddress_Request {
	return CCredentials_ValidateEmailAddress_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_validateemailaddress_request(o CCredentials_ValidateEmailAddress_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_validateemailaddress_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_ValidateEmailAddress_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_validateemailaddress_request_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_ValidateEmailAddress_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	was_validated  bool
}

pub fn (o &CCredentials_ValidateEmailAddress_Response) pack() []byte {
	mut res := []byte{}
	if o.was_validated != false {
		res << vproto.pack_bool_field(o.was_validated, 1)
	}
	return res
}

pub fn ccredentials_validateemailaddress_response_unpack(buf []byte) ?CCredentials_ValidateEmailAddress_Response {
	mut res := zzz_vproto_internal_new_ccredentials_validateemailaddress_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.was_validated = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_ValidateEmailAddress_Response) eq(b CCredentials_ValidateEmailAddress_Response) bool {
	return true && a.was_validated == b.was_validated
}

[inline]
pub fn (a CCredentials_ValidateEmailAddress_Response) ne(b CCredentials_ValidateEmailAddress_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_ValidateEmailAddress_Response) eq(b []CCredentials_ValidateEmailAddress_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_ValidateEmailAddress_Response) ne(b []CCredentials_ValidateEmailAddress_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_validateemailaddress_response() CCredentials_ValidateEmailAddress_Response {
	return CCredentials_ValidateEmailAddress_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_validateemailaddress_response(o CCredentials_ValidateEmailAddress_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_validateemailaddress_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_ValidateEmailAddress_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_validateemailaddress_response_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_SteamGuardPhishingReport_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	param_string     string
	ipaddress_actual u32
}

pub fn (o &CCredentials_SteamGuardPhishingReport_Request) pack() []byte {
	mut res := []byte{}
	if o.param_string != '' {
		res << vproto.pack_string_field(o.param_string, 1)
	}
	if o.ipaddress_actual != u32(0) {
		res << vproto.pack_uint32_field(o.ipaddress_actual, 2)
	}
	return res
}

pub fn ccredentials_steamguardphishingreport_request_unpack(buf []byte) ?CCredentials_SteamGuardPhishingReport_Request {
	mut res := zzz_vproto_internal_new_ccredentials_steamguardphishingreport_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.param_string = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.ipaddress_actual = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_SteamGuardPhishingReport_Request) eq(b CCredentials_SteamGuardPhishingReport_Request) bool {
	return true && a.param_string == b.param_string && a.ipaddress_actual == b.ipaddress_actual
}

[inline]
pub fn (a CCredentials_SteamGuardPhishingReport_Request) ne(b CCredentials_SteamGuardPhishingReport_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_SteamGuardPhishingReport_Request) eq(b []CCredentials_SteamGuardPhishingReport_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_SteamGuardPhishingReport_Request) ne(b []CCredentials_SteamGuardPhishingReport_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_steamguardphishingreport_request() CCredentials_SteamGuardPhishingReport_Request {
	return CCredentials_SteamGuardPhishingReport_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_steamguardphishingreport_request(o CCredentials_SteamGuardPhishingReport_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_steamguardphishingreport_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_SteamGuardPhishingReport_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_steamguardphishingreport_request_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_SteamGuardPhishingReport_Response {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	ipaddress_loginattempt   u32
	countryname_loginattempt string
	statename_loginattempt   string
	cityname_loginattempt    string
	ipaddress_actual         u32
	countryname_actual       string
	statename_actual         string
	cityname_actual          string
	steamguard_code          string
}

pub fn (o &CCredentials_SteamGuardPhishingReport_Response) pack() []byte {
	mut res := []byte{}
	if o.ipaddress_loginattempt != u32(0) {
		res << vproto.pack_uint32_field(o.ipaddress_loginattempt, 1)
	}
	if o.countryname_loginattempt != '' {
		res << vproto.pack_string_field(o.countryname_loginattempt, 2)
	}
	if o.statename_loginattempt != '' {
		res << vproto.pack_string_field(o.statename_loginattempt, 3)
	}
	if o.cityname_loginattempt != '' {
		res << vproto.pack_string_field(o.cityname_loginattempt, 4)
	}
	if o.ipaddress_actual != u32(0) {
		res << vproto.pack_uint32_field(o.ipaddress_actual, 5)
	}
	if o.countryname_actual != '' {
		res << vproto.pack_string_field(o.countryname_actual, 6)
	}
	if o.statename_actual != '' {
		res << vproto.pack_string_field(o.statename_actual, 7)
	}
	if o.cityname_actual != '' {
		res << vproto.pack_string_field(o.cityname_actual, 8)
	}
	if o.steamguard_code != '' {
		res << vproto.pack_string_field(o.steamguard_code, 9)
	}
	return res
}

pub fn ccredentials_steamguardphishingreport_response_unpack(buf []byte) ?CCredentials_SteamGuardPhishingReport_Response {
	mut res := zzz_vproto_internal_new_ccredentials_steamguardphishingreport_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.ipaddress_loginattempt = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.countryname_loginattempt = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			3 {
				i, res.statename_loginattempt = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.cityname_loginattempt = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.ipaddress_actual = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.countryname_actual = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.statename_actual = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.cityname_actual = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.steamguard_code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_SteamGuardPhishingReport_Response) eq(b CCredentials_SteamGuardPhishingReport_Response) bool {
	return true && a.ipaddress_loginattempt == b.ipaddress_loginattempt && a.countryname_loginattempt ==
		b.countryname_loginattempt && a.statename_loginattempt == b.statename_loginattempt &&
		a.cityname_loginattempt == b.cityname_loginattempt && a.ipaddress_actual == b.ipaddress_actual &&
		a.countryname_actual == b.countryname_actual && a.statename_actual == b.statename_actual &&
		a.cityname_actual == b.cityname_actual && a.steamguard_code == b.steamguard_code
}

[inline]
pub fn (a CCredentials_SteamGuardPhishingReport_Response) ne(b CCredentials_SteamGuardPhishingReport_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_SteamGuardPhishingReport_Response) eq(b []CCredentials_SteamGuardPhishingReport_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_SteamGuardPhishingReport_Response) ne(b []CCredentials_SteamGuardPhishingReport_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_steamguardphishingreport_response() CCredentials_SteamGuardPhishingReport_Response {
	return CCredentials_SteamGuardPhishingReport_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_steamguardphishingreport_response(o CCredentials_SteamGuardPhishingReport_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_steamguardphishingreport_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_SteamGuardPhishingReport_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_steamguardphishingreport_response_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_LastCredentialChangeTime_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	user_changes_only bool
}

pub fn (o &CCredentials_LastCredentialChangeTime_Request) pack() []byte {
	mut res := []byte{}
	if o.user_changes_only != false {
		res << vproto.pack_bool_field(o.user_changes_only, 1)
	}
	return res
}

pub fn ccredentials_lastcredentialchangetime_request_unpack(buf []byte) ?CCredentials_LastCredentialChangeTime_Request {
	mut res := zzz_vproto_internal_new_ccredentials_lastcredentialchangetime_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.user_changes_only = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_LastCredentialChangeTime_Request) eq(b CCredentials_LastCredentialChangeTime_Request) bool {
	return true && a.user_changes_only == b.user_changes_only
}

[inline]
pub fn (a CCredentials_LastCredentialChangeTime_Request) ne(b CCredentials_LastCredentialChangeTime_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_LastCredentialChangeTime_Request) eq(b []CCredentials_LastCredentialChangeTime_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_LastCredentialChangeTime_Request) ne(b []CCredentials_LastCredentialChangeTime_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_lastcredentialchangetime_request() CCredentials_LastCredentialChangeTime_Request {
	return CCredentials_LastCredentialChangeTime_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_lastcredentialchangetime_request(o CCredentials_LastCredentialChangeTime_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_lastcredentialchangetime_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_LastCredentialChangeTime_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_lastcredentialchangetime_request_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_LastCredentialChangeTime_Response {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	timestamp_last_password_change u32
	timestamp_last_email_change    u32
	timestamp_last_password_reset  u32
}

pub fn (o &CCredentials_LastCredentialChangeTime_Response) pack() []byte {
	mut res := []byte{}
	if o.timestamp_last_password_change != u32(0) {
		res << vproto.pack_32bit_field(o.timestamp_last_password_change, 1)
	}
	if o.timestamp_last_email_change != u32(0) {
		res << vproto.pack_32bit_field(o.timestamp_last_email_change, 2)
	}
	if o.timestamp_last_password_reset != u32(0) {
		res << vproto.pack_32bit_field(o.timestamp_last_password_reset, 3)
	}
	return res
}

pub fn ccredentials_lastcredentialchangetime_response_unpack(buf []byte) ?CCredentials_LastCredentialChangeTime_Response {
	mut res := zzz_vproto_internal_new_ccredentials_lastcredentialchangetime_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.timestamp_last_password_change = vproto.unpack_32bit_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			2 {
				i, res.timestamp_last_email_change = vproto.unpack_32bit_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			3 {
				i, res.timestamp_last_password_reset = vproto.unpack_32bit_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_LastCredentialChangeTime_Response) eq(b CCredentials_LastCredentialChangeTime_Response) bool {
	return true && a.timestamp_last_password_change == b.timestamp_last_password_change &&
		a.timestamp_last_email_change == b.timestamp_last_email_change && a.timestamp_last_password_reset ==
		b.timestamp_last_password_reset
}

[inline]
pub fn (a CCredentials_LastCredentialChangeTime_Response) ne(b CCredentials_LastCredentialChangeTime_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_LastCredentialChangeTime_Response) eq(b []CCredentials_LastCredentialChangeTime_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_LastCredentialChangeTime_Response) ne(b []CCredentials_LastCredentialChangeTime_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_lastcredentialchangetime_response() CCredentials_LastCredentialChangeTime_Response {
	return CCredentials_LastCredentialChangeTime_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_lastcredentialchangetime_response(o CCredentials_LastCredentialChangeTime_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_lastcredentialchangetime_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_LastCredentialChangeTime_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_lastcredentialchangetime_response_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_GetAccountAuthSecret_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCredentials_GetAccountAuthSecret_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccredentials_getaccountauthsecret_request_unpack(buf []byte) ?CCredentials_GetAccountAuthSecret_Request {
	res := zzz_vproto_internal_new_ccredentials_getaccountauthsecret_request()
	return res
}

[inline]
pub fn (a CCredentials_GetAccountAuthSecret_Request) eq(b CCredentials_GetAccountAuthSecret_Request) bool {
	return true
}

[inline]
pub fn (a CCredentials_GetAccountAuthSecret_Request) ne(b CCredentials_GetAccountAuthSecret_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_GetAccountAuthSecret_Request) eq(b []CCredentials_GetAccountAuthSecret_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_GetAccountAuthSecret_Request) ne(b []CCredentials_GetAccountAuthSecret_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_getaccountauthsecret_request() CCredentials_GetAccountAuthSecret_Request {
	return CCredentials_GetAccountAuthSecret_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_getaccountauthsecret_request(o CCredentials_GetAccountAuthSecret_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_getaccountauthsecret_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetAccountAuthSecret_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_getaccountauthsecret_request_unpack(v) ?
	return i, unpacked
}

pub struct CCredentials_GetAccountAuthSecret_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	secret_id      int
	secret         []byte
}

pub fn (o &CCredentials_GetAccountAuthSecret_Response) pack() []byte {
	mut res := []byte{}
	if o.secret_id != int(0) {
		res << vproto.pack_int32_field(o.secret_id, 1)
	}
	if o.secret != []byte{} {
		res << vproto.pack_bytes_field(o.secret, 2)
	}
	return res
}

pub fn ccredentials_getaccountauthsecret_response_unpack(buf []byte) ?CCredentials_GetAccountAuthSecret_Response {
	mut res := zzz_vproto_internal_new_ccredentials_getaccountauthsecret_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.secret_id = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.secret = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCredentials_GetAccountAuthSecret_Response) eq(b CCredentials_GetAccountAuthSecret_Response) bool {
	return true && a.secret_id == b.secret_id && a.secret == b.secret
}

[inline]
pub fn (a CCredentials_GetAccountAuthSecret_Response) ne(b CCredentials_GetAccountAuthSecret_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCredentials_GetAccountAuthSecret_Response) eq(b []CCredentials_GetAccountAuthSecret_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCredentials_GetAccountAuthSecret_Response) ne(b []CCredentials_GetAccountAuthSecret_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccredentials_getaccountauthsecret_response() CCredentials_GetAccountAuthSecret_Response {
	return CCredentials_GetAccountAuthSecret_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccredentials_getaccountauthsecret_response(o CCredentials_GetAccountAuthSecret_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccredentials_getaccountauthsecret_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetAccountAuthSecret_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ccredentials_getaccountauthsecret_response_unpack(v) ?
	return i, unpacked
}
