// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CShader_RegisterShader_Request_Shader {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	cache_key_sha   []byte
	shader_code_sha []byte
}

pub fn (o &CShader_RegisterShader_Request_Shader) pack() []byte {
	mut res := []byte{}
	if o.cache_key_sha != []byte{} {
		res << vproto.pack_bytes_field(o.cache_key_sha, 1)
	}
	if o.shader_code_sha != []byte{} {
		res << vproto.pack_bytes_field(o.shader_code_sha, 2)
	}
	return res
}

pub fn cshader_registershader_request_shader_unpack(buf []byte) ?CShader_RegisterShader_Request_Shader {
	mut res := zzz_vproto_internal_new_cshader_registershader_request_shader()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.cache_key_sha = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.shader_code_sha = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CShader_RegisterShader_Request_Shader) eq(b CShader_RegisterShader_Request_Shader) bool {
	return true && a.cache_key_sha == b.cache_key_sha && a.shader_code_sha == b.shader_code_sha
}

[inline]
pub fn (a CShader_RegisterShader_Request_Shader) ne(b CShader_RegisterShader_Request_Shader) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CShader_RegisterShader_Request_Shader) eq(b []CShader_RegisterShader_Request_Shader) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CShader_RegisterShader_Request_Shader) ne(b []CShader_RegisterShader_Request_Shader) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cshader_registershader_request_shader() CShader_RegisterShader_Request_Shader {
	return CShader_RegisterShader_Request_Shader{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cshader_registershader_request_shader(o CShader_RegisterShader_Request_Shader, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cshader_registershader_request_shader(buf []byte, tag_wiretype vproto.WireType) ?(int, CShader_RegisterShader_Request_Shader) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cshader_registershader_request_shader_unpack(v) ?
	return i, unpacked
}

pub struct CShader_RegisterShader_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	gpu_desc       string
	driver_desc    string
	shaders        []CShader_RegisterShader_Request_Shader
}

pub fn (o &CShader_RegisterShader_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.gpu_desc != '' {
		res << vproto.pack_string_field(o.gpu_desc, 2)
	}
	if o.driver_desc != '' {
		res << vproto.pack_string_field(o.driver_desc, 3)
	}
	// [packed=false]
	for _, x in o.shaders {
		res << zzz_vproto_internal_pack_cshader_registershader_request_shader(x, 4)
	}
	return res
}

pub fn cshader_registershader_request_unpack(buf []byte) ?CShader_RegisterShader_Request {
	mut res := zzz_vproto_internal_new_cshader_registershader_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.gpu_desc = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.driver_desc = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cshader_registershader_request_shader(cur_buf,
					tag_wiretype.wire_type) ?
				res.shaders << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CShader_RegisterShader_Request) eq(b CShader_RegisterShader_Request) bool {
	return true && a.appid == b.appid && a.gpu_desc == b.gpu_desc && a.driver_desc == b.driver_desc &&
		a.shaders.eq(b.shaders)
}

[inline]
pub fn (a CShader_RegisterShader_Request) ne(b CShader_RegisterShader_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CShader_RegisterShader_Request) eq(b []CShader_RegisterShader_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CShader_RegisterShader_Request) ne(b []CShader_RegisterShader_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cshader_registershader_request() CShader_RegisterShader_Request {
	return CShader_RegisterShader_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cshader_registershader_request(o CShader_RegisterShader_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cshader_registershader_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CShader_RegisterShader_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cshader_registershader_request_unpack(v) ?
	return i, unpacked
}

pub struct CShader_RegisterShader_Response {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	requested_codeids []u32
}

pub fn (o &CShader_RegisterShader_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.requested_codeids {
		res << vproto.pack_uint32_field(x, 1)
	}
	return res
}

pub fn cshader_registershader_response_unpack(buf []byte) ?CShader_RegisterShader_Response {
	mut res := zzz_vproto_internal_new_cshader_registershader_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.requested_codeids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CShader_RegisterShader_Response) eq(b CShader_RegisterShader_Response) bool {
	return true && a.requested_codeids == b.requested_codeids
}

[inline]
pub fn (a CShader_RegisterShader_Response) ne(b CShader_RegisterShader_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CShader_RegisterShader_Response) eq(b []CShader_RegisterShader_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CShader_RegisterShader_Response) ne(b []CShader_RegisterShader_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cshader_registershader_response() CShader_RegisterShader_Response {
	return CShader_RegisterShader_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cshader_registershader_response(o CShader_RegisterShader_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cshader_registershader_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CShader_RegisterShader_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cshader_registershader_response_unpack(v) ?
	return i, unpacked
}

pub struct CShader_SendShader_Request_ShaderCode {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	shader_code_sha []byte
	shader_code     []byte
}

pub fn (o &CShader_SendShader_Request_ShaderCode) pack() []byte {
	mut res := []byte{}
	if o.shader_code_sha != []byte{} {
		res << vproto.pack_bytes_field(o.shader_code_sha, 1)
	}
	if o.shader_code != []byte{} {
		res << vproto.pack_bytes_field(o.shader_code, 2)
	}
	return res
}

pub fn cshader_sendshader_request_shadercode_unpack(buf []byte) ?CShader_SendShader_Request_ShaderCode {
	mut res := zzz_vproto_internal_new_cshader_sendshader_request_shadercode()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.shader_code_sha = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.shader_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CShader_SendShader_Request_ShaderCode) eq(b CShader_SendShader_Request_ShaderCode) bool {
	return true && a.shader_code_sha == b.shader_code_sha && a.shader_code == b.shader_code
}

[inline]
pub fn (a CShader_SendShader_Request_ShaderCode) ne(b CShader_SendShader_Request_ShaderCode) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CShader_SendShader_Request_ShaderCode) eq(b []CShader_SendShader_Request_ShaderCode) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CShader_SendShader_Request_ShaderCode) ne(b []CShader_SendShader_Request_ShaderCode) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cshader_sendshader_request_shadercode() CShader_SendShader_Request_ShaderCode {
	return CShader_SendShader_Request_ShaderCode{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cshader_sendshader_request_shadercode(o CShader_SendShader_Request_ShaderCode, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cshader_sendshader_request_shadercode(buf []byte, tag_wiretype vproto.WireType) ?(int, CShader_SendShader_Request_ShaderCode) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cshader_sendshader_request_shadercode_unpack(v) ?
	return i, unpacked
}

pub struct CShader_SendShader_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	shaders        []CShader_SendShader_Request_ShaderCode
}

pub fn (o &CShader_SendShader_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.shaders {
		res << zzz_vproto_internal_pack_cshader_sendshader_request_shadercode(x, 2)
	}
	return res
}

pub fn cshader_sendshader_request_unpack(buf []byte) ?CShader_SendShader_Request {
	mut res := zzz_vproto_internal_new_cshader_sendshader_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cshader_sendshader_request_shadercode(cur_buf,
					tag_wiretype.wire_type) ?
				res.shaders << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CShader_SendShader_Request) eq(b CShader_SendShader_Request) bool {
	return true && a.appid == b.appid && a.shaders.eq(b.shaders)
}

[inline]
pub fn (a CShader_SendShader_Request) ne(b CShader_SendShader_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CShader_SendShader_Request) eq(b []CShader_SendShader_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CShader_SendShader_Request) ne(b []CShader_SendShader_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cshader_sendshader_request() CShader_SendShader_Request {
	return CShader_SendShader_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cshader_sendshader_request(o CShader_SendShader_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cshader_sendshader_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CShader_SendShader_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cshader_sendshader_request_unpack(v) ?
	return i, unpacked
}

pub struct CShader_SendShader_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CShader_SendShader_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cshader_sendshader_response_unpack(buf []byte) ?CShader_SendShader_Response {
	res := zzz_vproto_internal_new_cshader_sendshader_response()
	return res
}

[inline]
pub fn (a CShader_SendShader_Response) eq(b CShader_SendShader_Response) bool {
	return true
}

[inline]
pub fn (a CShader_SendShader_Response) ne(b CShader_SendShader_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CShader_SendShader_Response) eq(b []CShader_SendShader_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CShader_SendShader_Response) ne(b []CShader_SendShader_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cshader_sendshader_response() CShader_SendShader_Response {
	return CShader_SendShader_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cshader_sendshader_response(o CShader_SendShader_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cshader_sendshader_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CShader_SendShader_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cshader_sendshader_response_unpack(v) ?
	return i, unpacked
}

pub struct CShader_GetBucketManifest_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	gpu_desc       string
	driver_desc    string
}

pub fn (o &CShader_GetBucketManifest_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.gpu_desc != '' {
		res << vproto.pack_string_field(o.gpu_desc, 2)
	}
	if o.driver_desc != '' {
		res << vproto.pack_string_field(o.driver_desc, 3)
	}
	return res
}

pub fn cshader_getbucketmanifest_request_unpack(buf []byte) ?CShader_GetBucketManifest_Request {
	mut res := zzz_vproto_internal_new_cshader_getbucketmanifest_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.gpu_desc = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.driver_desc = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CShader_GetBucketManifest_Request) eq(b CShader_GetBucketManifest_Request) bool {
	return true && a.appid == b.appid && a.gpu_desc == b.gpu_desc && a.driver_desc == b.driver_desc
}

[inline]
pub fn (a CShader_GetBucketManifest_Request) ne(b CShader_GetBucketManifest_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CShader_GetBucketManifest_Request) eq(b []CShader_GetBucketManifest_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CShader_GetBucketManifest_Request) ne(b []CShader_GetBucketManifest_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cshader_getbucketmanifest_request() CShader_GetBucketManifest_Request {
	return CShader_GetBucketManifest_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cshader_getbucketmanifest_request(o CShader_GetBucketManifest_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cshader_getbucketmanifest_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CShader_GetBucketManifest_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cshader_getbucketmanifest_request_unpack(v) ?
	return i, unpacked
}

pub struct CShader_GetBucketManifest_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	manifestid     u64
	depotsize      u32
	bucketid       u64
}

pub fn (o &CShader_GetBucketManifest_Response) pack() []byte {
	mut res := []byte{}
	if o.manifestid != u64(0) {
		res << vproto.pack_uint64_field(o.manifestid, 1)
	}
	if o.depotsize != u32(0) {
		res << vproto.pack_uint32_field(o.depotsize, 2)
	}
	if o.bucketid != u64(0) {
		res << vproto.pack_uint64_field(o.bucketid, 3)
	}
	return res
}

pub fn cshader_getbucketmanifest_response_unpack(buf []byte) ?CShader_GetBucketManifest_Response {
	mut res := zzz_vproto_internal_new_cshader_getbucketmanifest_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.manifestid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.depotsize = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.bucketid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CShader_GetBucketManifest_Response) eq(b CShader_GetBucketManifest_Response) bool {
	return true && a.manifestid == b.manifestid && a.depotsize == b.depotsize && a.bucketid ==
		b.bucketid
}

[inline]
pub fn (a CShader_GetBucketManifest_Response) ne(b CShader_GetBucketManifest_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CShader_GetBucketManifest_Response) eq(b []CShader_GetBucketManifest_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CShader_GetBucketManifest_Response) ne(b []CShader_GetBucketManifest_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cshader_getbucketmanifest_response() CShader_GetBucketManifest_Response {
	return CShader_GetBucketManifest_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cshader_getbucketmanifest_response(o CShader_GetBucketManifest_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cshader_getbucketmanifest_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CShader_GetBucketManifest_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cshader_getbucketmanifest_response_unpack(v) ?
	return i, unpacked
}
