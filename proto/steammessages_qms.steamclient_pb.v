// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EGameSearchAction {
	k_egamesearchaction_none = 0
	k_egamesearchaction_accept = 1
	k_egamesearchaction_decline = 2
	k_egamesearchaction_cancel = 3
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_egamesearchaction() EGameSearchAction {
	return .k_egamesearchaction_none
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_egamesearchaction(e EGameSearchAction, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_egamesearchaction_packed(e []EGameSearchAction, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_egamesearchaction(buf []byte, tag_wiretype vproto.WireType) ?(int, EGameSearchAction) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, EGameSearchAction(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_egamesearchaction_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EGameSearchAction) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EGameSearchResult {
	k_egamesearchresult_invalid = 0
	k_egamesearchresult_searchinprogress = 1
	k_egamesearchresult_searchfailednohosts = 2
	k_egamesearchresult_searchgamefound = 3
	k_egamesearchresult_searchcompleteaccepted = 4
	k_egamesearchresult_searchcompletedeclined = 5
	k_egamesearchresult_searchcanceled = 6
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_egamesearchresult() EGameSearchResult {
	return .k_egamesearchresult_invalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_egamesearchresult(e EGameSearchResult, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_egamesearchresult_packed(e []EGameSearchResult, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_egamesearchresult(buf []byte, tag_wiretype vproto.WireType) ?(int, EGameSearchResult) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, EGameSearchResult(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_egamesearchresult_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EGameSearchResult) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct GameSearchParam {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key_name       string
	value          []string
}

pub fn (o &GameSearchParam) pack() []byte {
	mut res := []byte{}
	if o.key_name != '' {
		res << vproto.pack_string_field(o.key_name, 1)
	}
	// [packed=false]
	for _, x in o.value {
		res << vproto.pack_string_field(x, 2)
	}
	return res
}

pub fn gamesearchparam_unpack(buf []byte) ?GameSearchParam {
	mut res := zzz_vproto_internal_new_gamesearchparam()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.key_name = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.value << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a GameSearchParam) eq(b GameSearchParam) bool {
	return true && a.key_name == b.key_name && a.value == b.value
}

[inline]
pub fn (a GameSearchParam) ne(b GameSearchParam) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []GameSearchParam) eq(b []GameSearchParam) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []GameSearchParam) ne(b []GameSearchParam) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_gamesearchparam() GameSearchParam {
	return GameSearchParam{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_gamesearchparam(o GameSearchParam, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_gamesearchparam(buf []byte, tag_wiretype vproto.WireType) ?(int, GameSearchParam) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := gamesearchparam_unpack(v) ?
	return i, unpacked
}

pub struct CQueuedMatchmaking_SearchForGame_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	action         EGameSearchAction = .k_egamesearchaction_none
	params         []GameSearchParam
	player_min     u32
	player_max     u32
	steamidlobby   u64
	searchid       u64
}

pub fn (o &CQueuedMatchmaking_SearchForGame_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.action != zzz_vproto_internal_new_egamesearchaction() {
		res << zzz_vproto_internal_pack_egamesearchaction(o.action, 2)
	}
	// [packed=false]
	for _, x in o.params {
		res << zzz_vproto_internal_pack_gamesearchparam(x, 3)
	}
	if o.player_min != u32(0) {
		res << vproto.pack_uint32_field(o.player_min, 4)
	}
	if o.player_max != u32(0) {
		res << vproto.pack_uint32_field(o.player_max, 5)
	}
	if o.steamidlobby != u64(0) {
		res << vproto.pack_64bit_field(o.steamidlobby, 6)
	}
	if o.searchid != u64(0) {
		res << vproto.pack_uint64_field(o.searchid, 7)
	}
	return res
}

pub fn cqueuedmatchmaking_searchforgame_request_unpack(buf []byte) ?CQueuedMatchmaking_SearchForGame_Request {
	mut res := zzz_vproto_internal_new_cqueuedmatchmaking_searchforgame_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_egamesearchaction(cur_buf, tag_wiretype.wire_type) ?
				res.action = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_gamesearchparam(cur_buf, tag_wiretype.wire_type) ?
				res.params << v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.player_min = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.player_max = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamidlobby = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.searchid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CQueuedMatchmaking_SearchForGame_Request) eq(b CQueuedMatchmaking_SearchForGame_Request) bool {
	return true && a.appid == b.appid && a.action == b.action && a.params.eq(b.params) &&
		a.player_min == b.player_min && a.player_max == b.player_max && a.steamidlobby == b.steamidlobby &&
		a.searchid == b.searchid
}

[inline]
pub fn (a CQueuedMatchmaking_SearchForGame_Request) ne(b CQueuedMatchmaking_SearchForGame_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CQueuedMatchmaking_SearchForGame_Request) eq(b []CQueuedMatchmaking_SearchForGame_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CQueuedMatchmaking_SearchForGame_Request) ne(b []CQueuedMatchmaking_SearchForGame_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cqueuedmatchmaking_searchforgame_request() CQueuedMatchmaking_SearchForGame_Request {
	return CQueuedMatchmaking_SearchForGame_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cqueuedmatchmaking_searchforgame_request(o CQueuedMatchmaking_SearchForGame_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cqueuedmatchmaking_searchforgame_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CQueuedMatchmaking_SearchForGame_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cqueuedmatchmaking_searchforgame_request_unpack(v) ?
	return i, unpacked
}

pub struct CQueuedMatchmaking_SearchForGame_Response {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	gamesearchresult        EGameSearchResult = .k_egamesearchresult_invalid
	searchid                u64
	seconds_time_estimate   u32
	poll_frequency          u32
	count_searching         u32
	players_in_match        u32
	players_accepted        u32
	connect_string          string
	steamidhost             u64
	rtime_match_made        u32
	rtime_now               u32
	steamid_canceled_search u64
}

pub fn (o &CQueuedMatchmaking_SearchForGame_Response) pack() []byte {
	mut res := []byte{}
	if o.gamesearchresult != zzz_vproto_internal_new_egamesearchresult() {
		res << zzz_vproto_internal_pack_egamesearchresult(o.gamesearchresult, 1)
	}
	if o.searchid != u64(0) {
		res << vproto.pack_uint64_field(o.searchid, 2)
	}
	if o.seconds_time_estimate != u32(0) {
		res << vproto.pack_uint32_field(o.seconds_time_estimate, 3)
	}
	if o.poll_frequency != u32(0) {
		res << vproto.pack_uint32_field(o.poll_frequency, 4)
	}
	if o.count_searching != u32(0) {
		res << vproto.pack_uint32_field(o.count_searching, 5)
	}
	if o.players_in_match != u32(0) {
		res << vproto.pack_uint32_field(o.players_in_match, 6)
	}
	if o.players_accepted != u32(0) {
		res << vproto.pack_uint32_field(o.players_accepted, 7)
	}
	if o.connect_string != '' {
		res << vproto.pack_string_field(o.connect_string, 9)
	}
	if o.steamidhost != u64(0) {
		res << vproto.pack_64bit_field(o.steamidhost, 10)
	}
	if o.rtime_match_made != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_match_made, 11)
	}
	if o.rtime_now != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_now, 12)
	}
	if o.steamid_canceled_search != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_canceled_search, 13)
	}
	return res
}

pub fn cqueuedmatchmaking_searchforgame_response_unpack(buf []byte) ?CQueuedMatchmaking_SearchForGame_Response {
	mut res := zzz_vproto_internal_new_cqueuedmatchmaking_searchforgame_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_egamesearchresult(cur_buf, tag_wiretype.wire_type) ?
				res.gamesearchresult = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.searchid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seconds_time_estimate = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.poll_frequency = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.count_searching = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.players_in_match = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.players_accepted = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.connect_string = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamidhost = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.rtime_match_made = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.rtime_now = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid_canceled_search = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CQueuedMatchmaking_SearchForGame_Response) eq(b CQueuedMatchmaking_SearchForGame_Response) bool {
	return true && a.gamesearchresult == b.gamesearchresult && a.searchid == b.searchid &&
		a.seconds_time_estimate == b.seconds_time_estimate && a.poll_frequency == b.poll_frequency &&
		a.count_searching == b.count_searching && a.players_in_match == b.players_in_match &&
		a.players_accepted == b.players_accepted && a.connect_string == b.connect_string && a.steamidhost ==
		b.steamidhost && a.rtime_match_made == b.rtime_match_made && a.rtime_now == b.rtime_now &&
		a.steamid_canceled_search == b.steamid_canceled_search
}

[inline]
pub fn (a CQueuedMatchmaking_SearchForGame_Response) ne(b CQueuedMatchmaking_SearchForGame_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CQueuedMatchmaking_SearchForGame_Response) eq(b []CQueuedMatchmaking_SearchForGame_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CQueuedMatchmaking_SearchForGame_Response) ne(b []CQueuedMatchmaking_SearchForGame_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cqueuedmatchmaking_searchforgame_response() CQueuedMatchmaking_SearchForGame_Response {
	return CQueuedMatchmaking_SearchForGame_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cqueuedmatchmaking_searchforgame_response(o CQueuedMatchmaking_SearchForGame_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cqueuedmatchmaking_searchforgame_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CQueuedMatchmaking_SearchForGame_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cqueuedmatchmaking_searchforgame_response_unpack(v) ?
	return i, unpacked
}

pub struct CQueuedMatchmakingGameHost_SearchForPlayers_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	appid                u32
	action               EGameSearchAction = .k_egamesearchaction_none
	params               []GameSearchParam
	player_min           u32
	player_max           u32
	player_max_team_size u32
	connection_string    string
	searchid             u64
}

pub fn (o &CQueuedMatchmakingGameHost_SearchForPlayers_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.action != zzz_vproto_internal_new_egamesearchaction() {
		res << zzz_vproto_internal_pack_egamesearchaction(o.action, 2)
	}
	// [packed=false]
	for _, x in o.params {
		res << zzz_vproto_internal_pack_gamesearchparam(x, 3)
	}
	if o.player_min != u32(0) {
		res << vproto.pack_uint32_field(o.player_min, 4)
	}
	if o.player_max != u32(0) {
		res << vproto.pack_uint32_field(o.player_max, 5)
	}
	if o.player_max_team_size != u32(0) {
		res << vproto.pack_uint32_field(o.player_max_team_size, 6)
	}
	if o.connection_string != '' {
		res << vproto.pack_string_field(o.connection_string, 7)
	}
	if o.searchid != u64(0) {
		res << vproto.pack_uint64_field(o.searchid, 8)
	}
	return res
}

pub fn cqueuedmatchmakinggamehost_searchforplayers_request_unpack(buf []byte) ?CQueuedMatchmakingGameHost_SearchForPlayers_Request {
	mut res := zzz_vproto_internal_new_cqueuedmatchmakinggamehost_searchforplayers_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_egamesearchaction(cur_buf, tag_wiretype.wire_type) ?
				res.action = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_gamesearchparam(cur_buf, tag_wiretype.wire_type) ?
				res.params << v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.player_min = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.player_max = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.player_max_team_size = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_string = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.searchid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_SearchForPlayers_Request) eq(b CQueuedMatchmakingGameHost_SearchForPlayers_Request) bool {
	return true && a.appid == b.appid && a.action == b.action && a.params.eq(b.params) &&
		a.player_min == b.player_min && a.player_max == b.player_max && a.player_max_team_size == b.player_max_team_size &&
		a.connection_string == b.connection_string && a.searchid == b.searchid
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_SearchForPlayers_Request) ne(b CQueuedMatchmakingGameHost_SearchForPlayers_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_SearchForPlayers_Request) eq(b []CQueuedMatchmakingGameHost_SearchForPlayers_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_SearchForPlayers_Request) ne(b []CQueuedMatchmakingGameHost_SearchForPlayers_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cqueuedmatchmakinggamehost_searchforplayers_request() CQueuedMatchmakingGameHost_SearchForPlayers_Request {
	return CQueuedMatchmakingGameHost_SearchForPlayers_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cqueuedmatchmakinggamehost_searchforplayers_request(o CQueuedMatchmakingGameHost_SearchForPlayers_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cqueuedmatchmakinggamehost_searchforplayers_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CQueuedMatchmakingGameHost_SearchForPlayers_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cqueuedmatchmakinggamehost_searchforplayers_request_unpack(v) ?
	return i, unpacked
}

pub struct PlayerFound {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	action         EGameSearchAction = .k_egamesearchaction_none
	params         []GameSearchParam
	team_number    u32
}

pub fn (o &PlayerFound) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.action != zzz_vproto_internal_new_egamesearchaction() {
		res << zzz_vproto_internal_pack_egamesearchaction(o.action, 2)
	}
	// [packed=false]
	for _, x in o.params {
		res << zzz_vproto_internal_pack_gamesearchparam(x, 3)
	}
	if o.team_number != u32(0) {
		res << vproto.pack_uint32_field(o.team_number, 4)
	}
	return res
}

pub fn playerfound_unpack(buf []byte) ?PlayerFound {
	mut res := zzz_vproto_internal_new_playerfound()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_egamesearchaction(cur_buf, tag_wiretype.wire_type) ?
				res.action = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_gamesearchparam(cur_buf, tag_wiretype.wire_type) ?
				res.params << v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.team_number = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PlayerFound) eq(b PlayerFound) bool {
	return true && a.steamid == b.steamid && a.action == b.action && a.params.eq(b.params) &&
		a.team_number == b.team_number
}

[inline]
pub fn (a PlayerFound) ne(b PlayerFound) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PlayerFound) eq(b []PlayerFound) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PlayerFound) ne(b []PlayerFound) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_playerfound() PlayerFound {
	return PlayerFound{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_playerfound(o PlayerFound, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_playerfound(buf []byte, tag_wiretype vproto.WireType) ?(int, PlayerFound) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := playerfound_unpack(v) ?
	return i, unpacked
}

pub struct CQueuedMatchmakingGameHost_SearchForPlayers_Response {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	gamesearchresult EGameSearchResult = .k_egamesearchresult_invalid
	searchid         u64
	poll_frequency   u32
	matchid          u64
	players          []PlayerFound
	rtime_match_made u32
	rtime_now        u32
}

pub fn (o &CQueuedMatchmakingGameHost_SearchForPlayers_Response) pack() []byte {
	mut res := []byte{}
	if o.gamesearchresult != zzz_vproto_internal_new_egamesearchresult() {
		res << zzz_vproto_internal_pack_egamesearchresult(o.gamesearchresult, 1)
	}
	if o.searchid != u64(0) {
		res << vproto.pack_uint64_field(o.searchid, 2)
	}
	if o.poll_frequency != u32(0) {
		res << vproto.pack_uint32_field(o.poll_frequency, 3)
	}
	if o.matchid != u64(0) {
		res << vproto.pack_uint64_field(o.matchid, 4)
	}
	// [packed=false]
	for _, x in o.players {
		res << zzz_vproto_internal_pack_playerfound(x, 5)
	}
	if o.rtime_match_made != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_match_made, 6)
	}
	if o.rtime_now != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_now, 7)
	}
	return res
}

pub fn cqueuedmatchmakinggamehost_searchforplayers_response_unpack(buf []byte) ?CQueuedMatchmakingGameHost_SearchForPlayers_Response {
	mut res := zzz_vproto_internal_new_cqueuedmatchmakinggamehost_searchforplayers_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_egamesearchresult(cur_buf, tag_wiretype.wire_type) ?
				res.gamesearchresult = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.searchid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.poll_frequency = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.matchid = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_playerfound(cur_buf, tag_wiretype.wire_type) ?
				res.players << v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.rtime_match_made = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.rtime_now = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_SearchForPlayers_Response) eq(b CQueuedMatchmakingGameHost_SearchForPlayers_Response) bool {
	return true && a.gamesearchresult == b.gamesearchresult && a.searchid == b.searchid &&
		a.poll_frequency == b.poll_frequency && a.matchid == b.matchid && a.players.eq(b.players) &&
		a.rtime_match_made == b.rtime_match_made && a.rtime_now == b.rtime_now
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_SearchForPlayers_Response) ne(b CQueuedMatchmakingGameHost_SearchForPlayers_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_SearchForPlayers_Response) eq(b []CQueuedMatchmakingGameHost_SearchForPlayers_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_SearchForPlayers_Response) ne(b []CQueuedMatchmakingGameHost_SearchForPlayers_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cqueuedmatchmakinggamehost_searchforplayers_response() CQueuedMatchmakingGameHost_SearchForPlayers_Response {
	return CQueuedMatchmakingGameHost_SearchForPlayers_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cqueuedmatchmakinggamehost_searchforplayers_response(o CQueuedMatchmakingGameHost_SearchForPlayers_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cqueuedmatchmakinggamehost_searchforplayers_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CQueuedMatchmakingGameHost_SearchForPlayers_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cqueuedmatchmakinggamehost_searchforplayers_response_unpack(v) ?
	return i, unpacked
}

pub struct PlayerResult {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	value          u32
}

pub fn (o &PlayerResult) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.value != u32(0) {
		res << vproto.pack_uint32_field(o.value, 2)
	}
	return res
}

pub fn playerresult_unpack(buf []byte) ?PlayerResult {
	mut res := zzz_vproto_internal_new_playerresult()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PlayerResult) eq(b PlayerResult) bool {
	return true && a.steamid == b.steamid && a.value == b.value
}

[inline]
pub fn (a PlayerResult) ne(b PlayerResult) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PlayerResult) eq(b []PlayerResult) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PlayerResult) ne(b []PlayerResult) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_playerresult() PlayerResult {
	return PlayerResult{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_playerresult(o PlayerResult, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_playerresult(buf []byte, tag_wiretype vproto.WireType) ?(int, PlayerResult) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := playerresult_unpack(v) ?
	return i, unpacked
}

pub struct CQueuedMatchmakingGameHost_SubmitPlayerResult_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	matchid        u64
	player_results []PlayerResult
}

pub fn (o &CQueuedMatchmakingGameHost_SubmitPlayerResult_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.matchid != u64(0) {
		res << vproto.pack_uint64_field(o.matchid, 2)
	}
	// [packed=false]
	for _, x in o.player_results {
		res << zzz_vproto_internal_pack_playerresult(x, 3)
	}
	return res
}

pub fn cqueuedmatchmakinggamehost_submitplayerresult_request_unpack(buf []byte) ?CQueuedMatchmakingGameHost_SubmitPlayerResult_Request {
	mut res := zzz_vproto_internal_new_cqueuedmatchmakinggamehost_submitplayerresult_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.matchid = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_playerresult(cur_buf, tag_wiretype.wire_type) ?
				res.player_results << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_SubmitPlayerResult_Request) eq(b CQueuedMatchmakingGameHost_SubmitPlayerResult_Request) bool {
	return true && a.appid == b.appid && a.matchid == b.matchid && a.player_results.eq(b.player_results)
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_SubmitPlayerResult_Request) ne(b CQueuedMatchmakingGameHost_SubmitPlayerResult_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_SubmitPlayerResult_Request) eq(b []CQueuedMatchmakingGameHost_SubmitPlayerResult_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_SubmitPlayerResult_Request) ne(b []CQueuedMatchmakingGameHost_SubmitPlayerResult_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cqueuedmatchmakinggamehost_submitplayerresult_request() CQueuedMatchmakingGameHost_SubmitPlayerResult_Request {
	return CQueuedMatchmakingGameHost_SubmitPlayerResult_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cqueuedmatchmakinggamehost_submitplayerresult_request(o CQueuedMatchmakingGameHost_SubmitPlayerResult_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cqueuedmatchmakinggamehost_submitplayerresult_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CQueuedMatchmakingGameHost_SubmitPlayerResult_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cqueuedmatchmakinggamehost_submitplayerresult_request_unpack(v) ?
	return i, unpacked
}

pub struct CQueuedMatchmakingGameHost_SubmitPlayerResult_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CQueuedMatchmakingGameHost_SubmitPlayerResult_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cqueuedmatchmakinggamehost_submitplayerresult_response_unpack(buf []byte) ?CQueuedMatchmakingGameHost_SubmitPlayerResult_Response {
	res := zzz_vproto_internal_new_cqueuedmatchmakinggamehost_submitplayerresult_response()
	return res
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_SubmitPlayerResult_Response) eq(b CQueuedMatchmakingGameHost_SubmitPlayerResult_Response) bool {
	return true
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_SubmitPlayerResult_Response) ne(b CQueuedMatchmakingGameHost_SubmitPlayerResult_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_SubmitPlayerResult_Response) eq(b []CQueuedMatchmakingGameHost_SubmitPlayerResult_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_SubmitPlayerResult_Response) ne(b []CQueuedMatchmakingGameHost_SubmitPlayerResult_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cqueuedmatchmakinggamehost_submitplayerresult_response() CQueuedMatchmakingGameHost_SubmitPlayerResult_Response {
	return CQueuedMatchmakingGameHost_SubmitPlayerResult_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cqueuedmatchmakinggamehost_submitplayerresult_response(o CQueuedMatchmakingGameHost_SubmitPlayerResult_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cqueuedmatchmakinggamehost_submitplayerresult_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CQueuedMatchmakingGameHost_SubmitPlayerResult_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cqueuedmatchmakinggamehost_submitplayerresult_response_unpack(v) ?
	return i, unpacked
}

pub struct CQueuedMatchmakingGameHost_EndGame_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	matchid        u64
}

pub fn (o &CQueuedMatchmakingGameHost_EndGame_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.matchid != u64(0) {
		res << vproto.pack_uint64_field(o.matchid, 2)
	}
	return res
}

pub fn cqueuedmatchmakinggamehost_endgame_request_unpack(buf []byte) ?CQueuedMatchmakingGameHost_EndGame_Request {
	mut res := zzz_vproto_internal_new_cqueuedmatchmakinggamehost_endgame_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.matchid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_EndGame_Request) eq(b CQueuedMatchmakingGameHost_EndGame_Request) bool {
	return true && a.appid == b.appid && a.matchid == b.matchid
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_EndGame_Request) ne(b CQueuedMatchmakingGameHost_EndGame_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_EndGame_Request) eq(b []CQueuedMatchmakingGameHost_EndGame_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_EndGame_Request) ne(b []CQueuedMatchmakingGameHost_EndGame_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cqueuedmatchmakinggamehost_endgame_request() CQueuedMatchmakingGameHost_EndGame_Request {
	return CQueuedMatchmakingGameHost_EndGame_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cqueuedmatchmakinggamehost_endgame_request(o CQueuedMatchmakingGameHost_EndGame_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cqueuedmatchmakinggamehost_endgame_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CQueuedMatchmakingGameHost_EndGame_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cqueuedmatchmakinggamehost_endgame_request_unpack(v) ?
	return i, unpacked
}

pub struct CQueuedMatchmakingGameHost_EndGame_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CQueuedMatchmakingGameHost_EndGame_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cqueuedmatchmakinggamehost_endgame_response_unpack(buf []byte) ?CQueuedMatchmakingGameHost_EndGame_Response {
	res := zzz_vproto_internal_new_cqueuedmatchmakinggamehost_endgame_response()
	return res
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_EndGame_Response) eq(b CQueuedMatchmakingGameHost_EndGame_Response) bool {
	return true
}

[inline]
pub fn (a CQueuedMatchmakingGameHost_EndGame_Response) ne(b CQueuedMatchmakingGameHost_EndGame_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_EndGame_Response) eq(b []CQueuedMatchmakingGameHost_EndGame_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CQueuedMatchmakingGameHost_EndGame_Response) ne(b []CQueuedMatchmakingGameHost_EndGame_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cqueuedmatchmakinggamehost_endgame_response() CQueuedMatchmakingGameHost_EndGame_Response {
	return CQueuedMatchmakingGameHost_EndGame_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cqueuedmatchmakinggamehost_endgame_response(o CQueuedMatchmakingGameHost_EndGame_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cqueuedmatchmakinggamehost_endgame_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CQueuedMatchmakingGameHost_EndGame_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cqueuedmatchmakinggamehost_endgame_response_unpack(v) ?
	return i, unpacked
}
