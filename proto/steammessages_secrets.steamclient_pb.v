// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EKeyEscrowUsage {
	k_ekeyescrowusagestreamingdevice = 0
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_ekeyescrowusage() EKeyEscrowUsage {
	return .k_ekeyescrowusagestreamingdevice
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_ekeyescrowusage(e EKeyEscrowUsage, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_ekeyescrowusage_packed(e []EKeyEscrowUsage, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_ekeyescrowusage(buf []byte, tag_wiretype vproto.WireType) ?(int, EKeyEscrowUsage) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, EKeyEscrowUsage(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_ekeyescrowusage_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EKeyEscrowUsage) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CKeyEscrow_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	rsa_oaep_sha_ticket []byte
	password            []byte
	usage               EKeyEscrowUsage = .k_ekeyescrowusagestreamingdevice
	device_name         string
}

pub fn (o &CKeyEscrow_Request) pack() []byte {
	mut res := []byte{}
	if o.rsa_oaep_sha_ticket != []byte{} {
		res << vproto.pack_bytes_field(o.rsa_oaep_sha_ticket, 1)
	}
	if o.password != []byte{} {
		res << vproto.pack_bytes_field(o.password, 2)
	}
	if o.usage != zzz_vproto_internal_new_ekeyescrowusage() {
		res << zzz_vproto_internal_pack_ekeyescrowusage(o.usage, 3)
	}
	if o.device_name != '' {
		res << vproto.pack_string_field(o.device_name, 4)
	}
	return res
}

pub fn ckeyescrow_request_unpack(buf []byte) ?CKeyEscrow_Request {
	mut res := zzz_vproto_internal_new_ckeyescrow_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.rsa_oaep_sha_ticket = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.password = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.usage = zzz_vproto_internal_unpack_ekeyescrowusage(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.device_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CKeyEscrow_Request) eq(b CKeyEscrow_Request) bool {
	return true && a.rsa_oaep_sha_ticket == b.rsa_oaep_sha_ticket && a.password == b.password &&
		a.usage == b.usage && a.device_name == b.device_name
}

[inline]
pub fn (a CKeyEscrow_Request) ne(b CKeyEscrow_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CKeyEscrow_Request) eq(b []CKeyEscrow_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CKeyEscrow_Request) ne(b []CKeyEscrow_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ckeyescrow_request() CKeyEscrow_Request {
	return CKeyEscrow_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ckeyescrow_request(o CKeyEscrow_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ckeyescrow_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CKeyEscrow_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ckeyescrow_request_unpack(v) ?
	return i, unpacked
}

pub struct CKeyEscrow_Ticket {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	password               []byte
	identifier             u64
	payload                []byte
	timestamp              u32
	usage                  EKeyEscrowUsage = .k_ekeyescrowusagestreamingdevice
	device_name            string
	device_model           string
	device_serial          string
	device_provisioning_id u32
}

pub fn (o &CKeyEscrow_Ticket) pack() []byte {
	mut res := []byte{}
	if o.password != []byte{} {
		res << vproto.pack_bytes_field(o.password, 1)
	}
	if o.identifier != u64(0) {
		res << vproto.pack_uint64_field(o.identifier, 2)
	}
	if o.payload != []byte{} {
		res << vproto.pack_bytes_field(o.payload, 3)
	}
	if o.timestamp != u32(0) {
		res << vproto.pack_uint32_field(o.timestamp, 4)
	}
	if o.usage != zzz_vproto_internal_new_ekeyescrowusage() {
		res << zzz_vproto_internal_pack_ekeyescrowusage(o.usage, 5)
	}
	if o.device_name != '' {
		res << vproto.pack_string_field(o.device_name, 6)
	}
	if o.device_model != '' {
		res << vproto.pack_string_field(o.device_model, 7)
	}
	if o.device_serial != '' {
		res << vproto.pack_string_field(o.device_serial, 8)
	}
	if o.device_provisioning_id != u32(0) {
		res << vproto.pack_uint32_field(o.device_provisioning_id, 9)
	}
	return res
}

pub fn ckeyescrow_ticket_unpack(buf []byte) ?CKeyEscrow_Ticket {
	mut res := zzz_vproto_internal_new_ckeyescrow_ticket()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.password = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.identifier = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.payload = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.timestamp = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.usage = zzz_vproto_internal_unpack_ekeyescrowusage(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.device_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.device_model = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.device_serial = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.device_provisioning_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CKeyEscrow_Ticket) eq(b CKeyEscrow_Ticket) bool {
	return true && a.password == b.password && a.identifier == b.identifier && a.payload == b.payload &&
		a.timestamp == b.timestamp && a.usage == b.usage && a.device_name == b.device_name &&
		a.device_model == b.device_model && a.device_serial == b.device_serial && a.device_provisioning_id ==
		b.device_provisioning_id
}

[inline]
pub fn (a CKeyEscrow_Ticket) ne(b CKeyEscrow_Ticket) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CKeyEscrow_Ticket) eq(b []CKeyEscrow_Ticket) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CKeyEscrow_Ticket) ne(b []CKeyEscrow_Ticket) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ckeyescrow_ticket() CKeyEscrow_Ticket {
	return CKeyEscrow_Ticket{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ckeyescrow_ticket(o CKeyEscrow_Ticket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ckeyescrow_ticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CKeyEscrow_Ticket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ckeyescrow_ticket_unpack(v) ?
	return i, unpacked
}

pub struct CKeyEscrow_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ticket         CKeyEscrow_Ticket
}

pub fn (o &CKeyEscrow_Response) pack() []byte {
	mut res := []byte{}
	if o.ticket.ne(zzz_vproto_internal_new_ckeyescrow_ticket()) {
		res << zzz_vproto_internal_pack_ckeyescrow_ticket(o.ticket, 1)
	}
	return res
}

pub fn ckeyescrow_response_unpack(buf []byte) ?CKeyEscrow_Response {
	mut res := zzz_vproto_internal_new_ckeyescrow_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.ticket = zzz_vproto_internal_unpack_ckeyescrow_ticket(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CKeyEscrow_Response) eq(b CKeyEscrow_Response) bool {
	return true && a.ticket.eq(b.ticket)
}

[inline]
pub fn (a CKeyEscrow_Response) ne(b CKeyEscrow_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CKeyEscrow_Response) eq(b []CKeyEscrow_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CKeyEscrow_Response) ne(b []CKeyEscrow_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ckeyescrow_response() CKeyEscrow_Response {
	return CKeyEscrow_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ckeyescrow_response(o CKeyEscrow_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ckeyescrow_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CKeyEscrow_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ckeyescrow_response_unpack(v) ?
	return i, unpacked
}
