// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CMsgRemoteClientStatus {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	client_id      u64
	instance_id    u64
	status         CMsgRemoteClientBroadcastStatus
}

pub fn (o &CMsgRemoteClientStatus) pack() []byte {
	mut res := []byte{}
	if o.client_id != u64(0) {
		res << vproto.pack_uint64_field(o.client_id, 1)
	}
	if o.instance_id != u64(0) {
		res << vproto.pack_uint64_field(o.instance_id, 2)
	}
	if o.status.ne(zzz_vproto_internal_new_cmsgremoteclientbroadcaststatus()) {
		res << zzz_vproto_internal_pack_cmsgremoteclientbroadcaststatus(o.status, 3)
	}
	return res
}

pub fn cmsgremoteclientstatus_unpack(buf []byte) ?CMsgRemoteClientStatus {
	mut res := zzz_vproto_internal_new_cmsgremoteclientstatus()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.client_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.instance_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.status = zzz_vproto_internal_unpack_cmsgremoteclientbroadcaststatus(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientStatus) eq(b CMsgRemoteClientStatus) bool {
	return true && a.client_id == b.client_id && a.instance_id == b.instance_id && a.status.eq(b.status)
}

[inline]
pub fn (a CMsgRemoteClientStatus) ne(b CMsgRemoteClientStatus) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientStatus) eq(b []CMsgRemoteClientStatus) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientStatus) ne(b []CMsgRemoteClientStatus) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientstatus() CMsgRemoteClientStatus {
	return CMsgRemoteClientStatus{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientstatus(o CMsgRemoteClientStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientstatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientstatus_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientAppStatus_AppUpdateInfo {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	time_update_start           u32
	bytes_to_download           u64
	bytes_downloaded            u64
	bytes_to_process            u64
	bytes_processed             u64
	estimated_seconds_remaining int = -1
	update_result               int
	update_state                u32
}

pub fn (o &CMsgRemoteClientAppStatus_AppUpdateInfo) pack() []byte {
	mut res := []byte{}
	if o.time_update_start != u32(0) {
		res << vproto.pack_32bit_field(o.time_update_start, 1)
	}
	if o.bytes_to_download != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_to_download, 2)
	}
	if o.bytes_downloaded != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_downloaded, 3)
	}
	if o.bytes_to_process != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_to_process, 4)
	}
	if o.bytes_processed != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_processed, 5)
	}
	if o.estimated_seconds_remaining != int(0) {
		res << vproto.pack_int32_field(o.estimated_seconds_remaining, 6)
	}
	if o.update_result != int(0) {
		res << vproto.pack_int32_field(o.update_result, 7)
	}
	if o.update_state != u32(0) {
		res << vproto.pack_uint32_field(o.update_state, 8)
	}
	return res
}

pub fn cmsgremoteclientappstatus_appupdateinfo_unpack(buf []byte) ?CMsgRemoteClientAppStatus_AppUpdateInfo {
	mut res := zzz_vproto_internal_new_cmsgremoteclientappstatus_appupdateinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.time_update_start = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.bytes_to_download = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.bytes_downloaded = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.bytes_to_process = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.bytes_processed = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.estimated_seconds_remaining = vproto.unpack_int32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			7 {
				i, res.update_result = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.update_state = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientAppStatus_AppUpdateInfo) eq(b CMsgRemoteClientAppStatus_AppUpdateInfo) bool {
	return true && a.time_update_start == b.time_update_start && a.bytes_to_download == b.bytes_to_download &&
		a.bytes_downloaded == b.bytes_downloaded && a.bytes_to_process == b.bytes_to_process &&
		a.bytes_processed == b.bytes_processed && a.estimated_seconds_remaining == b.estimated_seconds_remaining &&
		a.update_result == b.update_result && a.update_state == b.update_state
}

[inline]
pub fn (a CMsgRemoteClientAppStatus_AppUpdateInfo) ne(b CMsgRemoteClientAppStatus_AppUpdateInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientAppStatus_AppUpdateInfo) eq(b []CMsgRemoteClientAppStatus_AppUpdateInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientAppStatus_AppUpdateInfo) ne(b []CMsgRemoteClientAppStatus_AppUpdateInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientappstatus_appupdateinfo() CMsgRemoteClientAppStatus_AppUpdateInfo {
	return CMsgRemoteClientAppStatus_AppUpdateInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientappstatus_appupdateinfo(o CMsgRemoteClientAppStatus_AppUpdateInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientappstatus_appupdateinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientAppStatus_AppUpdateInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientappstatus_appupdateinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientAppStatus_ShortcutInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	icon           string
	categories     []string
	exepath        string
}

pub fn (o &CMsgRemoteClientAppStatus_ShortcutInfo) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.icon != '' {
		res << vproto.pack_string_field(o.icon, 2)
	}
	// [packed=false]
	for _, x in o.categories {
		res << vproto.pack_string_field(x, 3)
	}
	if o.exepath != '' {
		res << vproto.pack_string_field(o.exepath, 4)
	}
	return res
}

pub fn cmsgremoteclientappstatus_shortcutinfo_unpack(buf []byte) ?CMsgRemoteClientAppStatus_ShortcutInfo {
	mut res := zzz_vproto_internal_new_cmsgremoteclientappstatus_shortcutinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.icon = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.categories << v
				i = ii
			}
			4 {
				i, res.exepath = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientAppStatus_ShortcutInfo) eq(b CMsgRemoteClientAppStatus_ShortcutInfo) bool {
	return true && a.name == b.name && a.icon == b.icon && a.categories == b.categories &&
		a.exepath == b.exepath
}

[inline]
pub fn (a CMsgRemoteClientAppStatus_ShortcutInfo) ne(b CMsgRemoteClientAppStatus_ShortcutInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientAppStatus_ShortcutInfo) eq(b []CMsgRemoteClientAppStatus_ShortcutInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientAppStatus_ShortcutInfo) ne(b []CMsgRemoteClientAppStatus_ShortcutInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientappstatus_shortcutinfo() CMsgRemoteClientAppStatus_ShortcutInfo {
	return CMsgRemoteClientAppStatus_ShortcutInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientappstatus_shortcutinfo(o CMsgRemoteClientAppStatus_ShortcutInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientappstatus_shortcutinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientAppStatus_ShortcutInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientappstatus_shortcutinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientAppStatus_AppStatus {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	app_id           u32
	app_state        u32
	update_info      CMsgRemoteClientAppStatus_AppUpdateInfo
	shortcut_info    CMsgRemoteClientAppStatus_ShortcutInfo
	launch_available bool = true
}

pub fn (o &CMsgRemoteClientAppStatus_AppStatus) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.app_state != u32(0) {
		res << vproto.pack_uint32_field(o.app_state, 2)
	}
	if o.update_info.ne(zzz_vproto_internal_new_cmsgremoteclientappstatus_appupdateinfo()) {
		res <<
			zzz_vproto_internal_pack_cmsgremoteclientappstatus_appupdateinfo(o.update_info, 3)
	}
	if o.shortcut_info.ne(zzz_vproto_internal_new_cmsgremoteclientappstatus_shortcutinfo()) {
		res <<
			zzz_vproto_internal_pack_cmsgremoteclientappstatus_shortcutinfo(o.shortcut_info, 4)
	}
	if o.launch_available != false {
		res << vproto.pack_bool_field(o.launch_available, 5)
	}
	return res
}

pub fn cmsgremoteclientappstatus_appstatus_unpack(buf []byte) ?CMsgRemoteClientAppStatus_AppStatus {
	mut res := zzz_vproto_internal_new_cmsgremoteclientappstatus_appstatus()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.app_state = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.update_info = zzz_vproto_internal_unpack_cmsgremoteclientappstatus_appupdateinfo(cur_buf,
					tag_wiretype.wire_type) ?
			}
			4 {
				i, res.shortcut_info = zzz_vproto_internal_unpack_cmsgremoteclientappstatus_shortcutinfo(cur_buf,
					tag_wiretype.wire_type) ?
			}
			5 {
				i, res.launch_available = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientAppStatus_AppStatus) eq(b CMsgRemoteClientAppStatus_AppStatus) bool {
	return true && a.app_id == b.app_id && a.app_state == b.app_state && a.update_info.eq(b.update_info) &&
		a.shortcut_info.eq(b.shortcut_info) && a.launch_available == b.launch_available
}

[inline]
pub fn (a CMsgRemoteClientAppStatus_AppStatus) ne(b CMsgRemoteClientAppStatus_AppStatus) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientAppStatus_AppStatus) eq(b []CMsgRemoteClientAppStatus_AppStatus) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientAppStatus_AppStatus) ne(b []CMsgRemoteClientAppStatus_AppStatus) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientappstatus_appstatus() CMsgRemoteClientAppStatus_AppStatus {
	return CMsgRemoteClientAppStatus_AppStatus{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientappstatus_appstatus(o CMsgRemoteClientAppStatus_AppStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientappstatus_appstatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientAppStatus_AppStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientappstatus_appstatus_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientAppStatus {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	status_updates []CMsgRemoteClientAppStatus_AppStatus
}

pub fn (o &CMsgRemoteClientAppStatus) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.status_updates {
		res << zzz_vproto_internal_pack_cmsgremoteclientappstatus_appstatus(x, 1)
	}
	return res
}

pub fn cmsgremoteclientappstatus_unpack(buf []byte) ?CMsgRemoteClientAppStatus {
	mut res := zzz_vproto_internal_new_cmsgremoteclientappstatus()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgremoteclientappstatus_appstatus(cur_buf,
					tag_wiretype.wire_type) ?
				res.status_updates << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientAppStatus) eq(b CMsgRemoteClientAppStatus) bool {
	return true && a.status_updates.eq(b.status_updates)
}

[inline]
pub fn (a CMsgRemoteClientAppStatus) ne(b CMsgRemoteClientAppStatus) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientAppStatus) eq(b []CMsgRemoteClientAppStatus) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientAppStatus) ne(b []CMsgRemoteClientAppStatus) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientappstatus() CMsgRemoteClientAppStatus {
	return CMsgRemoteClientAppStatus{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientappstatus(o CMsgRemoteClientAppStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientappstatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientAppStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientappstatus_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientStartStream_ReservedGamepad {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	controller_type    u32
	controller_subtype u32
}

pub fn (o &CMsgRemoteClientStartStream_ReservedGamepad) pack() []byte {
	mut res := []byte{}
	if o.controller_type != u32(0) {
		res << vproto.pack_uint32_field(o.controller_type, 1)
	}
	if o.controller_subtype != u32(0) {
		res << vproto.pack_uint32_field(o.controller_subtype, 2)
	}
	return res
}

pub fn cmsgremoteclientstartstream_reservedgamepad_unpack(buf []byte) ?CMsgRemoteClientStartStream_ReservedGamepad {
	mut res := zzz_vproto_internal_new_cmsgremoteclientstartstream_reservedgamepad()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.controller_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.controller_subtype = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientStartStream_ReservedGamepad) eq(b CMsgRemoteClientStartStream_ReservedGamepad) bool {
	return true && a.controller_type == b.controller_type && a.controller_subtype == b.controller_subtype
}

[inline]
pub fn (a CMsgRemoteClientStartStream_ReservedGamepad) ne(b CMsgRemoteClientStartStream_ReservedGamepad) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientStartStream_ReservedGamepad) eq(b []CMsgRemoteClientStartStream_ReservedGamepad) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientStartStream_ReservedGamepad) ne(b []CMsgRemoteClientStartStream_ReservedGamepad) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientstartstream_reservedgamepad() CMsgRemoteClientStartStream_ReservedGamepad {
	return CMsgRemoteClientStartStream_ReservedGamepad{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientstartstream_reservedgamepad(o CMsgRemoteClientStartStream_ReservedGamepad, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientstartstream_reservedgamepad(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientStartStream_ReservedGamepad) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientstartstream_reservedgamepad_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientStartStream {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	app_id               u32
	environment          int
	gamepad_count        int
	launch_option        int = -1
	lock_parental_lock   bool
	unlock_parental_lock string
	maximum_resolution_x int
	maximum_resolution_y int
	gamepads             []CMsgRemoteClientStartStream_ReservedGamepad
	audio_channel_count  int = 2
	supported_transport  []EStreamTransport
}

pub fn (o &CMsgRemoteClientStartStream) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.environment != int(0) {
		res << vproto.pack_int32_field(o.environment, 2)
	}
	if o.gamepad_count != int(0) {
		res << vproto.pack_int32_field(o.gamepad_count, 3)
	}
	if o.launch_option != int(0) {
		res << vproto.pack_int32_field(o.launch_option, 4)
	}
	if o.lock_parental_lock != false {
		res << vproto.pack_bool_field(o.lock_parental_lock, 5)
	}
	if o.unlock_parental_lock != '' {
		res << vproto.pack_string_field(o.unlock_parental_lock, 6)
	}
	if o.maximum_resolution_x != int(0) {
		res << vproto.pack_int32_field(o.maximum_resolution_x, 7)
	}
	if o.maximum_resolution_y != int(0) {
		res << vproto.pack_int32_field(o.maximum_resolution_y, 8)
	}
	// [packed=false]
	for _, x in o.gamepads {
		res <<
			zzz_vproto_internal_pack_cmsgremoteclientstartstream_reservedgamepad(x, 9)
	}
	if o.audio_channel_count != int(0) {
		res << vproto.pack_int32_field(o.audio_channel_count, 10)
	}
	// [packed=false]
	for _, x in o.supported_transport {
		res << zzz_vproto_internal_pack_estreamtransport(x, 11)
	}
	return res
}

pub fn cmsgremoteclientstartstream_unpack(buf []byte) ?CMsgRemoteClientStartStream {
	mut res := zzz_vproto_internal_new_cmsgremoteclientstartstream()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.environment = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.gamepad_count = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.launch_option = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.lock_parental_lock = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.unlock_parental_lock = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.maximum_resolution_x = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.maximum_resolution_y = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgremoteclientstartstream_reservedgamepad(cur_buf,
					tag_wiretype.wire_type) ?
				res.gamepads << v
				i = ii
			}
			10 {
				i, res.audio_channel_count = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_estreamtransport(cur_buf, tag_wiretype.wire_type) ?
				res.supported_transport << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientStartStream) eq(b CMsgRemoteClientStartStream) bool {
	return true && a.app_id == b.app_id && a.environment == b.environment && a.gamepad_count ==
		b.gamepad_count && a.launch_option == b.launch_option && a.lock_parental_lock == b.lock_parental_lock &&
		a.unlock_parental_lock == b.unlock_parental_lock && a.maximum_resolution_x == b.maximum_resolution_x &&
		a.maximum_resolution_y == b.maximum_resolution_y && a.gamepads.eq(b.gamepads) && a.audio_channel_count ==
		b.audio_channel_count && a.supported_transport == b.supported_transport
}

[inline]
pub fn (a CMsgRemoteClientStartStream) ne(b CMsgRemoteClientStartStream) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientStartStream) eq(b []CMsgRemoteClientStartStream) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientStartStream) ne(b []CMsgRemoteClientStartStream) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientstartstream() CMsgRemoteClientStartStream {
	return CMsgRemoteClientStartStream{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientstartstream(o CMsgRemoteClientStartStream, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientstartstream(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientStartStream) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientstartstream_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientStartStreamResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	e_launch_result    int = 2
	stream_port        u32
	launch_options     []int
	auth_token         []byte
	transport          EStreamTransport = .k_estreamtransportudp
	relay_server       string
	launch_task        string
	launch_task_detail string
	launch_tasks_done  int
	launch_tasks_total int
}

pub fn (o &CMsgRemoteClientStartStreamResponse) pack() []byte {
	mut res := []byte{}
	if o.e_launch_result != int(0) {
		res << vproto.pack_int32_field(o.e_launch_result, 1)
	}
	if o.stream_port != u32(0) {
		res << vproto.pack_uint32_field(o.stream_port, 2)
	}
	// [packed=false]
	for _, x in o.launch_options {
		res << vproto.pack_int32_field(x, 3)
	}
	if o.auth_token != []byte{} {
		res << vproto.pack_bytes_field(o.auth_token, 4)
	}
	if o.transport != zzz_vproto_internal_new_estreamtransport() {
		res << zzz_vproto_internal_pack_estreamtransport(o.transport, 5)
	}
	if o.relay_server != '' {
		res << vproto.pack_string_field(o.relay_server, 6)
	}
	if o.launch_task != '' {
		res << vproto.pack_string_field(o.launch_task, 7)
	}
	if o.launch_task_detail != '' {
		res << vproto.pack_string_field(o.launch_task_detail, 8)
	}
	if o.launch_tasks_done != int(0) {
		res << vproto.pack_int32_field(o.launch_tasks_done, 9)
	}
	if o.launch_tasks_total != int(0) {
		res << vproto.pack_int32_field(o.launch_tasks_total, 10)
	}
	return res
}

pub fn cmsgremoteclientstartstreamresponse_unpack(buf []byte) ?CMsgRemoteClientStartStreamResponse {
	mut res := zzz_vproto_internal_new_cmsgremoteclientstartstreamresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.e_launch_result = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.stream_port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
				res.launch_options << v
				i = ii
			}
			4 {
				i, res.auth_token = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.transport = zzz_vproto_internal_unpack_estreamtransport(cur_buf,
					tag_wiretype.wire_type) ?
			}
			6 {
				i, res.relay_server = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.launch_task = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.launch_task_detail = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.launch_tasks_done = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.launch_tasks_total = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientStartStreamResponse) eq(b CMsgRemoteClientStartStreamResponse) bool {
	return true && a.e_launch_result == b.e_launch_result && a.stream_port == b.stream_port &&
		a.launch_options == b.launch_options && a.auth_token == b.auth_token && a.transport == b.transport &&
		a.relay_server == b.relay_server && a.launch_task == b.launch_task && a.launch_task_detail ==
		b.launch_task_detail && a.launch_tasks_done == b.launch_tasks_done && a.launch_tasks_total ==
		b.launch_tasks_total
}

[inline]
pub fn (a CMsgRemoteClientStartStreamResponse) ne(b CMsgRemoteClientStartStreamResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientStartStreamResponse) eq(b []CMsgRemoteClientStartStreamResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientStartStreamResponse) ne(b []CMsgRemoteClientStartStreamResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientstartstreamresponse() CMsgRemoteClientStartStreamResponse {
	return CMsgRemoteClientStartStreamResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientstartstreamresponse(o CMsgRemoteClientStartStreamResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientstartstreamresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientStartStreamResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientstartstreamresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientPing {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgRemoteClientPing) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgremoteclientping_unpack(buf []byte) ?CMsgRemoteClientPing {
	res := zzz_vproto_internal_new_cmsgremoteclientping()
	return res
}

[inline]
pub fn (a CMsgRemoteClientPing) eq(b CMsgRemoteClientPing) bool {
	return true
}

[inline]
pub fn (a CMsgRemoteClientPing) ne(b CMsgRemoteClientPing) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientPing) eq(b []CMsgRemoteClientPing) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientPing) ne(b []CMsgRemoteClientPing) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientping() CMsgRemoteClientPing {
	return CMsgRemoteClientPing{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientping(o CMsgRemoteClientPing, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientping(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientPing) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientping_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientPingResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgRemoteClientPingResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgremoteclientpingresponse_unpack(buf []byte) ?CMsgRemoteClientPingResponse {
	res := zzz_vproto_internal_new_cmsgremoteclientpingresponse()
	return res
}

[inline]
pub fn (a CMsgRemoteClientPingResponse) eq(b CMsgRemoteClientPingResponse) bool {
	return true
}

[inline]
pub fn (a CMsgRemoteClientPingResponse) ne(b CMsgRemoteClientPingResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientPingResponse) eq(b []CMsgRemoteClientPingResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientPingResponse) ne(b []CMsgRemoteClientPingResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientpingresponse() CMsgRemoteClientPingResponse {
	return CMsgRemoteClientPingResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientpingresponse(o CMsgRemoteClientPingResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientpingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientPingResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientpingresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientAcceptEULA {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         []u32
}

pub fn (o &CMsgRemoteClientAcceptEULA) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.app_id {
		res << vproto.pack_uint32_field(x, 1)
	}
	return res
}

pub fn cmsgremoteclientaccepteula_unpack(buf []byte) ?CMsgRemoteClientAcceptEULA {
	mut res := zzz_vproto_internal_new_cmsgremoteclientaccepteula()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.app_id << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientAcceptEULA) eq(b CMsgRemoteClientAcceptEULA) bool {
	return true && a.app_id == b.app_id
}

[inline]
pub fn (a CMsgRemoteClientAcceptEULA) ne(b CMsgRemoteClientAcceptEULA) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientAcceptEULA) eq(b []CMsgRemoteClientAcceptEULA) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientAcceptEULA) ne(b []CMsgRemoteClientAcceptEULA) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientaccepteula() CMsgRemoteClientAcceptEULA {
	return CMsgRemoteClientAcceptEULA{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientaccepteula(o CMsgRemoteClientAcceptEULA, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientaccepteula(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientAcceptEULA) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientaccepteula_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientGetControllerConfig {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	app_id           u32
	controller_index u32
}

pub fn (o &CMsgRemoteClientGetControllerConfig) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.controller_index != u32(0) {
		res << vproto.pack_uint32_field(o.controller_index, 3)
	}
	return res
}

pub fn cmsgremoteclientgetcontrollerconfig_unpack(buf []byte) ?CMsgRemoteClientGetControllerConfig {
	mut res := zzz_vproto_internal_new_cmsgremoteclientgetcontrollerconfig()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.controller_index = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientGetControllerConfig) eq(b CMsgRemoteClientGetControllerConfig) bool {
	return true && a.app_id == b.app_id && a.controller_index == b.controller_index
}

[inline]
pub fn (a CMsgRemoteClientGetControllerConfig) ne(b CMsgRemoteClientGetControllerConfig) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientGetControllerConfig) eq(b []CMsgRemoteClientGetControllerConfig) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientGetControllerConfig) ne(b []CMsgRemoteClientGetControllerConfig) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientgetcontrollerconfig() CMsgRemoteClientGetControllerConfig {
	return CMsgRemoteClientGetControllerConfig{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientgetcontrollerconfig(o CMsgRemoteClientGetControllerConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientgetcontrollerconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientGetControllerConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientgetcontrollerconfig_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientGetControllerConfigResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	config_vdf     []byte
}

pub fn (o &CMsgRemoteClientGetControllerConfigResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.config_vdf != []byte{} {
		res << vproto.pack_bytes_field(o.config_vdf, 2)
	}
	return res
}

pub fn cmsgremoteclientgetcontrollerconfigresponse_unpack(buf []byte) ?CMsgRemoteClientGetControllerConfigResponse {
	mut res := zzz_vproto_internal_new_cmsgremoteclientgetcontrollerconfigresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.config_vdf = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientGetControllerConfigResponse) eq(b CMsgRemoteClientGetControllerConfigResponse) bool {
	return true && a.eresult == b.eresult && a.config_vdf == b.config_vdf
}

[inline]
pub fn (a CMsgRemoteClientGetControllerConfigResponse) ne(b CMsgRemoteClientGetControllerConfigResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientGetControllerConfigResponse) eq(b []CMsgRemoteClientGetControllerConfigResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientGetControllerConfigResponse) ne(b []CMsgRemoteClientGetControllerConfigResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientgetcontrollerconfigresponse() CMsgRemoteClientGetControllerConfigResponse {
	return CMsgRemoteClientGetControllerConfigResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientgetcontrollerconfigresponse(o CMsgRemoteClientGetControllerConfigResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientgetcontrollerconfigresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientGetControllerConfigResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientgetcontrollerconfigresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgRemoteClientStreamingEnabled {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	enabled        bool
}

pub fn (o &CMsgRemoteClientStreamingEnabled) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_bool_field(o.enabled, 1)
	return res
}

pub fn cmsgremoteclientstreamingenabled_unpack(buf []byte) ?CMsgRemoteClientStreamingEnabled {
	mut res := zzz_vproto_internal_new_cmsgremoteclientstreamingenabled()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.enabled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRemoteClientStreamingEnabled) eq(b CMsgRemoteClientStreamingEnabled) bool {
	return true && a.enabled == b.enabled
}

[inline]
pub fn (a CMsgRemoteClientStreamingEnabled) ne(b CMsgRemoteClientStreamingEnabled) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRemoteClientStreamingEnabled) eq(b []CMsgRemoteClientStreamingEnabled) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRemoteClientStreamingEnabled) ne(b []CMsgRemoteClientStreamingEnabled) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgremoteclientstreamingenabled() CMsgRemoteClientStreamingEnabled {
	return CMsgRemoteClientStreamingEnabled{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgremoteclientstreamingenabled(o CMsgRemoteClientStreamingEnabled, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgremoteclientstreamingenabled(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientStreamingEnabled) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgremoteclientstreamingenabled_unpack(v) ?
	return i, unpacked
}
