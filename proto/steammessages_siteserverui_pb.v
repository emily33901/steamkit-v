// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct SiteServerUI_Login_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	username          string
	password          string
	steamguardcode    string
	remember_password bool
}

pub fn (o &SiteServerUI_Login_Request) pack() []byte {
	mut res := []byte{}
	if o.username != '' {
		res << vproto.pack_string_field(o.username, 1)
	}
	if o.password != '' {
		res << vproto.pack_string_field(o.password, 2)
	}
	if o.steamguardcode != '' {
		res << vproto.pack_string_field(o.steamguardcode, 3)
	}
	if o.remember_password != false {
		res << vproto.pack_bool_field(o.remember_password, 4)
	}
	return res
}

pub fn siteserverui_login_request_unpack(buf []byte) ?SiteServerUI_Login_Request {
	mut res := zzz_vproto_internal_new_siteserverui_login_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.username = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.password = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.steamguardcode = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.remember_password = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_Login_Request) eq(b SiteServerUI_Login_Request) bool {
	return true && a.username == b.username && a.password == b.password && a.steamguardcode ==
		b.steamguardcode && a.remember_password == b.remember_password
}

[inline]
pub fn (a SiteServerUI_Login_Request) ne(b SiteServerUI_Login_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_Login_Request) eq(b []SiteServerUI_Login_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_Login_Request) ne(b []SiteServerUI_Login_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_login_request() SiteServerUI_Login_Request {
	return SiteServerUI_Login_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_login_request(o SiteServerUI_Login_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_login_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Login_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_login_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_Login_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	logon_state    int
	logon_eresult  int
}

pub fn (o &SiteServerUI_Login_Response) pack() []byte {
	mut res := []byte{}
	if o.logon_state != int(0) {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.logon_eresult != int(0) {
		res << vproto.pack_int32_field(o.logon_eresult, 2)
	}
	return res
}

pub fn siteserverui_login_response_unpack(buf []byte) ?SiteServerUI_Login_Response {
	mut res := zzz_vproto_internal_new_siteserverui_login_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.logon_state = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.logon_eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_Login_Response) eq(b SiteServerUI_Login_Response) bool {
	return true && a.logon_state == b.logon_state && a.logon_eresult == b.logon_eresult
}

[inline]
pub fn (a SiteServerUI_Login_Response) ne(b SiteServerUI_Login_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_Login_Response) eq(b []SiteServerUI_Login_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_Login_Response) ne(b []SiteServerUI_Login_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_login_response() SiteServerUI_Login_Response {
	return SiteServerUI_Login_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_login_response(o SiteServerUI_Login_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_login_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Login_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_login_response_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_LoginStatus_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_LoginStatus_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_loginstatus_request_unpack(buf []byte) ?SiteServerUI_LoginStatus_Request {
	res := zzz_vproto_internal_new_siteserverui_loginstatus_request()
	return res
}

[inline]
pub fn (a SiteServerUI_LoginStatus_Request) eq(b SiteServerUI_LoginStatus_Request) bool {
	return true
}

[inline]
pub fn (a SiteServerUI_LoginStatus_Request) ne(b SiteServerUI_LoginStatus_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_LoginStatus_Request) eq(b []SiteServerUI_LoginStatus_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_LoginStatus_Request) ne(b []SiteServerUI_LoginStatus_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_loginstatus_request() SiteServerUI_LoginStatus_Request {
	return SiteServerUI_LoginStatus_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_loginstatus_request(o SiteServerUI_LoginStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_loginstatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_LoginStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_loginstatus_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_LoginStatus_Response {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	username           string
	cached_credentials bool
	logon_state        int
	logon_eresult      int
}

pub fn (o &SiteServerUI_LoginStatus_Response) pack() []byte {
	mut res := []byte{}
	if o.username != '' {
		res << vproto.pack_string_field(o.username, 1)
	}
	if o.cached_credentials != false {
		res << vproto.pack_bool_field(o.cached_credentials, 2)
	}
	if o.logon_state != int(0) {
		res << vproto.pack_int32_field(o.logon_state, 3)
	}
	if o.logon_eresult != int(0) {
		res << vproto.pack_int32_field(o.logon_eresult, 4)
	}
	return res
}

pub fn siteserverui_loginstatus_response_unpack(buf []byte) ?SiteServerUI_LoginStatus_Response {
	mut res := zzz_vproto_internal_new_siteserverui_loginstatus_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.username = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.cached_credentials = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.logon_state = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.logon_eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_LoginStatus_Response) eq(b SiteServerUI_LoginStatus_Response) bool {
	return true && a.username == b.username && a.cached_credentials == b.cached_credentials &&
		a.logon_state == b.logon_state && a.logon_eresult == b.logon_eresult
}

[inline]
pub fn (a SiteServerUI_LoginStatus_Response) ne(b SiteServerUI_LoginStatus_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_LoginStatus_Response) eq(b []SiteServerUI_LoginStatus_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_LoginStatus_Response) ne(b []SiteServerUI_LoginStatus_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_loginstatus_response() SiteServerUI_LoginStatus_Response {
	return SiteServerUI_LoginStatus_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_loginstatus_response(o SiteServerUI_LoginStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_loginstatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_LoginStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_loginstatus_response_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_CancelLogin_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_CancelLogin_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_cancellogin_request_unpack(buf []byte) ?SiteServerUI_CancelLogin_Request {
	res := zzz_vproto_internal_new_siteserverui_cancellogin_request()
	return res
}

[inline]
pub fn (a SiteServerUI_CancelLogin_Request) eq(b SiteServerUI_CancelLogin_Request) bool {
	return true
}

[inline]
pub fn (a SiteServerUI_CancelLogin_Request) ne(b SiteServerUI_CancelLogin_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_CancelLogin_Request) eq(b []SiteServerUI_CancelLogin_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_CancelLogin_Request) ne(b []SiteServerUI_CancelLogin_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_cancellogin_request() SiteServerUI_CancelLogin_Request {
	return SiteServerUI_CancelLogin_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_cancellogin_request(o SiteServerUI_CancelLogin_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_cancellogin_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_CancelLogin_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_cancellogin_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_CancelLogin_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	logon_state    int
	logon_eresult  int
}

pub fn (o &SiteServerUI_CancelLogin_Response) pack() []byte {
	mut res := []byte{}
	if o.logon_state != int(0) {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.logon_eresult != int(0) {
		res << vproto.pack_int32_field(o.logon_eresult, 2)
	}
	return res
}

pub fn siteserverui_cancellogin_response_unpack(buf []byte) ?SiteServerUI_CancelLogin_Response {
	mut res := zzz_vproto_internal_new_siteserverui_cancellogin_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.logon_state = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.logon_eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_CancelLogin_Response) eq(b SiteServerUI_CancelLogin_Response) bool {
	return true && a.logon_state == b.logon_state && a.logon_eresult == b.logon_eresult
}

[inline]
pub fn (a SiteServerUI_CancelLogin_Response) ne(b SiteServerUI_CancelLogin_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_CancelLogin_Response) eq(b []SiteServerUI_CancelLogin_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_CancelLogin_Response) ne(b []SiteServerUI_CancelLogin_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_cancellogin_response() SiteServerUI_CancelLogin_Response {
	return SiteServerUI_CancelLogin_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_cancellogin_response(o SiteServerUI_CancelLogin_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_cancellogin_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_CancelLogin_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_cancellogin_response_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_Logout_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_Logout_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_logout_request_unpack(buf []byte) ?SiteServerUI_Logout_Request {
	res := zzz_vproto_internal_new_siteserverui_logout_request()
	return res
}

[inline]
pub fn (a SiteServerUI_Logout_Request) eq(b SiteServerUI_Logout_Request) bool {
	return true
}

[inline]
pub fn (a SiteServerUI_Logout_Request) ne(b SiteServerUI_Logout_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_Logout_Request) eq(b []SiteServerUI_Logout_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_Logout_Request) ne(b []SiteServerUI_Logout_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_logout_request() SiteServerUI_Logout_Request {
	return SiteServerUI_Logout_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_logout_request(o SiteServerUI_Logout_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_logout_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Logout_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_logout_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_Logout_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	logon_state    int
	logout_eresult int
}

pub fn (o &SiteServerUI_Logout_Response) pack() []byte {
	mut res := []byte{}
	if o.logon_state != int(0) {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.logout_eresult != int(0) {
		res << vproto.pack_int32_field(o.logout_eresult, 2)
	}
	return res
}

pub fn siteserverui_logout_response_unpack(buf []byte) ?SiteServerUI_Logout_Response {
	mut res := zzz_vproto_internal_new_siteserverui_logout_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.logon_state = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.logout_eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_Logout_Response) eq(b SiteServerUI_Logout_Response) bool {
	return true && a.logon_state == b.logon_state && a.logout_eresult == b.logout_eresult
}

[inline]
pub fn (a SiteServerUI_Logout_Response) ne(b SiteServerUI_Logout_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_Logout_Response) eq(b []SiteServerUI_Logout_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_Logout_Response) ne(b []SiteServerUI_Logout_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_logout_response() SiteServerUI_Logout_Response {
	return SiteServerUI_Logout_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_logout_response(o SiteServerUI_Logout_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_logout_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Logout_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_logout_response_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_Quit_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	restart        bool
}

pub fn (o &SiteServerUI_Quit_Request) pack() []byte {
	mut res := []byte{}
	if o.restart != false {
		res << vproto.pack_bool_field(o.restart, 1)
	}
	return res
}

pub fn siteserverui_quit_request_unpack(buf []byte) ?SiteServerUI_Quit_Request {
	mut res := zzz_vproto_internal_new_siteserverui_quit_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.restart = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_Quit_Request) eq(b SiteServerUI_Quit_Request) bool {
	return true && a.restart == b.restart
}

[inline]
pub fn (a SiteServerUI_Quit_Request) ne(b SiteServerUI_Quit_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_Quit_Request) eq(b []SiteServerUI_Quit_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_Quit_Request) ne(b []SiteServerUI_Quit_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_quit_request() SiteServerUI_Quit_Request {
	return SiteServerUI_Quit_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_quit_request(o SiteServerUI_Quit_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_quit_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Quit_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_quit_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_Quit_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_Quit_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_quit_response_unpack(buf []byte) ?SiteServerUI_Quit_Response {
	res := zzz_vproto_internal_new_siteserverui_quit_response()
	return res
}

[inline]
pub fn (a SiteServerUI_Quit_Response) eq(b SiteServerUI_Quit_Response) bool {
	return true
}

[inline]
pub fn (a SiteServerUI_Quit_Response) ne(b SiteServerUI_Quit_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_Quit_Response) eq(b []SiteServerUI_Quit_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_Quit_Response) ne(b []SiteServerUI_Quit_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_quit_response() SiteServerUI_Quit_Response {
	return SiteServerUI_Quit_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_quit_response(o SiteServerUI_Quit_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_quit_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Quit_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_quit_response_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_Status_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_Status_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_status_request_unpack(buf []byte) ?SiteServerUI_Status_Request {
	res := zzz_vproto_internal_new_siteserverui_status_request()
	return res
}

[inline]
pub fn (a SiteServerUI_Status_Request) eq(b SiteServerUI_Status_Request) bool {
	return true
}

[inline]
pub fn (a SiteServerUI_Status_Request) ne(b SiteServerUI_Status_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_Status_Request) eq(b []SiteServerUI_Status_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_Status_Request) ne(b []SiteServerUI_Status_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_status_request() SiteServerUI_Status_Request {
	return SiteServerUI_Status_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_status_request(o SiteServerUI_Status_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_status_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Status_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_status_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_Status_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	logon_state    int
	logon_eresult  int
	connected      bool
	cache_enabled  bool
	acct_status    int
}

pub fn (o &SiteServerUI_Status_Response) pack() []byte {
	mut res := []byte{}
	if o.logon_state != int(0) {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.logon_eresult != int(0) {
		res << vproto.pack_int32_field(o.logon_eresult, 2)
	}
	if o.connected != false {
		res << vproto.pack_bool_field(o.connected, 3)
	}
	if o.cache_enabled != false {
		res << vproto.pack_bool_field(o.cache_enabled, 4)
	}
	if o.acct_status != int(0) {
		res << vproto.pack_int32_field(o.acct_status, 5)
	}
	return res
}

pub fn siteserverui_status_response_unpack(buf []byte) ?SiteServerUI_Status_Response {
	mut res := zzz_vproto_internal_new_siteserverui_status_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.logon_state = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.logon_eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.connected = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.cache_enabled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.acct_status = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_Status_Response) eq(b SiteServerUI_Status_Response) bool {
	return true && a.logon_state == b.logon_state && a.logon_eresult == b.logon_eresult &&
		a.connected == b.connected && a.cache_enabled == b.cache_enabled && a.acct_status == b.acct_status
}

[inline]
pub fn (a SiteServerUI_Status_Response) ne(b SiteServerUI_Status_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_Status_Response) eq(b []SiteServerUI_Status_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_Status_Response) ne(b []SiteServerUI_Status_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_status_response() SiteServerUI_Status_Response {
	return SiteServerUI_Status_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_status_response(o SiteServerUI_Status_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_status_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Status_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_status_response_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_GetLanguage_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_GetLanguage_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_getlanguage_request_unpack(buf []byte) ?SiteServerUI_GetLanguage_Request {
	res := zzz_vproto_internal_new_siteserverui_getlanguage_request()
	return res
}

[inline]
pub fn (a SiteServerUI_GetLanguage_Request) eq(b SiteServerUI_GetLanguage_Request) bool {
	return true
}

[inline]
pub fn (a SiteServerUI_GetLanguage_Request) ne(b SiteServerUI_GetLanguage_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_GetLanguage_Request) eq(b []SiteServerUI_GetLanguage_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_GetLanguage_Request) ne(b []SiteServerUI_GetLanguage_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_getlanguage_request() SiteServerUI_GetLanguage_Request {
	return SiteServerUI_GetLanguage_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_getlanguage_request(o SiteServerUI_GetLanguage_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_getlanguage_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_GetLanguage_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_getlanguage_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_GetLanguage_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
}

pub fn (o &SiteServerUI_GetLanguage_Response) pack() []byte {
	mut res := []byte{}
	if o.language != '' {
		res << vproto.pack_string_field(o.language, 1)
	}
	return res
}

pub fn siteserverui_getlanguage_response_unpack(buf []byte) ?SiteServerUI_GetLanguage_Response {
	mut res := zzz_vproto_internal_new_siteserverui_getlanguage_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.language = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_GetLanguage_Response) eq(b SiteServerUI_GetLanguage_Response) bool {
	return true && a.language == b.language
}

[inline]
pub fn (a SiteServerUI_GetLanguage_Response) ne(b SiteServerUI_GetLanguage_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_GetLanguage_Response) eq(b []SiteServerUI_GetLanguage_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_GetLanguage_Response) ne(b []SiteServerUI_GetLanguage_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_getlanguage_response() SiteServerUI_GetLanguage_Response {
	return SiteServerUI_GetLanguage_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_getlanguage_response(o SiteServerUI_GetLanguage_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_getlanguage_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_GetLanguage_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_getlanguage_response_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_SetLanguage_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
}

pub fn (o &SiteServerUI_SetLanguage_Request) pack() []byte {
	mut res := []byte{}
	if o.language != '' {
		res << vproto.pack_string_field(o.language, 1)
	}
	return res
}

pub fn siteserverui_setlanguage_request_unpack(buf []byte) ?SiteServerUI_SetLanguage_Request {
	mut res := zzz_vproto_internal_new_siteserverui_setlanguage_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.language = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_SetLanguage_Request) eq(b SiteServerUI_SetLanguage_Request) bool {
	return true && a.language == b.language
}

[inline]
pub fn (a SiteServerUI_SetLanguage_Request) ne(b SiteServerUI_SetLanguage_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_SetLanguage_Request) eq(b []SiteServerUI_SetLanguage_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_SetLanguage_Request) ne(b []SiteServerUI_SetLanguage_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_setlanguage_request() SiteServerUI_SetLanguage_Request {
	return SiteServerUI_SetLanguage_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_setlanguage_request(o SiteServerUI_SetLanguage_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_setlanguage_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_SetLanguage_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_setlanguage_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_SetLanguage_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_SetLanguage_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_setlanguage_response_unpack(buf []byte) ?SiteServerUI_SetLanguage_Response {
	res := zzz_vproto_internal_new_siteserverui_setlanguage_response()
	return res
}

[inline]
pub fn (a SiteServerUI_SetLanguage_Response) eq(b SiteServerUI_SetLanguage_Response) bool {
	return true
}

[inline]
pub fn (a SiteServerUI_SetLanguage_Response) ne(b SiteServerUI_SetLanguage_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_SetLanguage_Response) eq(b []SiteServerUI_SetLanguage_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_SetLanguage_Response) ne(b []SiteServerUI_SetLanguage_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_setlanguage_response() SiteServerUI_SetLanguage_Response {
	return SiteServerUI_SetLanguage_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_setlanguage_response(o SiteServerUI_SetLanguage_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_setlanguage_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_SetLanguage_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_setlanguage_response_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_ClientStatus_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_ClientStatus_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_clientstatus_request_unpack(buf []byte) ?SiteServerUI_ClientStatus_Request {
	res := zzz_vproto_internal_new_siteserverui_clientstatus_request()
	return res
}

[inline]
pub fn (a SiteServerUI_ClientStatus_Request) eq(b SiteServerUI_ClientStatus_Request) bool {
	return true
}

[inline]
pub fn (a SiteServerUI_ClientStatus_Request) ne(b SiteServerUI_ClientStatus_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_ClientStatus_Request) eq(b []SiteServerUI_ClientStatus_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_ClientStatus_Request) ne(b []SiteServerUI_ClientStatus_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_clientstatus_request() SiteServerUI_ClientStatus_Request {
	return SiteServerUI_ClientStatus_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_clientstatus_request(o SiteServerUI_ClientStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_clientstatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ClientStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_clientstatus_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_ClientStatus_Response_ClientInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ip             u32
	hostname       string
	connected      bool
	instance_id    u64
}

pub fn (o &SiteServerUI_ClientStatus_Response_ClientInfo) pack() []byte {
	mut res := []byte{}
	if o.ip != u32(0) {
		res << vproto.pack_uint32_field(o.ip, 1)
	}
	if o.hostname != '' {
		res << vproto.pack_string_field(o.hostname, 2)
	}
	if o.connected != false {
		res << vproto.pack_bool_field(o.connected, 3)
	}
	if o.instance_id != u64(0) {
		res << vproto.pack_uint64_field(o.instance_id, 4)
	}
	return res
}

pub fn siteserverui_clientstatus_response_clientinfo_unpack(buf []byte) ?SiteServerUI_ClientStatus_Response_ClientInfo {
	mut res := zzz_vproto_internal_new_siteserverui_clientstatus_response_clientinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.ip = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.hostname = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.connected = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.instance_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_ClientStatus_Response_ClientInfo) eq(b SiteServerUI_ClientStatus_Response_ClientInfo) bool {
	return true && a.ip == b.ip && a.hostname == b.hostname && a.connected == b.connected &&
		a.instance_id == b.instance_id
}

[inline]
pub fn (a SiteServerUI_ClientStatus_Response_ClientInfo) ne(b SiteServerUI_ClientStatus_Response_ClientInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_ClientStatus_Response_ClientInfo) eq(b []SiteServerUI_ClientStatus_Response_ClientInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_ClientStatus_Response_ClientInfo) ne(b []SiteServerUI_ClientStatus_Response_ClientInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_clientstatus_response_clientinfo() SiteServerUI_ClientStatus_Response_ClientInfo {
	return SiteServerUI_ClientStatus_Response_ClientInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_clientstatus_response_clientinfo(o SiteServerUI_ClientStatus_Response_ClientInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_clientstatus_response_clientinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ClientStatus_Response_ClientInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_clientstatus_response_clientinfo_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_ClientStatus_Response_Payment {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	transid         u64
	steamid         u64
	amount          string
	time_created    int
	purchase_status int
	hostname        string
	persona_name    string
	profile_url     string
	avatar_url      string
}

pub fn (o &SiteServerUI_ClientStatus_Response_Payment) pack() []byte {
	mut res := []byte{}
	if o.transid != u64(0) {
		res << vproto.pack_uint64_field(o.transid, 1)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	if o.amount != '' {
		res << vproto.pack_string_field(o.amount, 3)
	}
	if o.time_created != int(0) {
		res << vproto.pack_int32_field(o.time_created, 4)
	}
	if o.purchase_status != int(0) {
		res << vproto.pack_int32_field(o.purchase_status, 5)
	}
	if o.hostname != '' {
		res << vproto.pack_string_field(o.hostname, 6)
	}
	if o.persona_name != '' {
		res << vproto.pack_string_field(o.persona_name, 7)
	}
	if o.profile_url != '' {
		res << vproto.pack_string_field(o.profile_url, 8)
	}
	if o.avatar_url != '' {
		res << vproto.pack_string_field(o.avatar_url, 9)
	}
	return res
}

pub fn siteserverui_clientstatus_response_payment_unpack(buf []byte) ?SiteServerUI_ClientStatus_Response_Payment {
	mut res := zzz_vproto_internal_new_siteserverui_clientstatus_response_payment()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.transid = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steamid = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.amount = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.time_created = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.purchase_status = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.hostname = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.persona_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.profile_url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.avatar_url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_ClientStatus_Response_Payment) eq(b SiteServerUI_ClientStatus_Response_Payment) bool {
	return true && a.transid == b.transid && a.steamid == b.steamid && a.amount == b.amount &&
		a.time_created == b.time_created && a.purchase_status == b.purchase_status && a.hostname == b.hostname &&
		a.persona_name == b.persona_name && a.profile_url == b.profile_url && a.avatar_url == b.avatar_url
}

[inline]
pub fn (a SiteServerUI_ClientStatus_Response_Payment) ne(b SiteServerUI_ClientStatus_Response_Payment) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_ClientStatus_Response_Payment) eq(b []SiteServerUI_ClientStatus_Response_Payment) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_ClientStatus_Response_Payment) ne(b []SiteServerUI_ClientStatus_Response_Payment) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_clientstatus_response_payment() SiteServerUI_ClientStatus_Response_Payment {
	return SiteServerUI_ClientStatus_Response_Payment{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_clientstatus_response_payment(o SiteServerUI_ClientStatus_Response_Payment, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_clientstatus_response_payment(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ClientStatus_Response_Payment) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_clientstatus_response_payment_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_ClientStatus_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	clients        []SiteServerUI_ClientStatus_Response_ClientInfo
	payments       []SiteServerUI_ClientStatus_Response_Payment
}

pub fn (o &SiteServerUI_ClientStatus_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.clients {
		res <<
			zzz_vproto_internal_pack_siteserverui_clientstatus_response_clientinfo(x, 4)
	}
	// [packed=false]
	for _, x in o.payments {
		res <<
			zzz_vproto_internal_pack_siteserverui_clientstatus_response_payment(x, 5)
	}
	return res
}

pub fn siteserverui_clientstatus_response_unpack(buf []byte) ?SiteServerUI_ClientStatus_Response {
	mut res := zzz_vproto_internal_new_siteserverui_clientstatus_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_siteserverui_clientstatus_response_clientinfo(cur_buf,
					tag_wiretype.wire_type) ?
				res.clients << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_siteserverui_clientstatus_response_payment(cur_buf,
					tag_wiretype.wire_type) ?
				res.payments << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_ClientStatus_Response) eq(b SiteServerUI_ClientStatus_Response) bool {
	return true && a.clients.eq(b.clients) && a.payments.eq(b.payments)
}

[inline]
pub fn (a SiteServerUI_ClientStatus_Response) ne(b SiteServerUI_ClientStatus_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_ClientStatus_Response) eq(b []SiteServerUI_ClientStatus_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_ClientStatus_Response) ne(b []SiteServerUI_ClientStatus_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_clientstatus_response() SiteServerUI_ClientStatus_Response {
	return SiteServerUI_ClientStatus_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_clientstatus_response(o SiteServerUI_ClientStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_clientstatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ClientStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_clientstatus_response_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_ContentCacheStatus_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_ContentCacheStatus_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_contentcachestatus_request_unpack(buf []byte) ?SiteServerUI_ContentCacheStatus_Request {
	res := zzz_vproto_internal_new_siteserverui_contentcachestatus_request()
	return res
}

[inline]
pub fn (a SiteServerUI_ContentCacheStatus_Request) eq(b SiteServerUI_ContentCacheStatus_Request) bool {
	return true
}

[inline]
pub fn (a SiteServerUI_ContentCacheStatus_Request) ne(b SiteServerUI_ContentCacheStatus_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_ContentCacheStatus_Request) eq(b []SiteServerUI_ContentCacheStatus_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_ContentCacheStatus_Request) ne(b []SiteServerUI_ContentCacheStatus_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_contentcachestatus_request() SiteServerUI_ContentCacheStatus_Request {
	return SiteServerUI_ContentCacheStatus_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_contentcachestatus_request(o SiteServerUI_ContentCacheStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_contentcachestatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ContentCacheStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_contentcachestatus_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_ContentCacheStatus_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	enabled             bool
	port                u32
	cache_location      string
	max_size_gb         u32
	p2p_enabled         bool
	explicit_ip_address string
	external_process    bool
	current_size_gb     u32
	current_bw          u64
	total_bytes_served  u64
}

pub fn (o &SiteServerUI_ContentCacheStatus_Response) pack() []byte {
	mut res := []byte{}
	if o.enabled != false {
		res << vproto.pack_bool_field(o.enabled, 1)
	}
	if o.port != u32(0) {
		res << vproto.pack_uint32_field(o.port, 2)
	}
	if o.cache_location != '' {
		res << vproto.pack_string_field(o.cache_location, 3)
	}
	if o.max_size_gb != u32(0) {
		res << vproto.pack_uint32_field(o.max_size_gb, 4)
	}
	if o.p2p_enabled != false {
		res << vproto.pack_bool_field(o.p2p_enabled, 5)
	}
	if o.explicit_ip_address != '' {
		res << vproto.pack_string_field(o.explicit_ip_address, 9)
	}
	if o.external_process != false {
		res << vproto.pack_bool_field(o.external_process, 10)
	}
	if o.current_size_gb != u32(0) {
		res << vproto.pack_uint32_field(o.current_size_gb, 6)
	}
	if o.current_bw != u64(0) {
		res << vproto.pack_uint64_field(o.current_bw, 7)
	}
	if o.total_bytes_served != u64(0) {
		res << vproto.pack_uint64_field(o.total_bytes_served, 8)
	}
	return res
}

pub fn siteserverui_contentcachestatus_response_unpack(buf []byte) ?SiteServerUI_ContentCacheStatus_Response {
	mut res := zzz_vproto_internal_new_siteserverui_contentcachestatus_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.enabled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.cache_location = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.max_size_gb = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.p2p_enabled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.explicit_ip_address = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.external_process = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.current_size_gb = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.current_bw = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.total_bytes_served = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_ContentCacheStatus_Response) eq(b SiteServerUI_ContentCacheStatus_Response) bool {
	return true && a.enabled == b.enabled && a.port == b.port && a.cache_location == b.cache_location &&
		a.max_size_gb == b.max_size_gb && a.p2p_enabled == b.p2p_enabled && a.explicit_ip_address == b.explicit_ip_address &&
		a.external_process == b.external_process && a.current_size_gb == b.current_size_gb &&
		a.current_bw == b.current_bw && a.total_bytes_served == b.total_bytes_served
}

[inline]
pub fn (a SiteServerUI_ContentCacheStatus_Response) ne(b SiteServerUI_ContentCacheStatus_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_ContentCacheStatus_Response) eq(b []SiteServerUI_ContentCacheStatus_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_ContentCacheStatus_Response) ne(b []SiteServerUI_ContentCacheStatus_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_contentcachestatus_response() SiteServerUI_ContentCacheStatus_Response {
	return SiteServerUI_ContentCacheStatus_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_contentcachestatus_response(o SiteServerUI_ContentCacheStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_contentcachestatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ContentCacheStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_contentcachestatus_response_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_ContentCacheConfig_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	enabled             bool
	port                u32
	cache_location      string
	max_size_gb         u32
	p2p_enabled         bool
	external_process    bool
	explicit_ip_address string
}

pub fn (o &SiteServerUI_ContentCacheConfig_Request) pack() []byte {
	mut res := []byte{}
	if o.enabled != false {
		res << vproto.pack_bool_field(o.enabled, 1)
	}
	if o.port != u32(0) {
		res << vproto.pack_uint32_field(o.port, 2)
	}
	if o.cache_location != '' {
		res << vproto.pack_string_field(o.cache_location, 3)
	}
	if o.max_size_gb != u32(0) {
		res << vproto.pack_uint32_field(o.max_size_gb, 4)
	}
	if o.p2p_enabled != false {
		res << vproto.pack_bool_field(o.p2p_enabled, 5)
	}
	if o.external_process != false {
		res << vproto.pack_bool_field(o.external_process, 6)
	}
	if o.explicit_ip_address != '' {
		res << vproto.pack_string_field(o.explicit_ip_address, 7)
	}
	return res
}

pub fn siteserverui_contentcacheconfig_request_unpack(buf []byte) ?SiteServerUI_ContentCacheConfig_Request {
	mut res := zzz_vproto_internal_new_siteserverui_contentcacheconfig_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.enabled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.cache_location = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.max_size_gb = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.p2p_enabled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.external_process = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.explicit_ip_address = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a SiteServerUI_ContentCacheConfig_Request) eq(b SiteServerUI_ContentCacheConfig_Request) bool {
	return true && a.enabled == b.enabled && a.port == b.port && a.cache_location == b.cache_location &&
		a.max_size_gb == b.max_size_gb && a.p2p_enabled == b.p2p_enabled && a.external_process == b.external_process &&
		a.explicit_ip_address == b.explicit_ip_address
}

[inline]
pub fn (a SiteServerUI_ContentCacheConfig_Request) ne(b SiteServerUI_ContentCacheConfig_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_ContentCacheConfig_Request) eq(b []SiteServerUI_ContentCacheConfig_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_ContentCacheConfig_Request) ne(b []SiteServerUI_ContentCacheConfig_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_contentcacheconfig_request() SiteServerUI_ContentCacheConfig_Request {
	return SiteServerUI_ContentCacheConfig_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_contentcacheconfig_request(o SiteServerUI_ContentCacheConfig_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_contentcacheconfig_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ContentCacheConfig_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_contentcacheconfig_request_unpack(v) ?
	return i, unpacked
}

pub struct SiteServerUI_ContentCacheConfig_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_ContentCacheConfig_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_contentcacheconfig_response_unpack(buf []byte) ?SiteServerUI_ContentCacheConfig_Response {
	res := zzz_vproto_internal_new_siteserverui_contentcacheconfig_response()
	return res
}

[inline]
pub fn (a SiteServerUI_ContentCacheConfig_Response) eq(b SiteServerUI_ContentCacheConfig_Response) bool {
	return true
}

[inline]
pub fn (a SiteServerUI_ContentCacheConfig_Response) ne(b SiteServerUI_ContentCacheConfig_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []SiteServerUI_ContentCacheConfig_Response) eq(b []SiteServerUI_ContentCacheConfig_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []SiteServerUI_ContentCacheConfig_Response) ne(b []SiteServerUI_ContentCacheConfig_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_siteserverui_contentcacheconfig_response() SiteServerUI_ContentCacheConfig_Response {
	return SiteServerUI_ContentCacheConfig_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_siteserverui_contentcacheconfig_response(o SiteServerUI_ContentCacheConfig_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_siteserverui_contentcacheconfig_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ContentCacheConfig_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := siteserverui_contentcacheconfig_response_unpack(v) ?
	return i, unpacked
}
