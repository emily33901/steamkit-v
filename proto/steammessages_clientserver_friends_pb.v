// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CMsgClientFriendMsg {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	steamid                  u64
	chat_entry_type          int
	message                  []byte
	rtime32_server_timestamp u32
	echo_to_sender           bool
}

pub fn (o &CMsgClientFriendMsg) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.chat_entry_type != int(0) {
		res << vproto.pack_int32_field(o.chat_entry_type, 2)
	}
	if o.message != []byte{} {
		res << vproto.pack_bytes_field(o.message, 3)
	}
	if o.rtime32_server_timestamp != u32(0) {
		res << vproto.pack_32bit_field(o.rtime32_server_timestamp, 4)
	}
	if o.echo_to_sender != false {
		res << vproto.pack_bool_field(o.echo_to_sender, 5)
	}
	return res
}

pub fn cmsgclientfriendmsg_unpack(buf []byte) ?CMsgClientFriendMsg {
	mut res := zzz_vproto_internal_new_cmsgclientfriendmsg()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.chat_entry_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.message = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.rtime32_server_timestamp = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.echo_to_sender = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientFriendMsg) eq(b CMsgClientFriendMsg) bool {
	return true && a.steamid == b.steamid && a.chat_entry_type == b.chat_entry_type &&
		a.message == b.message && a.rtime32_server_timestamp == b.rtime32_server_timestamp &&
		a.echo_to_sender == b.echo_to_sender
}

[inline]
pub fn (a CMsgClientFriendMsg) ne(b CMsgClientFriendMsg) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientFriendMsg) eq(b []CMsgClientFriendMsg) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientFriendMsg) ne(b []CMsgClientFriendMsg) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientfriendmsg() CMsgClientFriendMsg {
	return CMsgClientFriendMsg{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientfriendmsg(o CMsgClientFriendMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientfriendmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientfriendmsg_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientFriendMsgIncoming {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	steamid_from             u64
	chat_entry_type          int
	from_limited_account     bool
	message                  []byte
	rtime32_server_timestamp u32
}

pub fn (o &CMsgClientFriendMsgIncoming) pack() []byte {
	mut res := []byte{}
	if o.steamid_from != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_from, 1)
	}
	if o.chat_entry_type != int(0) {
		res << vproto.pack_int32_field(o.chat_entry_type, 2)
	}
	if o.from_limited_account != false {
		res << vproto.pack_bool_field(o.from_limited_account, 3)
	}
	if o.message != []byte{} {
		res << vproto.pack_bytes_field(o.message, 4)
	}
	if o.rtime32_server_timestamp != u32(0) {
		res << vproto.pack_32bit_field(o.rtime32_server_timestamp, 5)
	}
	return res
}

pub fn cmsgclientfriendmsgincoming_unpack(buf []byte) ?CMsgClientFriendMsgIncoming {
	mut res := zzz_vproto_internal_new_cmsgclientfriendmsgincoming()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid_from = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.chat_entry_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.from_limited_account = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.message = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.rtime32_server_timestamp = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientFriendMsgIncoming) eq(b CMsgClientFriendMsgIncoming) bool {
	return true && a.steamid_from == b.steamid_from && a.chat_entry_type == b.chat_entry_type &&
		a.from_limited_account == b.from_limited_account && a.message == b.message && a.rtime32_server_timestamp ==
		b.rtime32_server_timestamp
}

[inline]
pub fn (a CMsgClientFriendMsgIncoming) ne(b CMsgClientFriendMsgIncoming) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientFriendMsgIncoming) eq(b []CMsgClientFriendMsgIncoming) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientFriendMsgIncoming) ne(b []CMsgClientFriendMsgIncoming) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientfriendmsgincoming() CMsgClientFriendMsgIncoming {
	return CMsgClientFriendMsgIncoming{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientfriendmsgincoming(o CMsgClientFriendMsgIncoming, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientfriendmsgincoming(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendMsgIncoming) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientfriendmsgincoming_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAddFriend {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	steamid_to_add              u64
	accountname_or_email_to_add string
}

pub fn (o &CMsgClientAddFriend) pack() []byte {
	mut res := []byte{}
	if o.steamid_to_add != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_to_add, 1)
	}
	if o.accountname_or_email_to_add != '' {
		res << vproto.pack_string_field(o.accountname_or_email_to_add, 2)
	}
	return res
}

pub fn cmsgclientaddfriend_unpack(buf []byte) ?CMsgClientAddFriend {
	mut res := zzz_vproto_internal_new_cmsgclientaddfriend()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid_to_add = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.accountname_or_email_to_add = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAddFriend) eq(b CMsgClientAddFriend) bool {
	return true && a.steamid_to_add == b.steamid_to_add && a.accountname_or_email_to_add == b.accountname_or_email_to_add
}

[inline]
pub fn (a CMsgClientAddFriend) ne(b CMsgClientAddFriend) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAddFriend) eq(b []CMsgClientAddFriend) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAddFriend) ne(b []CMsgClientAddFriend) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientaddfriend() CMsgClientAddFriend {
	return CMsgClientAddFriend{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientaddfriend(o CMsgClientAddFriend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientaddfriend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAddFriend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientaddfriend_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAddFriendResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	eresult            int = 2
	steam_id_added     u64
	persona_name_added string
}

pub fn (o &CMsgClientAddFriendResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.steam_id_added != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_added, 2)
	}
	if o.persona_name_added != '' {
		res << vproto.pack_string_field(o.persona_name_added, 3)
	}
	return res
}

pub fn cmsgclientaddfriendresponse_unpack(buf []byte) ?CMsgClientAddFriendResponse {
	mut res := zzz_vproto_internal_new_cmsgclientaddfriendresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_added = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.persona_name_added = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAddFriendResponse) eq(b CMsgClientAddFriendResponse) bool {
	return true && a.eresult == b.eresult && a.steam_id_added == b.steam_id_added && a.persona_name_added ==
		b.persona_name_added
}

[inline]
pub fn (a CMsgClientAddFriendResponse) ne(b CMsgClientAddFriendResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAddFriendResponse) eq(b []CMsgClientAddFriendResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAddFriendResponse) ne(b []CMsgClientAddFriendResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientaddfriendresponse() CMsgClientAddFriendResponse {
	return CMsgClientAddFriendResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientaddfriendresponse(o CMsgClientAddFriendResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientaddfriendresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAddFriendResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientaddfriendresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRemoveFriend {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	friendid       u64
}

pub fn (o &CMsgClientRemoveFriend) pack() []byte {
	mut res := []byte{}
	if o.friendid != u64(0) {
		res << vproto.pack_64bit_field(o.friendid, 1)
	}
	return res
}

pub fn cmsgclientremovefriend_unpack(buf []byte) ?CMsgClientRemoveFriend {
	mut res := zzz_vproto_internal_new_cmsgclientremovefriend()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.friendid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRemoveFriend) eq(b CMsgClientRemoveFriend) bool {
	return true && a.friendid == b.friendid
}

[inline]
pub fn (a CMsgClientRemoveFriend) ne(b CMsgClientRemoveFriend) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRemoveFriend) eq(b []CMsgClientRemoveFriend) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRemoveFriend) ne(b []CMsgClientRemoveFriend) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientremovefriend() CMsgClientRemoveFriend {
	return CMsgClientRemoveFriend{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientremovefriend(o CMsgClientRemoveFriend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientremovefriend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRemoveFriend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientremovefriend_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientHideFriend {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	friendid       u64
	hide           bool
}

pub fn (o &CMsgClientHideFriend) pack() []byte {
	mut res := []byte{}
	if o.friendid != u64(0) {
		res << vproto.pack_64bit_field(o.friendid, 1)
	}
	if o.hide != false {
		res << vproto.pack_bool_field(o.hide, 2)
	}
	return res
}

pub fn cmsgclienthidefriend_unpack(buf []byte) ?CMsgClientHideFriend {
	mut res := zzz_vproto_internal_new_cmsgclienthidefriend()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.friendid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.hide = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientHideFriend) eq(b CMsgClientHideFriend) bool {
	return true && a.friendid == b.friendid && a.hide == b.hide
}

[inline]
pub fn (a CMsgClientHideFriend) ne(b CMsgClientHideFriend) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientHideFriend) eq(b []CMsgClientHideFriend) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientHideFriend) ne(b []CMsgClientHideFriend) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclienthidefriend() CMsgClientHideFriend {
	return CMsgClientHideFriend{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclienthidefriend(o CMsgClientHideFriend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclienthidefriend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientHideFriend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclienthidefriend_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientFriendsList_Friend {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	ulfriendid          u64
	efriendrelationship u32
}

pub fn (o &CMsgClientFriendsList_Friend) pack() []byte {
	mut res := []byte{}
	if o.ulfriendid != u64(0) {
		res << vproto.pack_64bit_field(o.ulfriendid, 1)
	}
	if o.efriendrelationship != u32(0) {
		res << vproto.pack_uint32_field(o.efriendrelationship, 2)
	}
	return res
}

pub fn cmsgclientfriendslist_friend_unpack(buf []byte) ?CMsgClientFriendsList_Friend {
	mut res := zzz_vproto_internal_new_cmsgclientfriendslist_friend()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.ulfriendid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.efriendrelationship = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientFriendsList_Friend) eq(b CMsgClientFriendsList_Friend) bool {
	return true && a.ulfriendid == b.ulfriendid && a.efriendrelationship == b.efriendrelationship
}

[inline]
pub fn (a CMsgClientFriendsList_Friend) ne(b CMsgClientFriendsList_Friend) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientFriendsList_Friend) eq(b []CMsgClientFriendsList_Friend) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientFriendsList_Friend) ne(b []CMsgClientFriendsList_Friend) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientfriendslist_friend() CMsgClientFriendsList_Friend {
	return CMsgClientFriendsList_Friend{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientfriendslist_friend(o CMsgClientFriendsList_Friend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientfriendslist_friend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendsList_Friend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientfriendslist_friend_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientFriendsList {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	bincremental        bool
	friends             []CMsgClientFriendsList_Friend
	max_friend_count    u32
	active_friend_count u32
	friends_limit_hit   bool
}

pub fn (o &CMsgClientFriendsList) pack() []byte {
	mut res := []byte{}
	if o.bincremental != false {
		res << vproto.pack_bool_field(o.bincremental, 1)
	}
	// [packed=false]
	for _, x in o.friends {
		res << zzz_vproto_internal_pack_cmsgclientfriendslist_friend(x, 2)
	}
	if o.max_friend_count != u32(0) {
		res << vproto.pack_uint32_field(o.max_friend_count, 3)
	}
	if o.active_friend_count != u32(0) {
		res << vproto.pack_uint32_field(o.active_friend_count, 4)
	}
	if o.friends_limit_hit != false {
		res << vproto.pack_bool_field(o.friends_limit_hit, 5)
	}
	return res
}

pub fn cmsgclientfriendslist_unpack(buf []byte) ?CMsgClientFriendsList {
	mut res := zzz_vproto_internal_new_cmsgclientfriendslist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.bincremental = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientfriendslist_friend(cur_buf,
					tag_wiretype.wire_type) ?
				res.friends << v
				i = ii
			}
			3 {
				i, res.max_friend_count = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.active_friend_count = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.friends_limit_hit = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientFriendsList) eq(b CMsgClientFriendsList) bool {
	return true && a.bincremental == b.bincremental && a.friends.eq(b.friends) && a.max_friend_count ==
		b.max_friend_count && a.active_friend_count == b.active_friend_count && a.friends_limit_hit ==
		b.friends_limit_hit
}

[inline]
pub fn (a CMsgClientFriendsList) ne(b CMsgClientFriendsList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientFriendsList) eq(b []CMsgClientFriendsList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientFriendsList) ne(b []CMsgClientFriendsList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientfriendslist() CMsgClientFriendsList {
	return CMsgClientFriendsList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientfriendslist(o CMsgClientFriendsList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientfriendslist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendsList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientfriendslist_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientFriendsGroupsList_FriendGroup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ngroupid       int
	strgroupname   string
}

pub fn (o &CMsgClientFriendsGroupsList_FriendGroup) pack() []byte {
	mut res := []byte{}
	if o.ngroupid != int(0) {
		res << vproto.pack_int32_field(o.ngroupid, 1)
	}
	if o.strgroupname != '' {
		res << vproto.pack_string_field(o.strgroupname, 2)
	}
	return res
}

pub fn cmsgclientfriendsgroupslist_friendgroup_unpack(buf []byte) ?CMsgClientFriendsGroupsList_FriendGroup {
	mut res := zzz_vproto_internal_new_cmsgclientfriendsgroupslist_friendgroup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.ngroupid = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.strgroupname = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientFriendsGroupsList_FriendGroup) eq(b CMsgClientFriendsGroupsList_FriendGroup) bool {
	return true && a.ngroupid == b.ngroupid && a.strgroupname == b.strgroupname
}

[inline]
pub fn (a CMsgClientFriendsGroupsList_FriendGroup) ne(b CMsgClientFriendsGroupsList_FriendGroup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientFriendsGroupsList_FriendGroup) eq(b []CMsgClientFriendsGroupsList_FriendGroup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientFriendsGroupsList_FriendGroup) ne(b []CMsgClientFriendsGroupsList_FriendGroup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientfriendsgroupslist_friendgroup() CMsgClientFriendsGroupsList_FriendGroup {
	return CMsgClientFriendsGroupsList_FriendGroup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientfriendsgroupslist_friendgroup(o CMsgClientFriendsGroupsList_FriendGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientfriendsgroupslist_friendgroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendsGroupsList_FriendGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientfriendsgroupslist_friendgroup_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientFriendsGroupsList_FriendGroupsMembership {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ulsteamid      u64
	ngroupid       int
}

pub fn (o &CMsgClientFriendsGroupsList_FriendGroupsMembership) pack() []byte {
	mut res := []byte{}
	if o.ulsteamid != u64(0) {
		res << vproto.pack_64bit_field(o.ulsteamid, 1)
	}
	if o.ngroupid != int(0) {
		res << vproto.pack_int32_field(o.ngroupid, 2)
	}
	return res
}

pub fn cmsgclientfriendsgroupslist_friendgroupsmembership_unpack(buf []byte) ?CMsgClientFriendsGroupsList_FriendGroupsMembership {
	mut res := zzz_vproto_internal_new_cmsgclientfriendsgroupslist_friendgroupsmembership()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.ulsteamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.ngroupid = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientFriendsGroupsList_FriendGroupsMembership) eq(b CMsgClientFriendsGroupsList_FriendGroupsMembership) bool {
	return true && a.ulsteamid == b.ulsteamid && a.ngroupid == b.ngroupid
}

[inline]
pub fn (a CMsgClientFriendsGroupsList_FriendGroupsMembership) ne(b CMsgClientFriendsGroupsList_FriendGroupsMembership) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientFriendsGroupsList_FriendGroupsMembership) eq(b []CMsgClientFriendsGroupsList_FriendGroupsMembership) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientFriendsGroupsList_FriendGroupsMembership) ne(b []CMsgClientFriendsGroupsList_FriendGroupsMembership) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientfriendsgroupslist_friendgroupsmembership() CMsgClientFriendsGroupsList_FriendGroupsMembership {
	return CMsgClientFriendsGroupsList_FriendGroupsMembership{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientfriendsgroupslist_friendgroupsmembership(o CMsgClientFriendsGroupsList_FriendGroupsMembership, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientfriendsgroupslist_friendgroupsmembership(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendsGroupsList_FriendGroupsMembership) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientfriendsgroupslist_friendgroupsmembership_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientFriendsGroupsList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bremoval       bool
	bincremental   bool
	friendgroups   []CMsgClientFriendsGroupsList_FriendGroup
	memberships    []CMsgClientFriendsGroupsList_FriendGroupsMembership
}

pub fn (o &CMsgClientFriendsGroupsList) pack() []byte {
	mut res := []byte{}
	if o.bremoval != false {
		res << vproto.pack_bool_field(o.bremoval, 1)
	}
	if o.bincremental != false {
		res << vproto.pack_bool_field(o.bincremental, 2)
	}
	// [packed=false]
	for _, x in o.friendgroups {
		res << zzz_vproto_internal_pack_cmsgclientfriendsgroupslist_friendgroup(x, 3)
	}
	// [packed=false]
	for _, x in o.memberships {
		res <<
			zzz_vproto_internal_pack_cmsgclientfriendsgroupslist_friendgroupsmembership(x, 4)
	}
	return res
}

pub fn cmsgclientfriendsgroupslist_unpack(buf []byte) ?CMsgClientFriendsGroupsList {
	mut res := zzz_vproto_internal_new_cmsgclientfriendsgroupslist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.bremoval = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.bincremental = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientfriendsgroupslist_friendgroup(cur_buf,
					tag_wiretype.wire_type) ?
				res.friendgroups << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientfriendsgroupslist_friendgroupsmembership(cur_buf,
					tag_wiretype.wire_type) ?
				res.memberships << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientFriendsGroupsList) eq(b CMsgClientFriendsGroupsList) bool {
	return true && a.bremoval == b.bremoval && a.bincremental == b.bincremental && a.friendgroups.eq(b.friendgroups) &&
		a.memberships.eq(b.memberships)
}

[inline]
pub fn (a CMsgClientFriendsGroupsList) ne(b CMsgClientFriendsGroupsList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientFriendsGroupsList) eq(b []CMsgClientFriendsGroupsList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientFriendsGroupsList) ne(b []CMsgClientFriendsGroupsList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientfriendsgroupslist() CMsgClientFriendsGroupsList {
	return CMsgClientFriendsGroupsList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientfriendsgroupslist(o CMsgClientFriendsGroupsList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientfriendsgroupslist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendsGroupsList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientfriendsgroupslist_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPlayerNicknameList_PlayerNickname {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	nickname       string
}

pub fn (o &CMsgClientPlayerNicknameList_PlayerNickname) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.nickname != '' {
		res << vproto.pack_string_field(o.nickname, 3)
	}
	return res
}

pub fn cmsgclientplayernicknamelist_playernickname_unpack(buf []byte) ?CMsgClientPlayerNicknameList_PlayerNickname {
	mut res := zzz_vproto_internal_new_cmsgclientplayernicknamelist_playernickname()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.nickname = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPlayerNicknameList_PlayerNickname) eq(b CMsgClientPlayerNicknameList_PlayerNickname) bool {
	return true && a.steamid == b.steamid && a.nickname == b.nickname
}

[inline]
pub fn (a CMsgClientPlayerNicknameList_PlayerNickname) ne(b CMsgClientPlayerNicknameList_PlayerNickname) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPlayerNicknameList_PlayerNickname) eq(b []CMsgClientPlayerNicknameList_PlayerNickname) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPlayerNicknameList_PlayerNickname) ne(b []CMsgClientPlayerNicknameList_PlayerNickname) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientplayernicknamelist_playernickname() CMsgClientPlayerNicknameList_PlayerNickname {
	return CMsgClientPlayerNicknameList_PlayerNickname{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientplayernicknamelist_playernickname(o CMsgClientPlayerNicknameList_PlayerNickname, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientplayernicknamelist_playernickname(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPlayerNicknameList_PlayerNickname) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientplayernicknamelist_playernickname_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPlayerNicknameList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	removal        bool
	incremental    bool
	nicknames      []CMsgClientPlayerNicknameList_PlayerNickname
}

pub fn (o &CMsgClientPlayerNicknameList) pack() []byte {
	mut res := []byte{}
	if o.removal != false {
		res << vproto.pack_bool_field(o.removal, 1)
	}
	if o.incremental != false {
		res << vproto.pack_bool_field(o.incremental, 2)
	}
	// [packed=false]
	for _, x in o.nicknames {
		res <<
			zzz_vproto_internal_pack_cmsgclientplayernicknamelist_playernickname(x, 3)
	}
	return res
}

pub fn cmsgclientplayernicknamelist_unpack(buf []byte) ?CMsgClientPlayerNicknameList {
	mut res := zzz_vproto_internal_new_cmsgclientplayernicknamelist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.removal = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.incremental = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientplayernicknamelist_playernickname(cur_buf,
					tag_wiretype.wire_type) ?
				res.nicknames << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPlayerNicknameList) eq(b CMsgClientPlayerNicknameList) bool {
	return true && a.removal == b.removal && a.incremental == b.incremental && a.nicknames.eq(b.nicknames)
}

[inline]
pub fn (a CMsgClientPlayerNicknameList) ne(b CMsgClientPlayerNicknameList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPlayerNicknameList) eq(b []CMsgClientPlayerNicknameList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPlayerNicknameList) ne(b []CMsgClientPlayerNicknameList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientplayernicknamelist() CMsgClientPlayerNicknameList {
	return CMsgClientPlayerNicknameList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientplayernicknamelist(o CMsgClientPlayerNicknameList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientplayernicknamelist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPlayerNicknameList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientplayernicknamelist_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSetPlayerNickname {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	nickname       string
}

pub fn (o &CMsgClientSetPlayerNickname) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.nickname != '' {
		res << vproto.pack_string_field(o.nickname, 2)
	}
	return res
}

pub fn cmsgclientsetplayernickname_unpack(buf []byte) ?CMsgClientSetPlayerNickname {
	mut res := zzz_vproto_internal_new_cmsgclientsetplayernickname()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.nickname = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSetPlayerNickname) eq(b CMsgClientSetPlayerNickname) bool {
	return true && a.steamid == b.steamid && a.nickname == b.nickname
}

[inline]
pub fn (a CMsgClientSetPlayerNickname) ne(b CMsgClientSetPlayerNickname) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSetPlayerNickname) eq(b []CMsgClientSetPlayerNickname) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSetPlayerNickname) ne(b []CMsgClientSetPlayerNickname) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsetplayernickname() CMsgClientSetPlayerNickname {
	return CMsgClientSetPlayerNickname{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsetplayernickname(o CMsgClientSetPlayerNickname, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsetplayernickname(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSetPlayerNickname) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsetplayernickname_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSetPlayerNicknameResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
}

pub fn (o &CMsgClientSetPlayerNicknameResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != u32(0) {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientsetplayernicknameresponse_unpack(buf []byte) ?CMsgClientSetPlayerNicknameResponse {
	mut res := zzz_vproto_internal_new_cmsgclientsetplayernicknameresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSetPlayerNicknameResponse) eq(b CMsgClientSetPlayerNicknameResponse) bool {
	return true && a.eresult == b.eresult
}

[inline]
pub fn (a CMsgClientSetPlayerNicknameResponse) ne(b CMsgClientSetPlayerNicknameResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSetPlayerNicknameResponse) eq(b []CMsgClientSetPlayerNicknameResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSetPlayerNicknameResponse) ne(b []CMsgClientSetPlayerNicknameResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsetplayernicknameresponse() CMsgClientSetPlayerNicknameResponse {
	return CMsgClientSetPlayerNicknameResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsetplayernicknameresponse(o CMsgClientSetPlayerNicknameResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsetplayernicknameresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSetPlayerNicknameResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsetplayernicknameresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRequestFriendData {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	persona_state_requested u32
	friends                 []u64
}

pub fn (o &CMsgClientRequestFriendData) pack() []byte {
	mut res := []byte{}
	if o.persona_state_requested != u32(0) {
		res << vproto.pack_uint32_field(o.persona_state_requested, 1)
	}
	// [packed=false]
	for _, x in o.friends {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cmsgclientrequestfrienddata_unpack(buf []byte) ?CMsgClientRequestFriendData {
	mut res := zzz_vproto_internal_new_cmsgclientrequestfrienddata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.persona_state_requested = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.friends << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRequestFriendData) eq(b CMsgClientRequestFriendData) bool {
	return true && a.persona_state_requested == b.persona_state_requested && a.friends == b.friends
}

[inline]
pub fn (a CMsgClientRequestFriendData) ne(b CMsgClientRequestFriendData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRequestFriendData) eq(b []CMsgClientRequestFriendData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRequestFriendData) ne(b []CMsgClientRequestFriendData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientrequestfrienddata() CMsgClientRequestFriendData {
	return CMsgClientRequestFriendData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientrequestfrienddata(o CMsgClientRequestFriendData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientrequestfrienddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestFriendData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientrequestfrienddata_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientChangeStatus {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	persona_state          u32
	player_name            string
	is_auto_generated_name bool
	high_priority          bool
	persona_set_by_user    bool
	persona_state_flags    u32
	need_persona_response  bool
	is_client_idle         bool
}

pub fn (o &CMsgClientChangeStatus) pack() []byte {
	mut res := []byte{}
	if o.persona_state != u32(0) {
		res << vproto.pack_uint32_field(o.persona_state, 1)
	}
	if o.player_name != '' {
		res << vproto.pack_string_field(o.player_name, 2)
	}
	if o.is_auto_generated_name != false {
		res << vproto.pack_bool_field(o.is_auto_generated_name, 3)
	}
	if o.high_priority != false {
		res << vproto.pack_bool_field(o.high_priority, 4)
	}
	if o.persona_set_by_user != false {
		res << vproto.pack_bool_field(o.persona_set_by_user, 5)
	}
	if o.persona_state_flags != u32(0) {
		res << vproto.pack_uint32_field(o.persona_state_flags, 6)
	}
	if o.need_persona_response != false {
		res << vproto.pack_bool_field(o.need_persona_response, 7)
	}
	if o.is_client_idle != false {
		res << vproto.pack_bool_field(o.is_client_idle, 8)
	}
	return res
}

pub fn cmsgclientchangestatus_unpack(buf []byte) ?CMsgClientChangeStatus {
	mut res := zzz_vproto_internal_new_cmsgclientchangestatus()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.persona_state = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.player_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.is_auto_generated_name = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.high_priority = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.persona_set_by_user = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.persona_state_flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.need_persona_response = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.is_client_idle = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientChangeStatus) eq(b CMsgClientChangeStatus) bool {
	return true && a.persona_state == b.persona_state && a.player_name == b.player_name &&
		a.is_auto_generated_name == b.is_auto_generated_name && a.high_priority == b.high_priority &&
		a.persona_set_by_user == b.persona_set_by_user && a.persona_state_flags == b.persona_state_flags &&
		a.need_persona_response == b.need_persona_response && a.is_client_idle == b.is_client_idle
}

[inline]
pub fn (a CMsgClientChangeStatus) ne(b CMsgClientChangeStatus) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientChangeStatus) eq(b []CMsgClientChangeStatus) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientChangeStatus) ne(b []CMsgClientChangeStatus) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientchangestatus() CMsgClientChangeStatus {
	return CMsgClientChangeStatus{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientchangestatus(o CMsgClientChangeStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientchangestatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChangeStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientchangestatus_unpack(v) ?
	return i, unpacked
}

pub struct CMsgPersonaChangeResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         u32
	player_name    string
}

pub fn (o &CMsgPersonaChangeResponse) pack() []byte {
	mut res := []byte{}
	if o.result != u32(0) {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	if o.player_name != '' {
		res << vproto.pack_string_field(o.player_name, 2)
	}
	return res
}

pub fn cmsgpersonachangeresponse_unpack(buf []byte) ?CMsgPersonaChangeResponse {
	mut res := zzz_vproto_internal_new_cmsgpersonachangeresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.result = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.player_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgPersonaChangeResponse) eq(b CMsgPersonaChangeResponse) bool {
	return true && a.result == b.result && a.player_name == b.player_name
}

[inline]
pub fn (a CMsgPersonaChangeResponse) ne(b CMsgPersonaChangeResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgPersonaChangeResponse) eq(b []CMsgPersonaChangeResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgPersonaChangeResponse) ne(b []CMsgPersonaChangeResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgpersonachangeresponse() CMsgPersonaChangeResponse {
	return CMsgPersonaChangeResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpersonachangeresponse(o CMsgPersonaChangeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpersonachangeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPersonaChangeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgpersonachangeresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPersonaStateFriend_ClanData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ogg_app_id     u32
	chat_group_id  u64
}

pub fn (o &CMsgClientPersonaStateFriend_ClanData) pack() []byte {
	mut res := []byte{}
	if o.ogg_app_id != u32(0) {
		res << vproto.pack_uint32_field(o.ogg_app_id, 1)
	}
	if o.chat_group_id != u64(0) {
		res << vproto.pack_uint64_field(o.chat_group_id, 2)
	}
	return res
}

pub fn cmsgclientpersonastatefriend_clandata_unpack(buf []byte) ?CMsgClientPersonaStateFriend_ClanData {
	mut res := zzz_vproto_internal_new_cmsgclientpersonastatefriend_clandata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.ogg_app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.chat_group_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPersonaStateFriend_ClanData) eq(b CMsgClientPersonaStateFriend_ClanData) bool {
	return true && a.ogg_app_id == b.ogg_app_id && a.chat_group_id == b.chat_group_id
}

[inline]
pub fn (a CMsgClientPersonaStateFriend_ClanData) ne(b CMsgClientPersonaStateFriend_ClanData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPersonaStateFriend_ClanData) eq(b []CMsgClientPersonaStateFriend_ClanData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPersonaStateFriend_ClanData) ne(b []CMsgClientPersonaStateFriend_ClanData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpersonastatefriend_clandata() CMsgClientPersonaStateFriend_ClanData {
	return CMsgClientPersonaStateFriend_ClanData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpersonastatefriend_clandata(o CMsgClientPersonaStateFriend_ClanData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpersonastatefriend_clandata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPersonaStateFriend_ClanData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpersonastatefriend_clandata_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPersonaStateFriend_KV {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	value          string
}

pub fn (o &CMsgClientPersonaStateFriend_KV) pack() []byte {
	mut res := []byte{}
	if o.key != '' {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.value != '' {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cmsgclientpersonastatefriend_kv_unpack(buf []byte) ?CMsgClientPersonaStateFriend_KV {
	mut res := zzz_vproto_internal_new_cmsgclientpersonastatefriend_kv()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.key = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.value = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPersonaStateFriend_KV) eq(b CMsgClientPersonaStateFriend_KV) bool {
	return true && a.key == b.key && a.value == b.value
}

[inline]
pub fn (a CMsgClientPersonaStateFriend_KV) ne(b CMsgClientPersonaStateFriend_KV) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPersonaStateFriend_KV) eq(b []CMsgClientPersonaStateFriend_KV) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPersonaStateFriend_KV) ne(b []CMsgClientPersonaStateFriend_KV) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpersonastatefriend_kv() CMsgClientPersonaStateFriend_KV {
	return CMsgClientPersonaStateFriend_KV{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpersonastatefriend_kv(o CMsgClientPersonaStateFriend_KV, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpersonastatefriend_kv(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPersonaStateFriend_KV) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpersonastatefriend_kv_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPersonaState_Friend {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	friendid                     u64
	persona_state                u32
	game_played_app_id           u32
	game_server_ip               u32
	game_server_port             u32
	persona_state_flags          u32
	online_session_instances     u32
	persona_set_by_user          bool
	player_name                  string
	query_port                   u32
	steamid_source               u64
	avatar_hash                  []byte
	last_logoff                  u32
	last_logon                   u32
	last_seen_online             u32
	clan_rank                    u32
	game_name                    string
	gameid                       u64
	game_data_blob               []byte
	clan_data                    CMsgClientPersonaStateFriend_ClanData
	clan_tag                     string
	rich_presence                []CMsgClientPersonaStateFriend_KV
	broadcast_id                 u64
	game_lobby_id                u64
	watching_broadcast_accountid u32
	watching_broadcast_appid     u32
	watching_broadcast_viewers   u32
	watching_broadcast_title     string
}

pub fn (o &CMsgClientPersonaState_Friend) pack() []byte {
	mut res := []byte{}
	if o.friendid != u64(0) {
		res << vproto.pack_64bit_field(o.friendid, 1)
	}
	if o.persona_state != u32(0) {
		res << vproto.pack_uint32_field(o.persona_state, 2)
	}
	if o.game_played_app_id != u32(0) {
		res << vproto.pack_uint32_field(o.game_played_app_id, 3)
	}
	if o.game_server_ip != u32(0) {
		res << vproto.pack_uint32_field(o.game_server_ip, 4)
	}
	if o.game_server_port != u32(0) {
		res << vproto.pack_uint32_field(o.game_server_port, 5)
	}
	if o.persona_state_flags != u32(0) {
		res << vproto.pack_uint32_field(o.persona_state_flags, 6)
	}
	if o.online_session_instances != u32(0) {
		res << vproto.pack_uint32_field(o.online_session_instances, 7)
	}
	if o.persona_set_by_user != false {
		res << vproto.pack_bool_field(o.persona_set_by_user, 10)
	}
	if o.player_name != '' {
		res << vproto.pack_string_field(o.player_name, 15)
	}
	if o.query_port != u32(0) {
		res << vproto.pack_uint32_field(o.query_port, 20)
	}
	if o.steamid_source != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_source, 25)
	}
	if o.avatar_hash != []byte{} {
		res << vproto.pack_bytes_field(o.avatar_hash, 31)
	}
	if o.last_logoff != u32(0) {
		res << vproto.pack_uint32_field(o.last_logoff, 45)
	}
	if o.last_logon != u32(0) {
		res << vproto.pack_uint32_field(o.last_logon, 46)
	}
	if o.last_seen_online != u32(0) {
		res << vproto.pack_uint32_field(o.last_seen_online, 47)
	}
	if o.clan_rank != u32(0) {
		res << vproto.pack_uint32_field(o.clan_rank, 50)
	}
	if o.game_name != '' {
		res << vproto.pack_string_field(o.game_name, 55)
	}
	if o.gameid != u64(0) {
		res << vproto.pack_64bit_field(o.gameid, 56)
	}
	if o.game_data_blob != []byte{} {
		res << vproto.pack_bytes_field(o.game_data_blob, 60)
	}
	if o.clan_data.ne(zzz_vproto_internal_new_cmsgclientpersonastatefriend_clandata()) {
		res <<
			zzz_vproto_internal_pack_cmsgclientpersonastatefriend_clandata(o.clan_data, 64)
	}
	if o.clan_tag != '' {
		res << vproto.pack_string_field(o.clan_tag, 65)
	}
	// [packed=false]
	for _, x in o.rich_presence {
		res << zzz_vproto_internal_pack_cmsgclientpersonastatefriend_kv(x, 71)
	}
	if o.broadcast_id != u64(0) {
		res << vproto.pack_64bit_field(o.broadcast_id, 72)
	}
	if o.game_lobby_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_lobby_id, 73)
	}
	if o.watching_broadcast_accountid != u32(0) {
		res << vproto.pack_uint32_field(o.watching_broadcast_accountid, 74)
	}
	if o.watching_broadcast_appid != u32(0) {
		res << vproto.pack_uint32_field(o.watching_broadcast_appid, 75)
	}
	if o.watching_broadcast_viewers != u32(0) {
		res << vproto.pack_uint32_field(o.watching_broadcast_viewers, 76)
	}
	if o.watching_broadcast_title != '' {
		res << vproto.pack_string_field(o.watching_broadcast_title, 77)
	}
	return res
}

pub fn cmsgclientpersonastate_friend_unpack(buf []byte) ?CMsgClientPersonaState_Friend {
	mut res := zzz_vproto_internal_new_cmsgclientpersonastate_friend()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.friendid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.persona_state = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.game_played_app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.game_server_ip = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.game_server_port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.persona_state_flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.online_session_instances = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			10 {
				i, res.persona_set_by_user = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			15 {
				i, res.player_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			20 {
				i, res.query_port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			25 {
				i, res.steamid_source = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			31 {
				i, res.avatar_hash = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			45 {
				i, res.last_logoff = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			46 {
				i, res.last_logon = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			47 {
				i, res.last_seen_online = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			50 {
				i, res.clan_rank = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			55 {
				i, res.game_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			56 {
				i, res.gameid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			60 {
				i, res.game_data_blob = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			64 {
				i, res.clan_data = zzz_vproto_internal_unpack_cmsgclientpersonastatefriend_clandata(cur_buf,
					tag_wiretype.wire_type) ?
			}
			65 {
				i, res.clan_tag = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			71 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastatefriend_kv(cur_buf,
					tag_wiretype.wire_type) ?
				res.rich_presence << v
				i = ii
			}
			72 {
				i, res.broadcast_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			73 {
				i, res.game_lobby_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			74 {
				i, res.watching_broadcast_accountid = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			75 {
				i, res.watching_broadcast_appid = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			76 {
				i, res.watching_broadcast_viewers = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			77 {
				i, res.watching_broadcast_title = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPersonaState_Friend) eq(b CMsgClientPersonaState_Friend) bool {
	return true && a.friendid == b.friendid && a.persona_state == b.persona_state && a.game_played_app_id ==
		b.game_played_app_id && a.game_server_ip == b.game_server_ip && a.game_server_port == b.game_server_port &&
		a.persona_state_flags == b.persona_state_flags && a.online_session_instances == b.online_session_instances &&
		a.persona_set_by_user == b.persona_set_by_user && a.player_name == b.player_name && a.query_port ==
		b.query_port && a.steamid_source == b.steamid_source && a.avatar_hash == b.avatar_hash &&
		a.last_logoff == b.last_logoff && a.last_logon == b.last_logon && a.last_seen_online == b.last_seen_online &&
		a.clan_rank == b.clan_rank && a.game_name == b.game_name && a.gameid == b.gameid && a.game_data_blob ==
		b.game_data_blob && a.clan_data.eq(b.clan_data) && a.clan_tag == b.clan_tag && a.rich_presence.eq(b.rich_presence) &&
		a.broadcast_id == b.broadcast_id && a.game_lobby_id == b.game_lobby_id && a.watching_broadcast_accountid ==
		b.watching_broadcast_accountid && a.watching_broadcast_appid == b.watching_broadcast_appid &&
		a.watching_broadcast_viewers == b.watching_broadcast_viewers && a.watching_broadcast_title ==
		b.watching_broadcast_title
}

[inline]
pub fn (a CMsgClientPersonaState_Friend) ne(b CMsgClientPersonaState_Friend) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPersonaState_Friend) eq(b []CMsgClientPersonaState_Friend) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPersonaState_Friend) ne(b []CMsgClientPersonaState_Friend) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpersonastate_friend() CMsgClientPersonaState_Friend {
	return CMsgClientPersonaState_Friend{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpersonastate_friend(o CMsgClientPersonaState_Friend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpersonastate_friend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPersonaState_Friend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpersonastate_friend_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPersonaState {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	status_flags   u32
	friends        []CMsgClientPersonaState_Friend
}

pub fn (o &CMsgClientPersonaState) pack() []byte {
	mut res := []byte{}
	if o.status_flags != u32(0) {
		res << vproto.pack_uint32_field(o.status_flags, 1)
	}
	// [packed=false]
	for _, x in o.friends {
		res << zzz_vproto_internal_pack_cmsgclientpersonastate_friend(x, 2)
	}
	return res
}

pub fn cmsgclientpersonastate_unpack(buf []byte) ?CMsgClientPersonaState {
	mut res := zzz_vproto_internal_new_cmsgclientpersonastate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.status_flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastate_friend(cur_buf,
					tag_wiretype.wire_type) ?
				res.friends << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPersonaState) eq(b CMsgClientPersonaState) bool {
	return true && a.status_flags == b.status_flags && a.friends.eq(b.friends)
}

[inline]
pub fn (a CMsgClientPersonaState) ne(b CMsgClientPersonaState) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPersonaState) eq(b []CMsgClientPersonaState) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPersonaState) ne(b []CMsgClientPersonaState) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpersonastate() CMsgClientPersonaState {
	return CMsgClientPersonaState{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpersonastate(o CMsgClientPersonaState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpersonastate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPersonaState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpersonastate_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientFriendProfileInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid_friend u64
}

pub fn (o &CMsgClientFriendProfileInfo) pack() []byte {
	mut res := []byte{}
	if o.steamid_friend != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_friend, 1)
	}
	return res
}

pub fn cmsgclientfriendprofileinfo_unpack(buf []byte) ?CMsgClientFriendProfileInfo {
	mut res := zzz_vproto_internal_new_cmsgclientfriendprofileinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid_friend = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientFriendProfileInfo) eq(b CMsgClientFriendProfileInfo) bool {
	return true && a.steamid_friend == b.steamid_friend
}

[inline]
pub fn (a CMsgClientFriendProfileInfo) ne(b CMsgClientFriendProfileInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientFriendProfileInfo) eq(b []CMsgClientFriendProfileInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientFriendProfileInfo) ne(b []CMsgClientFriendProfileInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientfriendprofileinfo() CMsgClientFriendProfileInfo {
	return CMsgClientFriendProfileInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientfriendprofileinfo(o CMsgClientFriendProfileInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientfriendprofileinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendProfileInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientfriendprofileinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientFriendProfileInfoResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	steamid_friend u64
	time_created   u32
	real_name      string
	city_name      string
	state_name     string
	country_name   string
	headline       string
	summary        string
}

pub fn (o &CMsgClientFriendProfileInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.steamid_friend != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_friend, 2)
	}
	if o.time_created != u32(0) {
		res << vproto.pack_uint32_field(o.time_created, 3)
	}
	if o.real_name != '' {
		res << vproto.pack_string_field(o.real_name, 4)
	}
	if o.city_name != '' {
		res << vproto.pack_string_field(o.city_name, 5)
	}
	if o.state_name != '' {
		res << vproto.pack_string_field(o.state_name, 6)
	}
	if o.country_name != '' {
		res << vproto.pack_string_field(o.country_name, 7)
	}
	if o.headline != '' {
		res << vproto.pack_string_field(o.headline, 8)
	}
	if o.summary != '' {
		res << vproto.pack_string_field(o.summary, 9)
	}
	return res
}

pub fn cmsgclientfriendprofileinforesponse_unpack(buf []byte) ?CMsgClientFriendProfileInfoResponse {
	mut res := zzz_vproto_internal_new_cmsgclientfriendprofileinforesponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steamid_friend = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.time_created = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.real_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.city_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.state_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.country_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.headline = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.summary = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientFriendProfileInfoResponse) eq(b CMsgClientFriendProfileInfoResponse) bool {
	return true && a.eresult == b.eresult && a.steamid_friend == b.steamid_friend && a.time_created ==
		b.time_created && a.real_name == b.real_name && a.city_name == b.city_name && a.state_name ==
		b.state_name && a.country_name == b.country_name && a.headline == b.headline && a.summary == b.summary
}

[inline]
pub fn (a CMsgClientFriendProfileInfoResponse) ne(b CMsgClientFriendProfileInfoResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientFriendProfileInfoResponse) eq(b []CMsgClientFriendProfileInfoResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientFriendProfileInfoResponse) ne(b []CMsgClientFriendProfileInfoResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientfriendprofileinforesponse() CMsgClientFriendProfileInfoResponse {
	return CMsgClientFriendProfileInfoResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientfriendprofileinforesponse(o CMsgClientFriendProfileInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientfriendprofileinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendProfileInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientfriendprofileinforesponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientCreateFriendsGroup {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	steamid         u64
	groupname       string
	steamid_friends []u64
}

pub fn (o &CMsgClientCreateFriendsGroup) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.groupname != '' {
		res << vproto.pack_string_field(o.groupname, 2)
	}
	// [packed=false]
	for _, x in o.steamid_friends {
		res << vproto.pack_64bit_field(x, 3)
	}
	return res
}

pub fn cmsgclientcreatefriendsgroup_unpack(buf []byte) ?CMsgClientCreateFriendsGroup {
	mut res := zzz_vproto_internal_new_cmsgclientcreatefriendsgroup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.groupname = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid_friends << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientCreateFriendsGroup) eq(b CMsgClientCreateFriendsGroup) bool {
	return true && a.steamid == b.steamid && a.groupname == b.groupname && a.steamid_friends ==
		b.steamid_friends
}

[inline]
pub fn (a CMsgClientCreateFriendsGroup) ne(b CMsgClientCreateFriendsGroup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientCreateFriendsGroup) eq(b []CMsgClientCreateFriendsGroup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientCreateFriendsGroup) ne(b []CMsgClientCreateFriendsGroup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientcreatefriendsgroup() CMsgClientCreateFriendsGroup {
	return CMsgClientCreateFriendsGroup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientcreatefriendsgroup(o CMsgClientCreateFriendsGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientcreatefriendsgroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCreateFriendsGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientcreatefriendsgroup_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientCreateFriendsGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	groupid        int
}

pub fn (o &CMsgClientCreateFriendsGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != u32(0) {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.groupid != int(0) {
		res << vproto.pack_int32_field(o.groupid, 2)
	}
	return res
}

pub fn cmsgclientcreatefriendsgroupresponse_unpack(buf []byte) ?CMsgClientCreateFriendsGroupResponse {
	mut res := zzz_vproto_internal_new_cmsgclientcreatefriendsgroupresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.groupid = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientCreateFriendsGroupResponse) eq(b CMsgClientCreateFriendsGroupResponse) bool {
	return true && a.eresult == b.eresult && a.groupid == b.groupid
}

[inline]
pub fn (a CMsgClientCreateFriendsGroupResponse) ne(b CMsgClientCreateFriendsGroupResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientCreateFriendsGroupResponse) eq(b []CMsgClientCreateFriendsGroupResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientCreateFriendsGroupResponse) ne(b []CMsgClientCreateFriendsGroupResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientcreatefriendsgroupresponse() CMsgClientCreateFriendsGroupResponse {
	return CMsgClientCreateFriendsGroupResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientcreatefriendsgroupresponse(o CMsgClientCreateFriendsGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientcreatefriendsgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCreateFriendsGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientcreatefriendsgroupresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientDeleteFriendsGroup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	groupid        int
}

pub fn (o &CMsgClientDeleteFriendsGroup) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.groupid != int(0) {
		res << vproto.pack_int32_field(o.groupid, 2)
	}
	return res
}

pub fn cmsgclientdeletefriendsgroup_unpack(buf []byte) ?CMsgClientDeleteFriendsGroup {
	mut res := zzz_vproto_internal_new_cmsgclientdeletefriendsgroup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.groupid = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientDeleteFriendsGroup) eq(b CMsgClientDeleteFriendsGroup) bool {
	return true && a.steamid == b.steamid && a.groupid == b.groupid
}

[inline]
pub fn (a CMsgClientDeleteFriendsGroup) ne(b CMsgClientDeleteFriendsGroup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientDeleteFriendsGroup) eq(b []CMsgClientDeleteFriendsGroup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientDeleteFriendsGroup) ne(b []CMsgClientDeleteFriendsGroup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientdeletefriendsgroup() CMsgClientDeleteFriendsGroup {
	return CMsgClientDeleteFriendsGroup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientdeletefriendsgroup(o CMsgClientDeleteFriendsGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientdeletefriendsgroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeleteFriendsGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientdeletefriendsgroup_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientDeleteFriendsGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
}

pub fn (o &CMsgClientDeleteFriendsGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != u32(0) {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientdeletefriendsgroupresponse_unpack(buf []byte) ?CMsgClientDeleteFriendsGroupResponse {
	mut res := zzz_vproto_internal_new_cmsgclientdeletefriendsgroupresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientDeleteFriendsGroupResponse) eq(b CMsgClientDeleteFriendsGroupResponse) bool {
	return true && a.eresult == b.eresult
}

[inline]
pub fn (a CMsgClientDeleteFriendsGroupResponse) ne(b CMsgClientDeleteFriendsGroupResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientDeleteFriendsGroupResponse) eq(b []CMsgClientDeleteFriendsGroupResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientDeleteFriendsGroupResponse) ne(b []CMsgClientDeleteFriendsGroupResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientdeletefriendsgroupresponse() CMsgClientDeleteFriendsGroupResponse {
	return CMsgClientDeleteFriendsGroupResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientdeletefriendsgroupresponse(o CMsgClientDeleteFriendsGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientdeletefriendsgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeleteFriendsGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientdeletefriendsgroupresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientManageFriendsGroup {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	groupid                 int
	groupname               string
	steamid_friends_added   []u64
	steamid_friends_removed []u64
}

pub fn (o &CMsgClientManageFriendsGroup) pack() []byte {
	mut res := []byte{}
	if o.groupid != int(0) {
		res << vproto.pack_int32_field(o.groupid, 1)
	}
	if o.groupname != '' {
		res << vproto.pack_string_field(o.groupname, 2)
	}
	// [packed=false]
	for _, x in o.steamid_friends_added {
		res << vproto.pack_64bit_field(x, 3)
	}
	// [packed=false]
	for _, x in o.steamid_friends_removed {
		res << vproto.pack_64bit_field(x, 4)
	}
	return res
}

pub fn cmsgclientmanagefriendsgroup_unpack(buf []byte) ?CMsgClientManageFriendsGroup {
	mut res := zzz_vproto_internal_new_cmsgclientmanagefriendsgroup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.groupid = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.groupname = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid_friends_added << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid_friends_removed << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientManageFriendsGroup) eq(b CMsgClientManageFriendsGroup) bool {
	return true && a.groupid == b.groupid && a.groupname == b.groupname && a.steamid_friends_added ==
		b.steamid_friends_added && a.steamid_friends_removed == b.steamid_friends_removed
}

[inline]
pub fn (a CMsgClientManageFriendsGroup) ne(b CMsgClientManageFriendsGroup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientManageFriendsGroup) eq(b []CMsgClientManageFriendsGroup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientManageFriendsGroup) ne(b []CMsgClientManageFriendsGroup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmanagefriendsgroup() CMsgClientManageFriendsGroup {
	return CMsgClientManageFriendsGroup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmanagefriendsgroup(o CMsgClientManageFriendsGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmanagefriendsgroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientManageFriendsGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmanagefriendsgroup_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientManageFriendsGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
}

pub fn (o &CMsgClientManageFriendsGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != u32(0) {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientmanagefriendsgroupresponse_unpack(buf []byte) ?CMsgClientManageFriendsGroupResponse {
	mut res := zzz_vproto_internal_new_cmsgclientmanagefriendsgroupresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientManageFriendsGroupResponse) eq(b CMsgClientManageFriendsGroupResponse) bool {
	return true && a.eresult == b.eresult
}

[inline]
pub fn (a CMsgClientManageFriendsGroupResponse) ne(b CMsgClientManageFriendsGroupResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientManageFriendsGroupResponse) eq(b []CMsgClientManageFriendsGroupResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientManageFriendsGroupResponse) ne(b []CMsgClientManageFriendsGroupResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmanagefriendsgroupresponse() CMsgClientManageFriendsGroupResponse {
	return CMsgClientManageFriendsGroupResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmanagefriendsgroupresponse(o CMsgClientManageFriendsGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmanagefriendsgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientManageFriendsGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmanagefriendsgroupresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAddFriendToGroup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	groupid        int
	steamiduser    u64
}

pub fn (o &CMsgClientAddFriendToGroup) pack() []byte {
	mut res := []byte{}
	if o.groupid != int(0) {
		res << vproto.pack_int32_field(o.groupid, 1)
	}
	if o.steamiduser != u64(0) {
		res << vproto.pack_64bit_field(o.steamiduser, 2)
	}
	return res
}

pub fn cmsgclientaddfriendtogroup_unpack(buf []byte) ?CMsgClientAddFriendToGroup {
	mut res := zzz_vproto_internal_new_cmsgclientaddfriendtogroup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.groupid = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steamiduser = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAddFriendToGroup) eq(b CMsgClientAddFriendToGroup) bool {
	return true && a.groupid == b.groupid && a.steamiduser == b.steamiduser
}

[inline]
pub fn (a CMsgClientAddFriendToGroup) ne(b CMsgClientAddFriendToGroup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAddFriendToGroup) eq(b []CMsgClientAddFriendToGroup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAddFriendToGroup) ne(b []CMsgClientAddFriendToGroup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientaddfriendtogroup() CMsgClientAddFriendToGroup {
	return CMsgClientAddFriendToGroup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientaddfriendtogroup(o CMsgClientAddFriendToGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientaddfriendtogroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAddFriendToGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientaddfriendtogroup_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAddFriendToGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
}

pub fn (o &CMsgClientAddFriendToGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != u32(0) {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientaddfriendtogroupresponse_unpack(buf []byte) ?CMsgClientAddFriendToGroupResponse {
	mut res := zzz_vproto_internal_new_cmsgclientaddfriendtogroupresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAddFriendToGroupResponse) eq(b CMsgClientAddFriendToGroupResponse) bool {
	return true && a.eresult == b.eresult
}

[inline]
pub fn (a CMsgClientAddFriendToGroupResponse) ne(b CMsgClientAddFriendToGroupResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAddFriendToGroupResponse) eq(b []CMsgClientAddFriendToGroupResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAddFriendToGroupResponse) ne(b []CMsgClientAddFriendToGroupResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientaddfriendtogroupresponse() CMsgClientAddFriendToGroupResponse {
	return CMsgClientAddFriendToGroupResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientaddfriendtogroupresponse(o CMsgClientAddFriendToGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientaddfriendtogroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAddFriendToGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientaddfriendtogroupresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRemoveFriendFromGroup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	groupid        int
	steamiduser    u64
}

pub fn (o &CMsgClientRemoveFriendFromGroup) pack() []byte {
	mut res := []byte{}
	if o.groupid != int(0) {
		res << vproto.pack_int32_field(o.groupid, 1)
	}
	if o.steamiduser != u64(0) {
		res << vproto.pack_64bit_field(o.steamiduser, 2)
	}
	return res
}

pub fn cmsgclientremovefriendfromgroup_unpack(buf []byte) ?CMsgClientRemoveFriendFromGroup {
	mut res := zzz_vproto_internal_new_cmsgclientremovefriendfromgroup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.groupid = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steamiduser = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRemoveFriendFromGroup) eq(b CMsgClientRemoveFriendFromGroup) bool {
	return true && a.groupid == b.groupid && a.steamiduser == b.steamiduser
}

[inline]
pub fn (a CMsgClientRemoveFriendFromGroup) ne(b CMsgClientRemoveFriendFromGroup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRemoveFriendFromGroup) eq(b []CMsgClientRemoveFriendFromGroup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRemoveFriendFromGroup) ne(b []CMsgClientRemoveFriendFromGroup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientremovefriendfromgroup() CMsgClientRemoveFriendFromGroup {
	return CMsgClientRemoveFriendFromGroup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientremovefriendfromgroup(o CMsgClientRemoveFriendFromGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientremovefriendfromgroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRemoveFriendFromGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientremovefriendfromgroup_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRemoveFriendFromGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
}

pub fn (o &CMsgClientRemoveFriendFromGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != u32(0) {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientremovefriendfromgroupresponse_unpack(buf []byte) ?CMsgClientRemoveFriendFromGroupResponse {
	mut res := zzz_vproto_internal_new_cmsgclientremovefriendfromgroupresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRemoveFriendFromGroupResponse) eq(b CMsgClientRemoveFriendFromGroupResponse) bool {
	return true && a.eresult == b.eresult
}

[inline]
pub fn (a CMsgClientRemoveFriendFromGroupResponse) ne(b CMsgClientRemoveFriendFromGroupResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRemoveFriendFromGroupResponse) eq(b []CMsgClientRemoveFriendFromGroupResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRemoveFriendFromGroupResponse) ne(b []CMsgClientRemoveFriendFromGroupResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientremovefriendfromgroupresponse() CMsgClientRemoveFriendFromGroupResponse {
	return CMsgClientRemoveFriendFromGroupResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientremovefriendfromgroupresponse(o CMsgClientRemoveFriendFromGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientremovefriendfromgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRemoveFriendFromGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientremovefriendfromgroupresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetEmoticonList {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientGetEmoticonList) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientgetemoticonlist_unpack(buf []byte) ?CMsgClientGetEmoticonList {
	res := zzz_vproto_internal_new_cmsgclientgetemoticonlist()
	return res
}

[inline]
pub fn (a CMsgClientGetEmoticonList) eq(b CMsgClientGetEmoticonList) bool {
	return true
}

[inline]
pub fn (a CMsgClientGetEmoticonList) ne(b CMsgClientGetEmoticonList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetEmoticonList) eq(b []CMsgClientGetEmoticonList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetEmoticonList) ne(b []CMsgClientGetEmoticonList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetemoticonlist() CMsgClientGetEmoticonList {
	return CMsgClientGetEmoticonList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetemoticonlist(o CMsgClientGetEmoticonList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetemoticonlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetEmoticonList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetemoticonlist_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientEmoticonList_Emoticon {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	count          int
	time_last_used u32
	use_count      u32
	time_received  u32
}

pub fn (o &CMsgClientEmoticonList_Emoticon) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.count != int(0) {
		res << vproto.pack_int32_field(o.count, 2)
	}
	if o.time_last_used != u32(0) {
		res << vproto.pack_uint32_field(o.time_last_used, 3)
	}
	if o.use_count != u32(0) {
		res << vproto.pack_uint32_field(o.use_count, 4)
	}
	if o.time_received != u32(0) {
		res << vproto.pack_uint32_field(o.time_received, 5)
	}
	return res
}

pub fn cmsgclientemoticonlist_emoticon_unpack(buf []byte) ?CMsgClientEmoticonList_Emoticon {
	mut res := zzz_vproto_internal_new_cmsgclientemoticonlist_emoticon()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.count = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.time_last_used = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.use_count = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.time_received = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientEmoticonList_Emoticon) eq(b CMsgClientEmoticonList_Emoticon) bool {
	return true && a.name == b.name && a.count == b.count && a.time_last_used == b.time_last_used &&
		a.use_count == b.use_count && a.time_received == b.time_received
}

[inline]
pub fn (a CMsgClientEmoticonList_Emoticon) ne(b CMsgClientEmoticonList_Emoticon) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientEmoticonList_Emoticon) eq(b []CMsgClientEmoticonList_Emoticon) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientEmoticonList_Emoticon) ne(b []CMsgClientEmoticonList_Emoticon) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientemoticonlist_emoticon() CMsgClientEmoticonList_Emoticon {
	return CMsgClientEmoticonList_Emoticon{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientemoticonlist_emoticon(o CMsgClientEmoticonList_Emoticon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientemoticonlist_emoticon(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientEmoticonList_Emoticon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientemoticonlist_emoticon_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientEmoticonList_Sticker {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	count          int
	time_received  u32
	appid          u32
}

pub fn (o &CMsgClientEmoticonList_Sticker) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.count != int(0) {
		res << vproto.pack_int32_field(o.count, 2)
	}
	if o.time_received != u32(0) {
		res << vproto.pack_uint32_field(o.time_received, 3)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 4)
	}
	return res
}

pub fn cmsgclientemoticonlist_sticker_unpack(buf []byte) ?CMsgClientEmoticonList_Sticker {
	mut res := zzz_vproto_internal_new_cmsgclientemoticonlist_sticker()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.count = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.time_received = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientEmoticonList_Sticker) eq(b CMsgClientEmoticonList_Sticker) bool {
	return true && a.name == b.name && a.count == b.count && a.time_received == b.time_received &&
		a.appid == b.appid
}

[inline]
pub fn (a CMsgClientEmoticonList_Sticker) ne(b CMsgClientEmoticonList_Sticker) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientEmoticonList_Sticker) eq(b []CMsgClientEmoticonList_Sticker) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientEmoticonList_Sticker) ne(b []CMsgClientEmoticonList_Sticker) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientemoticonlist_sticker() CMsgClientEmoticonList_Sticker {
	return CMsgClientEmoticonList_Sticker{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientemoticonlist_sticker(o CMsgClientEmoticonList_Sticker, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientemoticonlist_sticker(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientEmoticonList_Sticker) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientemoticonlist_sticker_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientEmoticonList_Effect {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	count          int
	time_received  u32
	infinite_use   bool
	appid          u32
}

pub fn (o &CMsgClientEmoticonList_Effect) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.count != int(0) {
		res << vproto.pack_int32_field(o.count, 2)
	}
	if o.time_received != u32(0) {
		res << vproto.pack_uint32_field(o.time_received, 3)
	}
	if o.infinite_use != false {
		res << vproto.pack_bool_field(o.infinite_use, 4)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 5)
	}
	return res
}

pub fn cmsgclientemoticonlist_effect_unpack(buf []byte) ?CMsgClientEmoticonList_Effect {
	mut res := zzz_vproto_internal_new_cmsgclientemoticonlist_effect()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.count = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.time_received = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.infinite_use = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientEmoticonList_Effect) eq(b CMsgClientEmoticonList_Effect) bool {
	return true && a.name == b.name && a.count == b.count && a.time_received == b.time_received &&
		a.infinite_use == b.infinite_use && a.appid == b.appid
}

[inline]
pub fn (a CMsgClientEmoticonList_Effect) ne(b CMsgClientEmoticonList_Effect) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientEmoticonList_Effect) eq(b []CMsgClientEmoticonList_Effect) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientEmoticonList_Effect) ne(b []CMsgClientEmoticonList_Effect) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientemoticonlist_effect() CMsgClientEmoticonList_Effect {
	return CMsgClientEmoticonList_Effect{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientemoticonlist_effect(o CMsgClientEmoticonList_Effect, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientemoticonlist_effect(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientEmoticonList_Effect) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientemoticonlist_effect_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientEmoticonList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	emoticons      []CMsgClientEmoticonList_Emoticon
	stickers       []CMsgClientEmoticonList_Sticker
	effects        []CMsgClientEmoticonList_Effect
}

pub fn (o &CMsgClientEmoticonList) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.emoticons {
		res << zzz_vproto_internal_pack_cmsgclientemoticonlist_emoticon(x, 1)
	}
	// [packed=false]
	for _, x in o.stickers {
		res << zzz_vproto_internal_pack_cmsgclientemoticonlist_sticker(x, 2)
	}
	// [packed=false]
	for _, x in o.effects {
		res << zzz_vproto_internal_pack_cmsgclientemoticonlist_effect(x, 3)
	}
	return res
}

pub fn cmsgclientemoticonlist_unpack(buf []byte) ?CMsgClientEmoticonList {
	mut res := zzz_vproto_internal_new_cmsgclientemoticonlist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientemoticonlist_emoticon(cur_buf,
					tag_wiretype.wire_type) ?
				res.emoticons << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientemoticonlist_sticker(cur_buf,
					tag_wiretype.wire_type) ?
				res.stickers << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientemoticonlist_effect(cur_buf,
					tag_wiretype.wire_type) ?
				res.effects << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientEmoticonList) eq(b CMsgClientEmoticonList) bool {
	return true && a.emoticons.eq(b.emoticons) && a.stickers.eq(b.stickers) && a.effects.eq(b.effects)
}

[inline]
pub fn (a CMsgClientEmoticonList) ne(b CMsgClientEmoticonList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientEmoticonList) eq(b []CMsgClientEmoticonList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientEmoticonList) ne(b []CMsgClientEmoticonList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientemoticonlist() CMsgClientEmoticonList {
	return CMsgClientEmoticonList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientemoticonlist(o CMsgClientEmoticonList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientemoticonlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientEmoticonList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientemoticonlist_unpack(v) ?
	return i, unpacked
}
