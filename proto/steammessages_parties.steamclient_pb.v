// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CParties_JoinParty_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	beacon_id      u64
}

pub fn (o &CParties_JoinParty_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 2)
	}
	return res
}

pub fn cparties_joinparty_request_unpack(buf []byte) ?CParties_JoinParty_Request {
	mut res := zzz_vproto_internal_new_cparties_joinparty_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_JoinParty_Request) eq(b CParties_JoinParty_Request) bool {
	return true && a.steamid == b.steamid && a.beacon_id == b.beacon_id
}

[inline]
pub fn (a CParties_JoinParty_Request) ne(b CParties_JoinParty_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_JoinParty_Request) eq(b []CParties_JoinParty_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_JoinParty_Request) ne(b []CParties_JoinParty_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_joinparty_request() CParties_JoinParty_Request {
	return CParties_JoinParty_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_joinparty_request(o CParties_JoinParty_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_joinparty_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_JoinParty_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_joinparty_request_unpack(v) ?
	return i, unpacked
}

pub struct CParties_JoinParty_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
	connect_string string
}

pub fn (o &CParties_JoinParty_Response) pack() []byte {
	mut res := []byte{}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	if o.connect_string != '' {
		res << vproto.pack_string_field(o.connect_string, 2)
	}
	return res
}

pub fn cparties_joinparty_response_unpack(buf []byte) ?CParties_JoinParty_Response {
	mut res := zzz_vproto_internal_new_cparties_joinparty_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.connect_string = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_JoinParty_Response) eq(b CParties_JoinParty_Response) bool {
	return true && a.beacon_id == b.beacon_id && a.connect_string == b.connect_string
}

[inline]
pub fn (a CParties_JoinParty_Response) ne(b CParties_JoinParty_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_JoinParty_Response) eq(b []CParties_JoinParty_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_JoinParty_Response) ne(b []CParties_JoinParty_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_joinparty_response() CParties_JoinParty_Response {
	return CParties_JoinParty_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_joinparty_response(o CParties_JoinParty_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_joinparty_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_JoinParty_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_joinparty_response_unpack(v) ?
	return i, unpacked
}

pub struct CParties_BeaconLocation {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	location_type  u32
	location_id    u64
}

pub fn (o &CParties_BeaconLocation) pack() []byte {
	mut res := []byte{}
	if o.location_type != u32(0) {
		res << vproto.pack_uint32_field(o.location_type, 1)
	}
	if o.location_id != u64(0) {
		res << vproto.pack_uint64_field(o.location_id, 2)
	}
	return res
}

pub fn cparties_beaconlocation_unpack(buf []byte) ?CParties_BeaconLocation {
	mut res := zzz_vproto_internal_new_cparties_beaconlocation()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.location_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.location_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_BeaconLocation) eq(b CParties_BeaconLocation) bool {
	return true && a.location_type == b.location_type && a.location_id == b.location_id
}

[inline]
pub fn (a CParties_BeaconLocation) ne(b CParties_BeaconLocation) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_BeaconLocation) eq(b []CParties_BeaconLocation) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_BeaconLocation) ne(b []CParties_BeaconLocation) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_beaconlocation() CParties_BeaconLocation {
	return CParties_BeaconLocation{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_beaconlocation(o CParties_BeaconLocation, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_beaconlocation(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_BeaconLocation) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_beaconlocation_unpack(v) ?
	return i, unpacked
}

pub struct CParties_CreateBeacon_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	num_open_slots u32
	locations      []CParties_BeaconLocation
	connect_string string
	metadata       string
}

pub fn (o &CParties_CreateBeacon_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.num_open_slots != u32(0) {
		res << vproto.pack_uint32_field(o.num_open_slots, 2)
	}
	// [packed=false]
	for _, x in o.locations {
		res << zzz_vproto_internal_pack_cparties_beaconlocation(x, 3)
	}
	if o.connect_string != '' {
		res << vproto.pack_string_field(o.connect_string, 4)
	}
	if o.metadata != '' {
		res << vproto.pack_string_field(o.metadata, 5)
	}
	return res
}

pub fn cparties_createbeacon_request_unpack(buf []byte) ?CParties_CreateBeacon_Request {
	mut res := zzz_vproto_internal_new_cparties_createbeacon_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.num_open_slots = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cparties_beaconlocation(cur_buf, tag_wiretype.wire_type) ?
				res.locations << v
				i = ii
			}
			4 {
				i, res.connect_string = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.metadata = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_CreateBeacon_Request) eq(b CParties_CreateBeacon_Request) bool {
	return true && a.appid == b.appid && a.num_open_slots == b.num_open_slots && a.locations.eq(b.locations) &&
		a.connect_string == b.connect_string && a.metadata == b.metadata
}

[inline]
pub fn (a CParties_CreateBeacon_Request) ne(b CParties_CreateBeacon_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_CreateBeacon_Request) eq(b []CParties_CreateBeacon_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_CreateBeacon_Request) ne(b []CParties_CreateBeacon_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_createbeacon_request() CParties_CreateBeacon_Request {
	return CParties_CreateBeacon_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_createbeacon_request(o CParties_CreateBeacon_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_createbeacon_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_CreateBeacon_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_createbeacon_request_unpack(v) ?
	return i, unpacked
}

pub struct CParties_CreateBeacon_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
}

pub fn (o &CParties_CreateBeacon_Response) pack() []byte {
	mut res := []byte{}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cparties_createbeacon_response_unpack(buf []byte) ?CParties_CreateBeacon_Response {
	mut res := zzz_vproto_internal_new_cparties_createbeacon_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_CreateBeacon_Response) eq(b CParties_CreateBeacon_Response) bool {
	return true && a.beacon_id == b.beacon_id
}

[inline]
pub fn (a CParties_CreateBeacon_Response) ne(b CParties_CreateBeacon_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_CreateBeacon_Response) eq(b []CParties_CreateBeacon_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_CreateBeacon_Response) ne(b []CParties_CreateBeacon_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_createbeacon_response() CParties_CreateBeacon_Response {
	return CParties_CreateBeacon_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_createbeacon_response(o CParties_CreateBeacon_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_createbeacon_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_CreateBeacon_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_createbeacon_response_unpack(v) ?
	return i, unpacked
}

pub struct CParties_OnReservationCompleted_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
	user_steamid   u64
}

pub fn (o &CParties_OnReservationCompleted_Request) pack() []byte {
	mut res := []byte{}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	if o.user_steamid != u64(0) {
		res << vproto.pack_64bit_field(o.user_steamid, 2)
	}
	return res
}

pub fn cparties_onreservationcompleted_request_unpack(buf []byte) ?CParties_OnReservationCompleted_Request {
	mut res := zzz_vproto_internal_new_cparties_onreservationcompleted_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.user_steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_OnReservationCompleted_Request) eq(b CParties_OnReservationCompleted_Request) bool {
	return true && a.beacon_id == b.beacon_id && a.user_steamid == b.user_steamid
}

[inline]
pub fn (a CParties_OnReservationCompleted_Request) ne(b CParties_OnReservationCompleted_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_OnReservationCompleted_Request) eq(b []CParties_OnReservationCompleted_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_OnReservationCompleted_Request) ne(b []CParties_OnReservationCompleted_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_onreservationcompleted_request() CParties_OnReservationCompleted_Request {
	return CParties_OnReservationCompleted_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_onreservationcompleted_request(o CParties_OnReservationCompleted_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_onreservationcompleted_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_OnReservationCompleted_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_onreservationcompleted_request_unpack(v) ?
	return i, unpacked
}

pub struct CParties_OnReservationCompleted_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
}

pub fn (o &CParties_OnReservationCompleted_Response) pack() []byte {
	mut res := []byte{}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cparties_onreservationcompleted_response_unpack(buf []byte) ?CParties_OnReservationCompleted_Response {
	mut res := zzz_vproto_internal_new_cparties_onreservationcompleted_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_OnReservationCompleted_Response) eq(b CParties_OnReservationCompleted_Response) bool {
	return true && a.beacon_id == b.beacon_id
}

[inline]
pub fn (a CParties_OnReservationCompleted_Response) ne(b CParties_OnReservationCompleted_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_OnReservationCompleted_Response) eq(b []CParties_OnReservationCompleted_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_OnReservationCompleted_Response) ne(b []CParties_OnReservationCompleted_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_onreservationcompleted_response() CParties_OnReservationCompleted_Response {
	return CParties_OnReservationCompleted_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_onreservationcompleted_response(o CParties_OnReservationCompleted_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_onreservationcompleted_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_OnReservationCompleted_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_onreservationcompleted_response_unpack(v) ?
	return i, unpacked
}

pub struct CParties_CancelReservation_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
	user_steamid   u64
}

pub fn (o &CParties_CancelReservation_Request) pack() []byte {
	mut res := []byte{}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	if o.user_steamid != u64(0) {
		res << vproto.pack_64bit_field(o.user_steamid, 2)
	}
	return res
}

pub fn cparties_cancelreservation_request_unpack(buf []byte) ?CParties_CancelReservation_Request {
	mut res := zzz_vproto_internal_new_cparties_cancelreservation_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.user_steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_CancelReservation_Request) eq(b CParties_CancelReservation_Request) bool {
	return true && a.beacon_id == b.beacon_id && a.user_steamid == b.user_steamid
}

[inline]
pub fn (a CParties_CancelReservation_Request) ne(b CParties_CancelReservation_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_CancelReservation_Request) eq(b []CParties_CancelReservation_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_CancelReservation_Request) ne(b []CParties_CancelReservation_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_cancelreservation_request() CParties_CancelReservation_Request {
	return CParties_CancelReservation_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_cancelreservation_request(o CParties_CancelReservation_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_cancelreservation_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_CancelReservation_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_cancelreservation_request_unpack(v) ?
	return i, unpacked
}

pub struct CParties_CancelReservation_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
}

pub fn (o &CParties_CancelReservation_Response) pack() []byte {
	mut res := []byte{}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cparties_cancelreservation_response_unpack(buf []byte) ?CParties_CancelReservation_Response {
	mut res := zzz_vproto_internal_new_cparties_cancelreservation_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_CancelReservation_Response) eq(b CParties_CancelReservation_Response) bool {
	return true && a.beacon_id == b.beacon_id
}

[inline]
pub fn (a CParties_CancelReservation_Response) ne(b CParties_CancelReservation_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_CancelReservation_Response) eq(b []CParties_CancelReservation_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_CancelReservation_Response) ne(b []CParties_CancelReservation_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_cancelreservation_response() CParties_CancelReservation_Response {
	return CParties_CancelReservation_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_cancelreservation_response(o CParties_CancelReservation_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_cancelreservation_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_CancelReservation_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_cancelreservation_response_unpack(v) ?
	return i, unpacked
}

pub struct CParties_ChangeNumOpenSlots_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
	num_open_slots u32
}

pub fn (o &CParties_ChangeNumOpenSlots_Request) pack() []byte {
	mut res := []byte{}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	if o.num_open_slots != u32(0) {
		res << vproto.pack_uint32_field(o.num_open_slots, 2)
	}
	return res
}

pub fn cparties_changenumopenslots_request_unpack(buf []byte) ?CParties_ChangeNumOpenSlots_Request {
	mut res := zzz_vproto_internal_new_cparties_changenumopenslots_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.num_open_slots = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_ChangeNumOpenSlots_Request) eq(b CParties_ChangeNumOpenSlots_Request) bool {
	return true && a.beacon_id == b.beacon_id && a.num_open_slots == b.num_open_slots
}

[inline]
pub fn (a CParties_ChangeNumOpenSlots_Request) ne(b CParties_ChangeNumOpenSlots_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_ChangeNumOpenSlots_Request) eq(b []CParties_ChangeNumOpenSlots_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_ChangeNumOpenSlots_Request) ne(b []CParties_ChangeNumOpenSlots_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_changenumopenslots_request() CParties_ChangeNumOpenSlots_Request {
	return CParties_ChangeNumOpenSlots_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_changenumopenslots_request(o CParties_ChangeNumOpenSlots_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_changenumopenslots_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_ChangeNumOpenSlots_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_changenumopenslots_request_unpack(v) ?
	return i, unpacked
}

pub struct CParties_ChangeNumOpenSlots_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
}

pub fn (o &CParties_ChangeNumOpenSlots_Response) pack() []byte {
	mut res := []byte{}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cparties_changenumopenslots_response_unpack(buf []byte) ?CParties_ChangeNumOpenSlots_Response {
	mut res := zzz_vproto_internal_new_cparties_changenumopenslots_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_ChangeNumOpenSlots_Response) eq(b CParties_ChangeNumOpenSlots_Response) bool {
	return true && a.beacon_id == b.beacon_id
}

[inline]
pub fn (a CParties_ChangeNumOpenSlots_Response) ne(b CParties_ChangeNumOpenSlots_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_ChangeNumOpenSlots_Response) eq(b []CParties_ChangeNumOpenSlots_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_ChangeNumOpenSlots_Response) ne(b []CParties_ChangeNumOpenSlots_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_changenumopenslots_response() CParties_ChangeNumOpenSlots_Response {
	return CParties_ChangeNumOpenSlots_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_changenumopenslots_response(o CParties_ChangeNumOpenSlots_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_changenumopenslots_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_ChangeNumOpenSlots_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_changenumopenslots_response_unpack(v) ?
	return i, unpacked
}

pub struct CParties_DestroyBeacon_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
}

pub fn (o &CParties_DestroyBeacon_Request) pack() []byte {
	mut res := []byte{}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cparties_destroybeacon_request_unpack(buf []byte) ?CParties_DestroyBeacon_Request {
	mut res := zzz_vproto_internal_new_cparties_destroybeacon_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_DestroyBeacon_Request) eq(b CParties_DestroyBeacon_Request) bool {
	return true && a.beacon_id == b.beacon_id
}

[inline]
pub fn (a CParties_DestroyBeacon_Request) ne(b CParties_DestroyBeacon_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_DestroyBeacon_Request) eq(b []CParties_DestroyBeacon_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_DestroyBeacon_Request) ne(b []CParties_DestroyBeacon_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_destroybeacon_request() CParties_DestroyBeacon_Request {
	return CParties_DestroyBeacon_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_destroybeacon_request(o CParties_DestroyBeacon_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_destroybeacon_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_DestroyBeacon_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_destroybeacon_request_unpack(v) ?
	return i, unpacked
}

pub struct CParties_DestroyBeacon_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
}

pub fn (o &CParties_DestroyBeacon_Response) pack() []byte {
	mut res := []byte{}
	if o.beacon_id != u64(0) {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cparties_destroybeacon_response_unpack(buf []byte) ?CParties_DestroyBeacon_Response {
	mut res := zzz_vproto_internal_new_cparties_destroybeacon_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.beacon_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParties_DestroyBeacon_Response) eq(b CParties_DestroyBeacon_Response) bool {
	return true && a.beacon_id == b.beacon_id
}

[inline]
pub fn (a CParties_DestroyBeacon_Response) ne(b CParties_DestroyBeacon_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParties_DestroyBeacon_Response) eq(b []CParties_DestroyBeacon_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParties_DestroyBeacon_Response) ne(b []CParties_DestroyBeacon_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparties_destroybeacon_response() CParties_DestroyBeacon_Response {
	return CParties_DestroyBeacon_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparties_destroybeacon_response(o CParties_DestroyBeacon_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparties_destroybeacon_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParties_DestroyBeacon_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparties_destroybeacon_response_unpack(v) ?
	return i, unpacked
}
