// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CMsgClientSiteInfo {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	site_id                  u64
	site_name                string
	allow_cached_credentials bool
}

pub fn (o &CMsgClientSiteInfo) pack() []byte {
	mut res := []byte{}
	if o.site_id != u64(0) {
		res << vproto.pack_uint64_field(o.site_id, 1)
	}
	if o.site_name != '' {
		res << vproto.pack_string_field(o.site_name, 2)
	}
	if o.allow_cached_credentials != false {
		res << vproto.pack_bool_field(o.allow_cached_credentials, 3)
	}
	return res
}

pub fn cmsgclientsiteinfo_unpack(buf []byte) ?CMsgClientSiteInfo {
	mut res := zzz_vproto_internal_new_cmsgclientsiteinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.site_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.site_name = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.allow_cached_credentials = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSiteInfo) eq(b CMsgClientSiteInfo) bool {
	return true && a.site_id == b.site_id && a.site_name == b.site_name && a.allow_cached_credentials ==
		b.allow_cached_credentials
}

[inline]
pub fn (a CMsgClientSiteInfo) ne(b CMsgClientSiteInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSiteInfo) eq(b []CMsgClientSiteInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSiteInfo) ne(b []CMsgClientSiteInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsiteinfo() CMsgClientSiteInfo {
	return CMsgClientSiteInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsiteinfo(o CMsgClientSiteInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsiteinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSiteInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsiteinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSiteLicenseCheckout {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
}

pub fn (o &CMsgClientSiteLicenseCheckout) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cmsgclientsitelicensecheckout_unpack(buf []byte) ?CMsgClientSiteLicenseCheckout {
	mut res := zzz_vproto_internal_new_cmsgclientsitelicensecheckout()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSiteLicenseCheckout) eq(b CMsgClientSiteLicenseCheckout) bool {
	return true && a.appid == b.appid
}

[inline]
pub fn (a CMsgClientSiteLicenseCheckout) ne(b CMsgClientSiteLicenseCheckout) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSiteLicenseCheckout) eq(b []CMsgClientSiteLicenseCheckout) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSiteLicenseCheckout) ne(b []CMsgClientSiteLicenseCheckout) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsitelicensecheckout() CMsgClientSiteLicenseCheckout {
	return CMsgClientSiteLicenseCheckout{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsitelicensecheckout(o CMsgClientSiteLicenseCheckout, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsitelicensecheckout(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSiteLicenseCheckout) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsitelicensecheckout_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSiteLicenseCheckoutResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
}

pub fn (o &CMsgClientSiteLicenseCheckoutResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientsitelicensecheckoutresponse_unpack(buf []byte) ?CMsgClientSiteLicenseCheckoutResponse {
	mut res := zzz_vproto_internal_new_cmsgclientsitelicensecheckoutresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSiteLicenseCheckoutResponse) eq(b CMsgClientSiteLicenseCheckoutResponse) bool {
	return true && a.eresult == b.eresult
}

[inline]
pub fn (a CMsgClientSiteLicenseCheckoutResponse) ne(b CMsgClientSiteLicenseCheckoutResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSiteLicenseCheckoutResponse) eq(b []CMsgClientSiteLicenseCheckoutResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSiteLicenseCheckoutResponse) ne(b []CMsgClientSiteLicenseCheckoutResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsitelicensecheckoutresponse() CMsgClientSiteLicenseCheckoutResponse {
	return CMsgClientSiteLicenseCheckoutResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsitelicensecheckoutresponse(o CMsgClientSiteLicenseCheckoutResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsitelicensecheckoutresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSiteLicenseCheckoutResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsitelicensecheckoutresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSiteLicenseGetAvailableSeats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
}

pub fn (o &CMsgClientSiteLicenseGetAvailableSeats) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cmsgclientsitelicensegetavailableseats_unpack(buf []byte) ?CMsgClientSiteLicenseGetAvailableSeats {
	mut res := zzz_vproto_internal_new_cmsgclientsitelicensegetavailableseats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSiteLicenseGetAvailableSeats) eq(b CMsgClientSiteLicenseGetAvailableSeats) bool {
	return true && a.appid == b.appid
}

[inline]
pub fn (a CMsgClientSiteLicenseGetAvailableSeats) ne(b CMsgClientSiteLicenseGetAvailableSeats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSiteLicenseGetAvailableSeats) eq(b []CMsgClientSiteLicenseGetAvailableSeats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSiteLicenseGetAvailableSeats) ne(b []CMsgClientSiteLicenseGetAvailableSeats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsitelicensegetavailableseats() CMsgClientSiteLicenseGetAvailableSeats {
	return CMsgClientSiteLicenseGetAvailableSeats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsitelicensegetavailableseats(o CMsgClientSiteLicenseGetAvailableSeats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsitelicensegetavailableseats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSiteLicenseGetAvailableSeats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsitelicensegetavailableseats_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSiteLicenseGetAvailableSeatsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	seats          u32
}

pub fn (o &CMsgClientSiteLicenseGetAvailableSeatsResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.seats != u32(0) {
		res << vproto.pack_uint32_field(o.seats, 2)
	}
	return res
}

pub fn cmsgclientsitelicensegetavailableseatsresponse_unpack(buf []byte) ?CMsgClientSiteLicenseGetAvailableSeatsResponse {
	mut res := zzz_vproto_internal_new_cmsgclientsitelicensegetavailableseatsresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
				res.eresult = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seats = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSiteLicenseGetAvailableSeatsResponse) eq(b CMsgClientSiteLicenseGetAvailableSeatsResponse) bool {
	return true && a.eresult == b.eresult && a.seats == b.seats
}

[inline]
pub fn (a CMsgClientSiteLicenseGetAvailableSeatsResponse) ne(b CMsgClientSiteLicenseGetAvailableSeatsResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSiteLicenseGetAvailableSeatsResponse) eq(b []CMsgClientSiteLicenseGetAvailableSeatsResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSiteLicenseGetAvailableSeatsResponse) ne(b []CMsgClientSiteLicenseGetAvailableSeatsResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsitelicensegetavailableseatsresponse() CMsgClientSiteLicenseGetAvailableSeatsResponse {
	return CMsgClientSiteLicenseGetAvailableSeatsResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsitelicensegetavailableseatsresponse(o CMsgClientSiteLicenseGetAvailableSeatsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsitelicensegetavailableseatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSiteLicenseGetAvailableSeatsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsitelicensegetavailableseatsresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSiteLicenseGetContentCacheInfo {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientSiteLicenseGetContentCacheInfo) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientsitelicensegetcontentcacheinfo_unpack(buf []byte) ?CMsgClientSiteLicenseGetContentCacheInfo {
	res := zzz_vproto_internal_new_cmsgclientsitelicensegetcontentcacheinfo()
	return res
}

[inline]
pub fn (a CMsgClientSiteLicenseGetContentCacheInfo) eq(b CMsgClientSiteLicenseGetContentCacheInfo) bool {
	return true
}

[inline]
pub fn (a CMsgClientSiteLicenseGetContentCacheInfo) ne(b CMsgClientSiteLicenseGetContentCacheInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSiteLicenseGetContentCacheInfo) eq(b []CMsgClientSiteLicenseGetContentCacheInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSiteLicenseGetContentCacheInfo) ne(b []CMsgClientSiteLicenseGetContentCacheInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsitelicensegetcontentcacheinfo() CMsgClientSiteLicenseGetContentCacheInfo {
	return CMsgClientSiteLicenseGetContentCacheInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsitelicensegetcontentcacheinfo(o CMsgClientSiteLicenseGetContentCacheInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsitelicensegetcontentcacheinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSiteLicenseGetContentCacheInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsitelicensegetcontentcacheinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSiteLicenseGetContentCacheInfoResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	use_cache      bool
	ipv4_address   u32
	port_number    u32
	p2p_group      u32
	ip_address     string
}

pub fn (o &CMsgClientSiteLicenseGetContentCacheInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.use_cache != false {
		res << vproto.pack_bool_field(o.use_cache, 1)
	}
	if o.ipv4_address != u32(0) {
		res << vproto.pack_uint32_field(o.ipv4_address, 2)
	}
	if o.port_number != u32(0) {
		res << vproto.pack_uint32_field(o.port_number, 3)
	}
	if o.p2p_group != u32(0) {
		res << vproto.pack_uint32_field(o.p2p_group, 4)
	}
	if o.ip_address != '' {
		res << vproto.pack_string_field(o.ip_address, 5)
	}
	return res
}

pub fn cmsgclientsitelicensegetcontentcacheinforesponse_unpack(buf []byte) ?CMsgClientSiteLicenseGetContentCacheInfoResponse {
	mut res := zzz_vproto_internal_new_cmsgclientsitelicensegetcontentcacheinforesponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.use_cache = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ipv4_address = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.port_number = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.p2p_group = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.ip_address = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSiteLicenseGetContentCacheInfoResponse) eq(b CMsgClientSiteLicenseGetContentCacheInfoResponse) bool {
	return true && a.use_cache == b.use_cache && a.ipv4_address == b.ipv4_address && a.port_number ==
		b.port_number && a.p2p_group == b.p2p_group && a.ip_address == b.ip_address
}

[inline]
pub fn (a CMsgClientSiteLicenseGetContentCacheInfoResponse) ne(b CMsgClientSiteLicenseGetContentCacheInfoResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSiteLicenseGetContentCacheInfoResponse) eq(b []CMsgClientSiteLicenseGetContentCacheInfoResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSiteLicenseGetContentCacheInfoResponse) ne(b []CMsgClientSiteLicenseGetContentCacheInfoResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsitelicensegetcontentcacheinforesponse() CMsgClientSiteLicenseGetContentCacheInfoResponse {
	return CMsgClientSiteLicenseGetContentCacheInfoResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsitelicensegetcontentcacheinforesponse(o CMsgClientSiteLicenseGetContentCacheInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsitelicensegetcontentcacheinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSiteLicenseGetContentCacheInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsitelicensegetcontentcacheinforesponse_unpack(v) ?
	return i, unpacked
}
