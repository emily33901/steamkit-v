
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


[_allow_multiple_values]
enum EJSRegisterMethodType {
k_ejsregistermethodtype_invalid = 0
k_ejsregistermethodtype_function = 1
k_ejsregistermethodtype_callback = 2
k_ejsregistermethodtype_promise = 3
}
// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_ejsregistermethodtype() EJSRegisterMethodType {
return .k_ejsregistermethodtype_invalid
}
// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_ejsregistermethodtype(e EJSRegisterMethodType, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_ejsregistermethodtype_packed(e []EJSRegisterMethodType, num u32) []byte {
x := array{data: e.data, len: e.len, element_size: e.element_size, cap: e.cap}
return vproto.pack_int32_field_packed(x, num)
}
// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_ejsregistermethodtype(buf []byte, tag_wiretype vproto.WireType) ?(int, EJSRegisterMethodType) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EJSRegisterMethodType(v)
}
// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_ejsregistermethodtype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EJSRegisterMethodType) {
i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
return i, array {data: v.data, len: v.len, cap: v.cap, element_size: v.element_size}
}
pub struct CMsgKeyUp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
keycode u32
modifiers u32
nativekeycode u32
}
pub fn (o &CMsgKeyUp) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.keycode != u32(0) {
res << vproto.pack_uint32_field(o.keycode, 2)
}

if o.modifiers != u32(0) {
res << vproto.pack_uint32_field(o.modifiers, 3)
}

if o.nativekeycode != u32(0) {
res << vproto.pack_uint32_field(o.nativekeycode, 4)
}

return res
}

pub fn cmsgkeyup_unpack(buf []byte) ?CMsgKeyUp {
mut res := zzz_vproto_internal_new_cmsgkeyup()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.keycode = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.modifiers = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.nativekeycode = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgKeyUp) eq(b CMsgKeyUp) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.keycode == b.keycode
&& a.modifiers == b.modifiers
&& a.nativekeycode == b.nativekeycode
}
	[inline]
	pub fn (a CMsgKeyUp) ne(b CMsgKeyUp) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgKeyUp) eq(b []CMsgKeyUp) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgKeyUp) ne(b []CMsgKeyUp) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgkeyup() CMsgKeyUp {
			return CMsgKeyUp{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgkeyup(o CMsgKeyUp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgkeyup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgKeyUp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgkeyup_unpack(v)?
return i, unpacked
}
pub struct CMsgKeyDown {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
keycode u32
modifiers u32
is_system_key bool
nativekeycode u32
}
pub fn (o &CMsgKeyDown) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.keycode != u32(0) {
res << vproto.pack_uint32_field(o.keycode, 2)
}

if o.modifiers != u32(0) {
res << vproto.pack_uint32_field(o.modifiers, 3)
}

if o.is_system_key != false {
res << vproto.pack_bool_field(o.is_system_key, 4)
}

if o.nativekeycode != u32(0) {
res << vproto.pack_uint32_field(o.nativekeycode, 5)
}

return res
}

pub fn cmsgkeydown_unpack(buf []byte) ?CMsgKeyDown {
mut res := zzz_vproto_internal_new_cmsgkeydown()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.keycode = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.modifiers = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.is_system_key = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.nativekeycode = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgKeyDown) eq(b CMsgKeyDown) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.keycode == b.keycode
&& a.modifiers == b.modifiers
&& a.is_system_key == b.is_system_key
&& a.nativekeycode == b.nativekeycode
}
	[inline]
	pub fn (a CMsgKeyDown) ne(b CMsgKeyDown) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgKeyDown) eq(b []CMsgKeyDown) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgKeyDown) ne(b []CMsgKeyDown) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgkeydown() CMsgKeyDown {
			return CMsgKeyDown{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgkeydown(o CMsgKeyDown, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgkeydown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgKeyDown) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgkeydown_unpack(v)?
return i, unpacked
}
pub struct CMsgKeyChar {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
unichar u32
modifiers u32
keycode u32
nativekeycode u32
}
pub fn (o &CMsgKeyChar) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.unichar != u32(0) {
res << vproto.pack_uint32_field(o.unichar, 2)
}

if o.modifiers != u32(0) {
res << vproto.pack_uint32_field(o.modifiers, 3)
}

if o.keycode != u32(0) {
res << vproto.pack_uint32_field(o.keycode, 4)
}

if o.nativekeycode != u32(0) {
res << vproto.pack_uint32_field(o.nativekeycode, 5)
}

return res
}

pub fn cmsgkeychar_unpack(buf []byte) ?CMsgKeyChar {
mut res := zzz_vproto_internal_new_cmsgkeychar()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.unichar = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.modifiers = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.keycode = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.nativekeycode = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgKeyChar) eq(b CMsgKeyChar) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.unichar == b.unichar
&& a.modifiers == b.modifiers
&& a.keycode == b.keycode
&& a.nativekeycode == b.nativekeycode
}
	[inline]
	pub fn (a CMsgKeyChar) ne(b CMsgKeyChar) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgKeyChar) eq(b []CMsgKeyChar) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgKeyChar) ne(b []CMsgKeyChar) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgkeychar() CMsgKeyChar {
			return CMsgKeyChar{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgkeychar(o CMsgKeyChar, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgkeychar(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgKeyChar) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgkeychar_unpack(v)?
return i, unpacked
}
pub struct CMsgMouseDown {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
mouse_button u32
modifiers u32
}
pub fn (o &CMsgMouseDown) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.mouse_button != u32(0) {
res << vproto.pack_uint32_field(o.mouse_button, 2)
}

if o.modifiers != u32(0) {
res << vproto.pack_uint32_field(o.modifiers, 3)
}

return res
}

pub fn cmsgmousedown_unpack(buf []byte) ?CMsgMouseDown {
mut res := zzz_vproto_internal_new_cmsgmousedown()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.mouse_button = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.modifiers = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgMouseDown) eq(b CMsgMouseDown) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.mouse_button == b.mouse_button
&& a.modifiers == b.modifiers
}
	[inline]
	pub fn (a CMsgMouseDown) ne(b CMsgMouseDown) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgMouseDown) eq(b []CMsgMouseDown) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgMouseDown) ne(b []CMsgMouseDown) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgmousedown() CMsgMouseDown {
			return CMsgMouseDown{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmousedown(o CMsgMouseDown, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmousedown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseDown) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgmousedown_unpack(v)?
return i, unpacked
}
pub struct CMsgMouseUp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
mouse_button u32
modifiers u32
is_off_panel bool
x int
y int
}
pub fn (o &CMsgMouseUp) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.mouse_button != u32(0) {
res << vproto.pack_uint32_field(o.mouse_button, 2)
}

if o.modifiers != u32(0) {
res << vproto.pack_uint32_field(o.modifiers, 3)
}

if o.is_off_panel != false {
res << vproto.pack_bool_field(o.is_off_panel, 4)
}

if o.x != int(0) {
res << vproto.pack_int32_field(o.x, 5)
}

if o.y != int(0) {
res << vproto.pack_int32_field(o.y, 6)
}

return res
}

pub fn cmsgmouseup_unpack(buf []byte) ?CMsgMouseUp {
mut res := zzz_vproto_internal_new_cmsgmouseup()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.mouse_button = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.modifiers = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.is_off_panel = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.x = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.y = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgMouseUp) eq(b CMsgMouseUp) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.mouse_button == b.mouse_button
&& a.modifiers == b.modifiers
&& a.is_off_panel == b.is_off_panel
&& a.x == b.x
&& a.y == b.y
}
	[inline]
	pub fn (a CMsgMouseUp) ne(b CMsgMouseUp) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgMouseUp) eq(b []CMsgMouseUp) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgMouseUp) ne(b []CMsgMouseUp) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgmouseup() CMsgMouseUp {
			return CMsgMouseUp{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmouseup(o CMsgMouseUp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmouseup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseUp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgmouseup_unpack(v)?
return i, unpacked
}
pub struct CMsgMouseDblClick {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
mouse_button u32
modifiers u32
}
pub fn (o &CMsgMouseDblClick) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.mouse_button != u32(0) {
res << vproto.pack_uint32_field(o.mouse_button, 2)
}

if o.modifiers != u32(0) {
res << vproto.pack_uint32_field(o.modifiers, 3)
}

return res
}

pub fn cmsgmousedblclick_unpack(buf []byte) ?CMsgMouseDblClick {
mut res := zzz_vproto_internal_new_cmsgmousedblclick()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.mouse_button = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.modifiers = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgMouseDblClick) eq(b CMsgMouseDblClick) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.mouse_button == b.mouse_button
&& a.modifiers == b.modifiers
}
	[inline]
	pub fn (a CMsgMouseDblClick) ne(b CMsgMouseDblClick) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgMouseDblClick) eq(b []CMsgMouseDblClick) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgMouseDblClick) ne(b []CMsgMouseDblClick) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgmousedblclick() CMsgMouseDblClick {
			return CMsgMouseDblClick{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmousedblclick(o CMsgMouseDblClick, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmousedblclick(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseDblClick) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgmousedblclick_unpack(v)?
return i, unpacked
}
pub struct CMsgMouseWheel {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
deltax int
deltay int
modifiers u32
}
pub fn (o &CMsgMouseWheel) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.deltax != int(0) {
res << vproto.pack_int32_field(o.deltax, 2)
}

if o.deltay != int(0) {
res << vproto.pack_int32_field(o.deltay, 3)
}

if o.modifiers != u32(0) {
res << vproto.pack_uint32_field(o.modifiers, 4)
}

return res
}

pub fn cmsgmousewheel_unpack(buf []byte) ?CMsgMouseWheel {
mut res := zzz_vproto_internal_new_cmsgmousewheel()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.deltax = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.deltay = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.modifiers = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgMouseWheel) eq(b CMsgMouseWheel) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.deltax == b.deltax
&& a.deltay == b.deltay
&& a.modifiers == b.modifiers
}
	[inline]
	pub fn (a CMsgMouseWheel) ne(b CMsgMouseWheel) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgMouseWheel) eq(b []CMsgMouseWheel) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgMouseWheel) ne(b []CMsgMouseWheel) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgmousewheel() CMsgMouseWheel {
			return CMsgMouseWheel{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmousewheel(o CMsgMouseWheel, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmousewheel(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseWheel) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgmousewheel_unpack(v)?
return i, unpacked
}
pub struct CMsgMouseMove {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
x int
y int
modifiers u32
}
pub fn (o &CMsgMouseMove) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.x != int(0) {
res << vproto.pack_int32_field(o.x, 2)
}

if o.y != int(0) {
res << vproto.pack_int32_field(o.y, 3)
}

if o.modifiers != u32(0) {
res << vproto.pack_uint32_field(o.modifiers, 4)
}

return res
}

pub fn cmsgmousemove_unpack(buf []byte) ?CMsgMouseMove {
mut res := zzz_vproto_internal_new_cmsgmousemove()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.x = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.y = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.modifiers = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgMouseMove) eq(b CMsgMouseMove) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.x == b.x
&& a.y == b.y
&& a.modifiers == b.modifiers
}
	[inline]
	pub fn (a CMsgMouseMove) ne(b CMsgMouseMove) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgMouseMove) eq(b []CMsgMouseMove) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgMouseMove) ne(b []CMsgMouseMove) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgmousemove() CMsgMouseMove {
			return CMsgMouseMove{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmousemove(o CMsgMouseMove, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmousemove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseMove) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgmousemove_unpack(v)?
return i, unpacked
}
pub struct CMsgMouseLeave {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgMouseLeave) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgmouseleave_unpack(buf []byte) ?CMsgMouseLeave {
mut res := zzz_vproto_internal_new_cmsgmouseleave()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgMouseLeave) eq(b CMsgMouseLeave) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgMouseLeave) ne(b CMsgMouseLeave) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgMouseLeave) eq(b []CMsgMouseLeave) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgMouseLeave) ne(b []CMsgMouseLeave) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgmouseleave() CMsgMouseLeave {
			return CMsgMouseLeave{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmouseleave(o CMsgMouseLeave, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmouseleave(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseLeave) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgmouseleave_unpack(v)?
return i, unpacked
}
pub struct CMsgBrowserCreate {
mut:
unknown_fields []vproto.UnknownField
pub mut:
request_id u32
useragent string
user_css string
native_dropdowns bool
dpi_scaling f32
offscreen bool
 = true
initial_width u32
initial_height u32
window_icon string
borderless bool
vroverlay_key string
browser_type u32
initial_top int
 = -2147483648
initial_left int
 = -2147483648
only_allow_trusted_popups bool
initial_url string
hwnd_parent u64
}
pub fn (o &CMsgBrowserCreate) pack() []byte {
mut res := []byte{}
if o.request_id != u32(0) {
res << vproto.pack_uint32_field(o.request_id, 1)
}

if o.useragent != '' {
res << vproto.pack_string_field(o.useragent, 3)
}

if o.user_css != '' {
res << vproto.pack_string_field(o.user_css, 5)
}

if o.native_dropdowns != false {
res << vproto.pack_bool_field(o.native_dropdowns, 6)
}

if o.dpi_scaling != f32(0) {
res << vproto.pack_float_field(o.dpi_scaling, 7)
}

if o.offscreen != false {
res << vproto.pack_bool_field(o.offscreen, 8)
}

if o.initial_width != u32(0) {
res << vproto.pack_uint32_field(o.initial_width, 9)
}

if o.initial_height != u32(0) {
res << vproto.pack_uint32_field(o.initial_height, 10)
}

if o.window_icon != '' {
res << vproto.pack_string_field(o.window_icon, 11)
}

if o.borderless != false {
res << vproto.pack_bool_field(o.borderless, 12)
}

if o.vroverlay_key != '' {
res << vproto.pack_string_field(o.vroverlay_key, 13)
}

if o.browser_type != u32(0) {
res << vproto.pack_uint32_field(o.browser_type, 14)
}

if o.initial_top != int(0) {
res << vproto.pack_int32_field(o.initial_top, 15)
}

if o.initial_left != int(0) {
res << vproto.pack_int32_field(o.initial_left, 16)
}

if o.only_allow_trusted_popups != false {
res << vproto.pack_bool_field(o.only_allow_trusted_popups, 17)
}

if o.initial_url != '' {
res << vproto.pack_string_field(o.initial_url, 18)
}

if o.hwnd_parent != u64(0) {
res << vproto.pack_64bit_field(o.hwnd_parent, 19)
}

return res
}

pub fn cmsgbrowsercreate_unpack(buf []byte) ?CMsgBrowserCreate {
mut res := zzz_vproto_internal_new_cmsgbrowsercreate()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.request_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.useragent = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.user_css = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.native_dropdowns = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.dpi_scaling = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

8 {
i, res.offscreen = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

9 {
i, res.initial_width = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

10 {
i, res.initial_height = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

11 {
i, res.window_icon = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

12 {
i, res.borderless = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

13 {
i, res.vroverlay_key = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

14 {
i, res.browser_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

15 {
i, res.initial_top = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

16 {
i, res.initial_left = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

17 {
i, res.only_allow_trusted_popups = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

18 {
i, res.initial_url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

19 {
i, res.hwnd_parent = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBrowserCreate) eq(b CMsgBrowserCreate) bool {
		return true
&& a.request_id == b.request_id
&& a.useragent == b.useragent
&& a.user_css == b.user_css
&& a.native_dropdowns == b.native_dropdowns
&& a.dpi_scaling == b.dpi_scaling
&& a.offscreen == b.offscreen
&& a.initial_width == b.initial_width
&& a.initial_height == b.initial_height
&& a.window_icon == b.window_icon
&& a.borderless == b.borderless
&& a.vroverlay_key == b.vroverlay_key
&& a.browser_type == b.browser_type
&& a.initial_top == b.initial_top
&& a.initial_left == b.initial_left
&& a.only_allow_trusted_popups == b.only_allow_trusted_popups
&& a.initial_url == b.initial_url
&& a.hwnd_parent == b.hwnd_parent
}
	[inline]
	pub fn (a CMsgBrowserCreate) ne(b CMsgBrowserCreate) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBrowserCreate) eq(b []CMsgBrowserCreate) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBrowserCreate) ne(b []CMsgBrowserCreate) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbrowsercreate() CMsgBrowserCreate {
			return CMsgBrowserCreate{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowsercreate(o CMsgBrowserCreate, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowsercreate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserCreate) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbrowsercreate_unpack(v)?
return i, unpacked
}
pub struct CMsgBrowserCreateResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
request_id u32
}
pub fn (o &CMsgBrowserCreateResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.request_id != u32(0) {
res << vproto.pack_uint32_field(o.request_id, 2)
}

return res
}

pub fn cmsgbrowsercreateresponse_unpack(buf []byte) ?CMsgBrowserCreateResponse {
mut res := zzz_vproto_internal_new_cmsgbrowsercreateresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.request_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBrowserCreateResponse) eq(b CMsgBrowserCreateResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.request_id == b.request_id
}
	[inline]
	pub fn (a CMsgBrowserCreateResponse) ne(b CMsgBrowserCreateResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBrowserCreateResponse) eq(b []CMsgBrowserCreateResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBrowserCreateResponse) ne(b []CMsgBrowserCreateResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbrowsercreateresponse() CMsgBrowserCreateResponse {
			return CMsgBrowserCreateResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowsercreateresponse(o CMsgBrowserCreateResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowsercreateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserCreateResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbrowsercreateresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgBrowserRemove {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgBrowserRemove) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgbrowserremove_unpack(buf []byte) ?CMsgBrowserRemove {
mut res := zzz_vproto_internal_new_cmsgbrowserremove()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBrowserRemove) eq(b CMsgBrowserRemove) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgBrowserRemove) ne(b CMsgBrowserRemove) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBrowserRemove) eq(b []CMsgBrowserRemove) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBrowserRemove) ne(b []CMsgBrowserRemove) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbrowserremove() CMsgBrowserRemove {
			return CMsgBrowserRemove{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowserremove(o CMsgBrowserRemove, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowserremove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserRemove) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbrowserremove_unpack(v)?
return i, unpacked
}
pub struct CMsgSetLocalFileRequestMapping_AdditionalRoute {
mut:
unknown_fields []vproto.UnknownField
pub mut:
relative_url string
local_path string
allowed_extensions string
}
pub fn (o &CMsgSetLocalFileRequestMapping_AdditionalRoute) pack() []byte {
mut res := []byte{}
if o.relative_url != '' {
res << vproto.pack_string_field(o.relative_url, 1)
}

if o.local_path != '' {
res << vproto.pack_string_field(o.local_path, 2)
}

if o.allowed_extensions != '' {
res << vproto.pack_string_field(o.allowed_extensions, 3)
}

return res
}

pub fn cmsgsetlocalfilerequestmapping_additionalroute_unpack(buf []byte) ?CMsgSetLocalFileRequestMapping_AdditionalRoute {
mut res := zzz_vproto_internal_new_cmsgsetlocalfilerequestmapping_additionalroute()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.relative_url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.local_path = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.allowed_extensions = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetLocalFileRequestMapping_AdditionalRoute) eq(b CMsgSetLocalFileRequestMapping_AdditionalRoute) bool {
		return true
&& a.relative_url == b.relative_url
&& a.local_path == b.local_path
&& a.allowed_extensions == b.allowed_extensions
}
	[inline]
	pub fn (a CMsgSetLocalFileRequestMapping_AdditionalRoute) ne(b CMsgSetLocalFileRequestMapping_AdditionalRoute) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetLocalFileRequestMapping_AdditionalRoute) eq(b []CMsgSetLocalFileRequestMapping_AdditionalRoute) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetLocalFileRequestMapping_AdditionalRoute) ne(b []CMsgSetLocalFileRequestMapping_AdditionalRoute) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetlocalfilerequestmapping_additionalroute() CMsgSetLocalFileRequestMapping_AdditionalRoute {
			return CMsgSetLocalFileRequestMapping_AdditionalRoute{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetlocalfilerequestmapping_additionalroute(o CMsgSetLocalFileRequestMapping_AdditionalRoute, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetlocalfilerequestmapping_additionalroute(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetLocalFileRequestMapping_AdditionalRoute) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetlocalfilerequestmapping_additionalroute_unpack(v)?
return i, unpacked
}
pub struct CMsgSetLocalFileRequestMapping {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
request_url string
default_local_path string
routes []CMsgSetLocalFileRequestMapping_AdditionalRoute
}
pub fn (o &CMsgSetLocalFileRequestMapping) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.request_url != '' {
res << vproto.pack_string_field(o.request_url, 2)
}

if o.default_local_path != '' {
res << vproto.pack_string_field(o.default_local_path, 3)
}

// [packed=false]
for _, x in o.routes {
res << zzz_vproto_internal_pack_cmsgsetlocalfilerequestmapping_additionalroute(x, 4)
}

return res
}

pub fn cmsgsetlocalfilerequestmapping_unpack(buf []byte) ?CMsgSetLocalFileRequestMapping {
mut res := zzz_vproto_internal_new_cmsgsetlocalfilerequestmapping()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.request_url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.default_local_path = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsetlocalfilerequestmapping_additionalroute(cur_buf, tag_wiretype.wire_type)?
res.routes << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetLocalFileRequestMapping) eq(b CMsgSetLocalFileRequestMapping) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.request_url == b.request_url
&& a.default_local_path == b.default_local_path
&& a.routes.eq(b.routes)
}
	[inline]
	pub fn (a CMsgSetLocalFileRequestMapping) ne(b CMsgSetLocalFileRequestMapping) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetLocalFileRequestMapping) eq(b []CMsgSetLocalFileRequestMapping) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetLocalFileRequestMapping) ne(b []CMsgSetLocalFileRequestMapping) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetlocalfilerequestmapping() CMsgSetLocalFileRequestMapping {
			return CMsgSetLocalFileRequestMapping{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetlocalfilerequestmapping(o CMsgSetLocalFileRequestMapping, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetlocalfilerequestmapping(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetLocalFileRequestMapping) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetlocalfilerequestmapping_unpack(v)?
return i, unpacked
}
pub struct CMsgBrowserErrorStrings {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
title string
header string
cache_miss string
bad_url string
connection_problem string
proxy_problem string
unknown string
}
pub fn (o &CMsgBrowserErrorStrings) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.title != '' {
res << vproto.pack_string_field(o.title, 2)
}

if o.header != '' {
res << vproto.pack_string_field(o.header, 3)
}

if o.cache_miss != '' {
res << vproto.pack_string_field(o.cache_miss, 4)
}

if o.bad_url != '' {
res << vproto.pack_string_field(o.bad_url, 5)
}

if o.connection_problem != '' {
res << vproto.pack_string_field(o.connection_problem, 6)
}

if o.proxy_problem != '' {
res << vproto.pack_string_field(o.proxy_problem, 7)
}

if o.unknown != '' {
res << vproto.pack_string_field(o.unknown, 8)
}

return res
}

pub fn cmsgbrowsererrorstrings_unpack(buf []byte) ?CMsgBrowserErrorStrings {
mut res := zzz_vproto_internal_new_cmsgbrowsererrorstrings()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.title = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.header = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.cache_miss = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.bad_url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.connection_problem = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.proxy_problem = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

8 {
i, res.unknown = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBrowserErrorStrings) eq(b CMsgBrowserErrorStrings) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.title == b.title
&& a.header == b.header
&& a.cache_miss == b.cache_miss
&& a.bad_url == b.bad_url
&& a.connection_problem == b.connection_problem
&& a.proxy_problem == b.proxy_problem
&& a.unknown == b.unknown
}
	[inline]
	pub fn (a CMsgBrowserErrorStrings) ne(b CMsgBrowserErrorStrings) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBrowserErrorStrings) eq(b []CMsgBrowserErrorStrings) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBrowserErrorStrings) ne(b []CMsgBrowserErrorStrings) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbrowsererrorstrings() CMsgBrowserErrorStrings {
			return CMsgBrowserErrorStrings{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowsererrorstrings(o CMsgBrowserErrorStrings, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowsererrorstrings(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserErrorStrings) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbrowsererrorstrings_unpack(v)?
return i, unpacked
}
pub struct CMsgBrowserSize {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
width u32
height u32
}
pub fn (o &CMsgBrowserSize) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.width != u32(0) {
res << vproto.pack_uint32_field(o.width, 2)
}

if o.height != u32(0) {
res << vproto.pack_uint32_field(o.height, 3)
}

return res
}

pub fn cmsgbrowsersize_unpack(buf []byte) ?CMsgBrowserSize {
mut res := zzz_vproto_internal_new_cmsgbrowsersize()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.width = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.height = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBrowserSize) eq(b CMsgBrowserSize) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.width == b.width
&& a.height == b.height
}
	[inline]
	pub fn (a CMsgBrowserSize) ne(b CMsgBrowserSize) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBrowserSize) eq(b []CMsgBrowserSize) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBrowserSize) ne(b []CMsgBrowserSize) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbrowsersize() CMsgBrowserSize {
			return CMsgBrowserSize{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowsersize(o CMsgBrowserSize, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowsersize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserSize) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbrowsersize_unpack(v)?
return i, unpacked
}
pub struct CMsgBrowserSetMinSize {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
width u32
height u32
}
pub fn (o &CMsgBrowserSetMinSize) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.width != u32(0) {
res << vproto.pack_uint32_field(o.width, 2)
}

if o.height != u32(0) {
res << vproto.pack_uint32_field(o.height, 3)
}

return res
}

pub fn cmsgbrowsersetminsize_unpack(buf []byte) ?CMsgBrowserSetMinSize {
mut res := zzz_vproto_internal_new_cmsgbrowsersetminsize()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.width = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.height = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBrowserSetMinSize) eq(b CMsgBrowserSetMinSize) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.width == b.width
&& a.height == b.height
}
	[inline]
	pub fn (a CMsgBrowserSetMinSize) ne(b CMsgBrowserSetMinSize) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBrowserSetMinSize) eq(b []CMsgBrowserSetMinSize) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBrowserSetMinSize) ne(b []CMsgBrowserSetMinSize) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbrowsersetminsize() CMsgBrowserSetMinSize {
			return CMsgBrowserSetMinSize{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowsersetminsize(o CMsgBrowserSetMinSize, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowsersetminsize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserSetMinSize) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbrowsersetminsize_unpack(v)?
return i, unpacked
}
pub struct CMsgBrowserPosition {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
x int
y int
x_local int
y_local int
}
pub fn (o &CMsgBrowserPosition) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.x != int(0) {
res << vproto.pack_int32_field(o.x, 2)
}

if o.y != int(0) {
res << vproto.pack_int32_field(o.y, 3)
}

if o.x_local != int(0) {
res << vproto.pack_int32_field(o.x_local, 4)
}

if o.y_local != int(0) {
res << vproto.pack_int32_field(o.y_local, 5)
}

return res
}

pub fn cmsgbrowserposition_unpack(buf []byte) ?CMsgBrowserPosition {
mut res := zzz_vproto_internal_new_cmsgbrowserposition()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.x = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.y = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.x_local = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.y_local = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBrowserPosition) eq(b CMsgBrowserPosition) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.x == b.x
&& a.y == b.y
&& a.x_local == b.x_local
&& a.y_local == b.y_local
}
	[inline]
	pub fn (a CMsgBrowserPosition) ne(b CMsgBrowserPosition) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBrowserPosition) eq(b []CMsgBrowserPosition) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBrowserPosition) ne(b []CMsgBrowserPosition) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbrowserposition() CMsgBrowserPosition {
			return CMsgBrowserPosition{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowserposition(o CMsgBrowserPosition, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowserposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserPosition) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbrowserposition_unpack(v)?
return i, unpacked
}
pub struct CMsgBrowserResized {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
x int
y int
width u32
height u32
}
pub fn (o &CMsgBrowserResized) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.x != int(0) {
res << vproto.pack_int32_field(o.x, 2)
}

if o.y != int(0) {
res << vproto.pack_int32_field(o.y, 3)
}

if o.width != u32(0) {
res << vproto.pack_uint32_field(o.width, 4)
}

if o.height != u32(0) {
res << vproto.pack_uint32_field(o.height, 5)
}

return res
}

pub fn cmsgbrowserresized_unpack(buf []byte) ?CMsgBrowserResized {
mut res := zzz_vproto_internal_new_cmsgbrowserresized()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.x = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.y = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.width = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.height = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBrowserResized) eq(b CMsgBrowserResized) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.x == b.x
&& a.y == b.y
&& a.width == b.width
&& a.height == b.height
}
	[inline]
	pub fn (a CMsgBrowserResized) ne(b CMsgBrowserResized) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBrowserResized) eq(b []CMsgBrowserResized) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBrowserResized) ne(b []CMsgBrowserResized) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbrowserresized() CMsgBrowserResized {
			return CMsgBrowserResized{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowserresized(o CMsgBrowserResized, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowserresized(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserResized) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbrowserresized_unpack(v)?
return i, unpacked
}
pub struct CMsgPostURL {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
post string
pageserial u32
}
pub fn (o &CMsgPostURL) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.post != '' {
res << vproto.pack_string_field(o.post, 3)
}

if o.pageserial != u32(0) {
res << vproto.pack_uint32_field(o.pageserial, 4)
}

return res
}

pub fn cmsgposturl_unpack(buf []byte) ?CMsgPostURL {
mut res := zzz_vproto_internal_new_cmsgposturl()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.post = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.pageserial = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgPostURL) eq(b CMsgPostURL) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.post == b.post
&& a.pageserial == b.pageserial
}
	[inline]
	pub fn (a CMsgPostURL) ne(b CMsgPostURL) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgPostURL) eq(b []CMsgPostURL) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgPostURL) ne(b []CMsgPostURL) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgposturl() CMsgPostURL {
			return CMsgPostURL{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgposturl(o CMsgPostURL, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgposturl(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPostURL) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgposturl_unpack(v)?
return i, unpacked
}
pub struct CMsgAddHeader {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
key string
value string
}
pub fn (o &CMsgAddHeader) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.key != '' {
res << vproto.pack_string_field(o.key, 2)
}

if o.value != '' {
res << vproto.pack_string_field(o.value, 3)
}

return res
}

pub fn cmsgaddheader_unpack(buf []byte) ?CMsgAddHeader {
mut res := zzz_vproto_internal_new_cmsgaddheader()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.key = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.value = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgAddHeader) eq(b CMsgAddHeader) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.key == b.key
&& a.value == b.value
}
	[inline]
	pub fn (a CMsgAddHeader) ne(b CMsgAddHeader) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgAddHeader) eq(b []CMsgAddHeader) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgAddHeader) ne(b []CMsgAddHeader) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgaddheader() CMsgAddHeader {
			return CMsgAddHeader{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgaddheader(o CMsgAddHeader, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgaddheader(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAddHeader) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgaddheader_unpack(v)?
return i, unpacked
}
pub struct CMsgStopLoad {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgStopLoad) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgstopload_unpack(buf []byte) ?CMsgStopLoad {
mut res := zzz_vproto_internal_new_cmsgstopload()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgStopLoad) eq(b CMsgStopLoad) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgStopLoad) ne(b CMsgStopLoad) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgStopLoad) eq(b []CMsgStopLoad) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgStopLoad) ne(b []CMsgStopLoad) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgstopload() CMsgStopLoad {
			return CMsgStopLoad{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstopload(o CMsgStopLoad, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstopload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStopLoad) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgstopload_unpack(v)?
return i, unpacked
}
pub struct CMsgReload {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgReload) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgreload_unpack(buf []byte) ?CMsgReload {
mut res := zzz_vproto_internal_new_cmsgreload()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgReload) eq(b CMsgReload) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgReload) ne(b CMsgReload) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgReload) eq(b []CMsgReload) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgReload) ne(b []CMsgReload) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgreload() CMsgReload {
			return CMsgReload{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgreload(o CMsgReload, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgreload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgReload) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgreload_unpack(v)?
return i, unpacked
}
pub struct CMsgGoForward {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgGoForward) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsggoforward_unpack(buf []byte) ?CMsgGoForward {
mut res := zzz_vproto_internal_new_cmsggoforward()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgGoForward) eq(b CMsgGoForward) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgGoForward) ne(b CMsgGoForward) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgGoForward) eq(b []CMsgGoForward) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgGoForward) ne(b []CMsgGoForward) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsggoforward() CMsgGoForward {
			return CMsgGoForward{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggoforward(o CMsgGoForward, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggoforward(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGoForward) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggoforward_unpack(v)?
return i, unpacked
}
pub struct CMsgGoBack {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgGoBack) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsggoback_unpack(buf []byte) ?CMsgGoBack {
mut res := zzz_vproto_internal_new_cmsggoback()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgGoBack) eq(b CMsgGoBack) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgGoBack) ne(b CMsgGoBack) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgGoBack) eq(b []CMsgGoBack) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgGoBack) ne(b []CMsgGoBack) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsggoback() CMsgGoBack {
			return CMsgGoBack{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggoback(o CMsgGoBack, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggoback(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGoBack) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggoback_unpack(v)?
return i, unpacked
}
pub struct CMsgWasHidden {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
hidden bool
}
pub fn (o &CMsgWasHidden) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.hidden != false {
res << vproto.pack_bool_field(o.hidden, 2)
}

return res
}

pub fn cmsgwashidden_unpack(buf []byte) ?CMsgWasHidden {
mut res := zzz_vproto_internal_new_cmsgwashidden()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.hidden = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgWasHidden) eq(b CMsgWasHidden) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.hidden == b.hidden
}
	[inline]
	pub fn (a CMsgWasHidden) ne(b CMsgWasHidden) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgWasHidden) eq(b []CMsgWasHidden) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgWasHidden) ne(b []CMsgWasHidden) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgwashidden() CMsgWasHidden {
			return CMsgWasHidden{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgwashidden(o CMsgWasHidden, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgwashidden(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgWasHidden) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgwashidden_unpack(v)?
return i, unpacked
}
pub struct CMsgClearHistory {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgClearHistory) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgclearhistory_unpack(buf []byte) ?CMsgClearHistory {
mut res := zzz_vproto_internal_new_cmsgclearhistory()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgClearHistory) eq(b CMsgClearHistory) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgClearHistory) ne(b CMsgClearHistory) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgClearHistory) eq(b []CMsgClearHistory) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgClearHistory) ne(b []CMsgClearHistory) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgclearhistory() CMsgClearHistory {
			return CMsgClearHistory{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclearhistory(o CMsgClearHistory, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclearhistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClearHistory) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclearhistory_unpack(v)?
return i, unpacked
}
pub struct CMsgClearAllBrowsingData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgClearAllBrowsingData) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgclearallbrowsingdata_unpack(buf []byte) ?CMsgClearAllBrowsingData {
mut res := zzz_vproto_internal_new_cmsgclearallbrowsingdata()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgClearAllBrowsingData) eq(b CMsgClearAllBrowsingData) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgClearAllBrowsingData) ne(b CMsgClearAllBrowsingData) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgClearAllBrowsingData) eq(b []CMsgClearAllBrowsingData) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgClearAllBrowsingData) ne(b []CMsgClearAllBrowsingData) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgclearallbrowsingdata() CMsgClearAllBrowsingData {
			return CMsgClearAllBrowsingData{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclearallbrowsingdata(o CMsgClearAllBrowsingData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclearallbrowsingdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClearAllBrowsingData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclearallbrowsingdata_unpack(v)?
return i, unpacked
}
pub struct CMsgCopy {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgCopy) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgcopy_unpack(buf []byte) ?CMsgCopy {
mut res := zzz_vproto_internal_new_cmsgcopy()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgCopy) eq(b CMsgCopy) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgCopy) ne(b CMsgCopy) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgCopy) eq(b []CMsgCopy) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgCopy) ne(b []CMsgCopy) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgcopy() CMsgCopy {
			return CMsgCopy{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgcopy(o CMsgCopy, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgcopy(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCopy) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcopy_unpack(v)?
return i, unpacked
}
pub struct CMsgPaste {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgPaste) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgpaste_unpack(buf []byte) ?CMsgPaste {
mut res := zzz_vproto_internal_new_cmsgpaste()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgPaste) eq(b CMsgPaste) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgPaste) ne(b CMsgPaste) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgPaste) eq(b []CMsgPaste) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgPaste) ne(b []CMsgPaste) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgpaste() CMsgPaste {
			return CMsgPaste{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpaste(o CMsgPaste, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpaste(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPaste) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgpaste_unpack(v)?
return i, unpacked
}
pub struct CMsgExecuteJavaScript {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
script string
}
pub fn (o &CMsgExecuteJavaScript) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.script != '' {
res << vproto.pack_string_field(o.script, 2)
}

return res
}

pub fn cmsgexecutejavascript_unpack(buf []byte) ?CMsgExecuteJavaScript {
mut res := zzz_vproto_internal_new_cmsgexecutejavascript()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.script = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgExecuteJavaScript) eq(b CMsgExecuteJavaScript) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.script == b.script
}
	[inline]
	pub fn (a CMsgExecuteJavaScript) ne(b CMsgExecuteJavaScript) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgExecuteJavaScript) eq(b []CMsgExecuteJavaScript) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgExecuteJavaScript) ne(b []CMsgExecuteJavaScript) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgexecutejavascript() CMsgExecuteJavaScript {
			return CMsgExecuteJavaScript{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgexecutejavascript(o CMsgExecuteJavaScript, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgexecutejavascript(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgExecuteJavaScript) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgexecutejavascript_unpack(v)?
return i, unpacked
}
pub struct CMsgSetFocus {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
focus bool
}
pub fn (o &CMsgSetFocus) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.focus != false {
res << vproto.pack_bool_field(o.focus, 2)
}

return res
}

pub fn cmsgsetfocus_unpack(buf []byte) ?CMsgSetFocus {
mut res := zzz_vproto_internal_new_cmsgsetfocus()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.focus = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetFocus) eq(b CMsgSetFocus) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.focus == b.focus
}
	[inline]
	pub fn (a CMsgSetFocus) ne(b CMsgSetFocus) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetFocus) eq(b []CMsgSetFocus) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetFocus) ne(b []CMsgSetFocus) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetfocus() CMsgSetFocus {
			return CMsgSetFocus{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetfocus(o CMsgSetFocus, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetfocus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetFocus) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetfocus_unpack(v)?
return i, unpacked
}
pub struct CMsgHorizontalScrollBarSize {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgHorizontalScrollBarSize) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsghorizontalscrollbarsize_unpack(buf []byte) ?CMsgHorizontalScrollBarSize {
mut res := zzz_vproto_internal_new_cmsghorizontalscrollbarsize()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgHorizontalScrollBarSize) eq(b CMsgHorizontalScrollBarSize) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgHorizontalScrollBarSize) ne(b CMsgHorizontalScrollBarSize) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgHorizontalScrollBarSize) eq(b []CMsgHorizontalScrollBarSize) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgHorizontalScrollBarSize) ne(b []CMsgHorizontalScrollBarSize) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsghorizontalscrollbarsize() CMsgHorizontalScrollBarSize {
			return CMsgHorizontalScrollBarSize{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsghorizontalscrollbarsize(o CMsgHorizontalScrollBarSize, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsghorizontalscrollbarsize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHorizontalScrollBarSize) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsghorizontalscrollbarsize_unpack(v)?
return i, unpacked
}
pub struct CMsgHorizontalScrollBarSizeResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
scroll_max u32
scroll u32
zoom f32
visible bool
page_size u32
}
pub fn (o &CMsgHorizontalScrollBarSizeResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.scroll_max != u32(0) {
res << vproto.pack_uint32_field(o.scroll_max, 6)
}

if o.scroll != u32(0) {
res << vproto.pack_uint32_field(o.scroll, 7)
}

if o.zoom != f32(0) {
res << vproto.pack_float_field(o.zoom, 8)
}

if o.visible != false {
res << vproto.pack_bool_field(o.visible, 9)
}

if o.page_size != u32(0) {
res << vproto.pack_uint32_field(o.page_size, 10)
}

return res
}

pub fn cmsghorizontalscrollbarsizeresponse_unpack(buf []byte) ?CMsgHorizontalScrollBarSizeResponse {
mut res := zzz_vproto_internal_new_cmsghorizontalscrollbarsizeresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.scroll_max = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.scroll = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

8 {
i, res.zoom = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

9 {
i, res.visible = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

10 {
i, res.page_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgHorizontalScrollBarSizeResponse) eq(b CMsgHorizontalScrollBarSizeResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.scroll_max == b.scroll_max
&& a.scroll == b.scroll
&& a.zoom == b.zoom
&& a.visible == b.visible
&& a.page_size == b.page_size
}
	[inline]
	pub fn (a CMsgHorizontalScrollBarSizeResponse) ne(b CMsgHorizontalScrollBarSizeResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgHorizontalScrollBarSizeResponse) eq(b []CMsgHorizontalScrollBarSizeResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgHorizontalScrollBarSizeResponse) ne(b []CMsgHorizontalScrollBarSizeResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsghorizontalscrollbarsizeresponse() CMsgHorizontalScrollBarSizeResponse {
			return CMsgHorizontalScrollBarSizeResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsghorizontalscrollbarsizeresponse(o CMsgHorizontalScrollBarSizeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsghorizontalscrollbarsizeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHorizontalScrollBarSizeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsghorizontalscrollbarsizeresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgVerticalScrollBarSize {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgVerticalScrollBarSize) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgverticalscrollbarsize_unpack(buf []byte) ?CMsgVerticalScrollBarSize {
mut res := zzz_vproto_internal_new_cmsgverticalscrollbarsize()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgVerticalScrollBarSize) eq(b CMsgVerticalScrollBarSize) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgVerticalScrollBarSize) ne(b CMsgVerticalScrollBarSize) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgVerticalScrollBarSize) eq(b []CMsgVerticalScrollBarSize) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgVerticalScrollBarSize) ne(b []CMsgVerticalScrollBarSize) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgverticalscrollbarsize() CMsgVerticalScrollBarSize {
			return CMsgVerticalScrollBarSize{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgverticalscrollbarsize(o CMsgVerticalScrollBarSize, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgverticalscrollbarsize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgVerticalScrollBarSize) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgverticalscrollbarsize_unpack(v)?
return i, unpacked
}
pub struct CMsgVerticalScrollBarSizeResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
scroll_max u32
scroll u32
zoom f32
visible bool
page_size u32
}
pub fn (o &CMsgVerticalScrollBarSizeResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.scroll_max != u32(0) {
res << vproto.pack_uint32_field(o.scroll_max, 6)
}

if o.scroll != u32(0) {
res << vproto.pack_uint32_field(o.scroll, 7)
}

if o.zoom != f32(0) {
res << vproto.pack_float_field(o.zoom, 8)
}

if o.visible != false {
res << vproto.pack_bool_field(o.visible, 9)
}

if o.page_size != u32(0) {
res << vproto.pack_uint32_field(o.page_size, 10)
}

return res
}

pub fn cmsgverticalscrollbarsizeresponse_unpack(buf []byte) ?CMsgVerticalScrollBarSizeResponse {
mut res := zzz_vproto_internal_new_cmsgverticalscrollbarsizeresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.scroll_max = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.scroll = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

8 {
i, res.zoom = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

9 {
i, res.visible = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

10 {
i, res.page_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgVerticalScrollBarSizeResponse) eq(b CMsgVerticalScrollBarSizeResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.scroll_max == b.scroll_max
&& a.scroll == b.scroll
&& a.zoom == b.zoom
&& a.visible == b.visible
&& a.page_size == b.page_size
}
	[inline]
	pub fn (a CMsgVerticalScrollBarSizeResponse) ne(b CMsgVerticalScrollBarSizeResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgVerticalScrollBarSizeResponse) eq(b []CMsgVerticalScrollBarSizeResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgVerticalScrollBarSizeResponse) ne(b []CMsgVerticalScrollBarSizeResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgverticalscrollbarsizeresponse() CMsgVerticalScrollBarSizeResponse {
			return CMsgVerticalScrollBarSizeResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgverticalscrollbarsizeresponse(o CMsgVerticalScrollBarSizeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgverticalscrollbarsizeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgVerticalScrollBarSizeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgverticalscrollbarsizeresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgFind {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
find string
infind bool
reverse bool
}
pub fn (o &CMsgFind) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.find != '' {
res << vproto.pack_string_field(o.find, 2)
}

if o.infind != false {
res << vproto.pack_bool_field(o.infind, 3)
}

if o.reverse != false {
res << vproto.pack_bool_field(o.reverse, 4)
}

return res
}

pub fn cmsgfind_unpack(buf []byte) ?CMsgFind {
mut res := zzz_vproto_internal_new_cmsgfind()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.find = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.infind = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.reverse = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgFind) eq(b CMsgFind) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.find == b.find
&& a.infind == b.infind
&& a.reverse == b.reverse
}
	[inline]
	pub fn (a CMsgFind) ne(b CMsgFind) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgFind) eq(b []CMsgFind) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgFind) ne(b []CMsgFind) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgfind() CMsgFind {
			return CMsgFind{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfind(o CMsgFind, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfind(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFind) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfind_unpack(v)?
return i, unpacked
}
pub struct CMsgStopFind {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgStopFind) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgstopfind_unpack(buf []byte) ?CMsgStopFind {
mut res := zzz_vproto_internal_new_cmsgstopfind()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgStopFind) eq(b CMsgStopFind) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgStopFind) ne(b CMsgStopFind) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgStopFind) eq(b []CMsgStopFind) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgStopFind) ne(b []CMsgStopFind) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgstopfind() CMsgStopFind {
			return CMsgStopFind{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstopfind(o CMsgStopFind, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstopfind(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStopFind) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgstopfind_unpack(v)?
return i, unpacked
}
pub struct CMsgSetHorizontalScroll {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
scroll u32
}
pub fn (o &CMsgSetHorizontalScroll) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.scroll != u32(0) {
res << vproto.pack_uint32_field(o.scroll, 2)
}

return res
}

pub fn cmsgsethorizontalscroll_unpack(buf []byte) ?CMsgSetHorizontalScroll {
mut res := zzz_vproto_internal_new_cmsgsethorizontalscroll()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.scroll = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetHorizontalScroll) eq(b CMsgSetHorizontalScroll) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.scroll == b.scroll
}
	[inline]
	pub fn (a CMsgSetHorizontalScroll) ne(b CMsgSetHorizontalScroll) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetHorizontalScroll) eq(b []CMsgSetHorizontalScroll) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetHorizontalScroll) ne(b []CMsgSetHorizontalScroll) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsethorizontalscroll() CMsgSetHorizontalScroll {
			return CMsgSetHorizontalScroll{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsethorizontalscroll(o CMsgSetHorizontalScroll, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsethorizontalscroll(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetHorizontalScroll) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsethorizontalscroll_unpack(v)?
return i, unpacked
}
pub struct CMsgSetVerticalScroll {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
scroll u32
}
pub fn (o &CMsgSetVerticalScroll) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.scroll != u32(0) {
res << vproto.pack_uint32_field(o.scroll, 2)
}

return res
}

pub fn cmsgsetverticalscroll_unpack(buf []byte) ?CMsgSetVerticalScroll {
mut res := zzz_vproto_internal_new_cmsgsetverticalscroll()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.scroll = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetVerticalScroll) eq(b CMsgSetVerticalScroll) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.scroll == b.scroll
}
	[inline]
	pub fn (a CMsgSetVerticalScroll) ne(b CMsgSetVerticalScroll) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetVerticalScroll) eq(b []CMsgSetVerticalScroll) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetVerticalScroll) ne(b []CMsgSetVerticalScroll) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetverticalscroll() CMsgSetVerticalScroll {
			return CMsgSetVerticalScroll{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetverticalscroll(o CMsgSetVerticalScroll, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetverticalscroll(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetVerticalScroll) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetverticalscroll_unpack(v)?
return i, unpacked
}
pub struct CMsgSetZoomLevel {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
zoom f64
}
pub fn (o &CMsgSetZoomLevel) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.zoom != f64(0) {
res << vproto.pack_double_field(o.zoom, 2)
}

return res
}

pub fn cmsgsetzoomlevel_unpack(buf []byte) ?CMsgSetZoomLevel {
mut res := zzz_vproto_internal_new_cmsgsetzoomlevel()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.zoom = vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetZoomLevel) eq(b CMsgSetZoomLevel) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.zoom == b.zoom
}
	[inline]
	pub fn (a CMsgSetZoomLevel) ne(b CMsgSetZoomLevel) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetZoomLevel) eq(b []CMsgSetZoomLevel) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetZoomLevel) ne(b []CMsgSetZoomLevel) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetzoomlevel() CMsgSetZoomLevel {
			return CMsgSetZoomLevel{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetzoomlevel(o CMsgSetZoomLevel, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetzoomlevel(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetZoomLevel) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetzoomlevel_unpack(v)?
return i, unpacked
}
pub struct CMsgViewSource {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgViewSource) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgviewsource_unpack(buf []byte) ?CMsgViewSource {
mut res := zzz_vproto_internal_new_cmsgviewsource()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgViewSource) eq(b CMsgViewSource) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgViewSource) ne(b CMsgViewSource) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgViewSource) eq(b []CMsgViewSource) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgViewSource) ne(b []CMsgViewSource) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgviewsource() CMsgViewSource {
			return CMsgViewSource{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgviewsource(o CMsgViewSource, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgviewsource(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgViewSource) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgviewsource_unpack(v)?
return i, unpacked
}
pub struct CMsgBrowserReady {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
vr_overlay_key string
hwnd_browser u64
}
pub fn (o &CMsgBrowserReady) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.vr_overlay_key != '' {
res << vproto.pack_string_field(o.vr_overlay_key, 2)
}

if o.hwnd_browser != u64(0) {
res << vproto.pack_64bit_field(o.hwnd_browser, 3)
}

return res
}

pub fn cmsgbrowserready_unpack(buf []byte) ?CMsgBrowserReady {
mut res := zzz_vproto_internal_new_cmsgbrowserready()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.vr_overlay_key = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.hwnd_browser = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBrowserReady) eq(b CMsgBrowserReady) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.vr_overlay_key == b.vr_overlay_key
&& a.hwnd_browser == b.hwnd_browser
}
	[inline]
	pub fn (a CMsgBrowserReady) ne(b CMsgBrowserReady) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBrowserReady) eq(b []CMsgBrowserReady) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBrowserReady) ne(b []CMsgBrowserReady) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbrowserready() CMsgBrowserReady {
			return CMsgBrowserReady{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowserready(o CMsgBrowserReady, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowserready(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserReady) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbrowserready_unpack(v)?
return i, unpacked
}
pub struct CMsgURLChanged {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
postdata string
bisredirect bool
pagetitle string
bnewnavigation bool
}
pub fn (o &CMsgURLChanged) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.postdata != '' {
res << vproto.pack_string_field(o.postdata, 3)
}

if o.bisredirect != false {
res << vproto.pack_bool_field(o.bisredirect, 4)
}

if o.pagetitle != '' {
res << vproto.pack_string_field(o.pagetitle, 5)
}

if o.bnewnavigation != false {
res << vproto.pack_bool_field(o.bnewnavigation, 6)
}

return res
}

pub fn cmsgurlchanged_unpack(buf []byte) ?CMsgURLChanged {
mut res := zzz_vproto_internal_new_cmsgurlchanged()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.postdata = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.bisredirect = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.pagetitle = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.bnewnavigation = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgURLChanged) eq(b CMsgURLChanged) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.postdata == b.postdata
&& a.bisredirect == b.bisredirect
&& a.pagetitle == b.pagetitle
&& a.bnewnavigation == b.bnewnavigation
}
	[inline]
	pub fn (a CMsgURLChanged) ne(b CMsgURLChanged) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgURLChanged) eq(b []CMsgURLChanged) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgURLChanged) ne(b []CMsgURLChanged) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgurlchanged() CMsgURLChanged {
			return CMsgURLChanged{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgurlchanged(o CMsgURLChanged, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgurlchanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgURLChanged) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgurlchanged_unpack(v)?
return i, unpacked
}
pub struct CHTMLHeader {
mut:
unknown_fields []vproto.UnknownField
pub mut:
key string
value string
}
pub fn (o &CHTMLHeader) pack() []byte {
mut res := []byte{}
if o.key != '' {
res << vproto.pack_string_field(o.key, 1)
}

if o.value != '' {
res << vproto.pack_string_field(o.value, 2)
}

return res
}

pub fn chtmlheader_unpack(buf []byte) ?CHTMLHeader {
mut res := zzz_vproto_internal_new_chtmlheader()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.key = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.value = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CHTMLHeader) eq(b CHTMLHeader) bool {
		return true
&& a.key == b.key
&& a.value == b.value
}
	[inline]
	pub fn (a CHTMLHeader) ne(b CHTMLHeader) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CHTMLHeader) eq(b []CHTMLHeader) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CHTMLHeader) ne(b []CHTMLHeader) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_chtmlheader() CHTMLHeader {
			return CHTMLHeader{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_chtmlheader(o CHTMLHeader, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_chtmlheader(buf []byte, tag_wiretype vproto.WireType) ?(int, CHTMLHeader) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := chtmlheader_unpack(v)?
return i, unpacked
}
pub struct CHTMLPageSecurityInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
bissecure bool
bhascerterror bool
issuername string
certname string
certexpiry int
ncertbits int
bisevcert bool
}
pub fn (o &CHTMLPageSecurityInfo) pack() []byte {
mut res := []byte{}
if o.bissecure != false {
res << vproto.pack_bool_field(o.bissecure, 1)
}

if o.bhascerterror != false {
res << vproto.pack_bool_field(o.bhascerterror, 2)
}

if o.issuername != '' {
res << vproto.pack_string_field(o.issuername, 3)
}

if o.certname != '' {
res << vproto.pack_string_field(o.certname, 4)
}

if o.certexpiry != int(0) {
res << vproto.pack_int32_field(o.certexpiry, 5)
}

if o.ncertbits != int(0) {
res << vproto.pack_int32_field(o.ncertbits, 6)
}

if o.bisevcert != false {
res << vproto.pack_bool_field(o.bisevcert, 7)
}

return res
}

pub fn chtmlpagesecurityinfo_unpack(buf []byte) ?CHTMLPageSecurityInfo {
mut res := zzz_vproto_internal_new_chtmlpagesecurityinfo()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.bissecure = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.bhascerterror = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.issuername = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.certname = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.certexpiry = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.ncertbits = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.bisevcert = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CHTMLPageSecurityInfo) eq(b CHTMLPageSecurityInfo) bool {
		return true
&& a.bissecure == b.bissecure
&& a.bhascerterror == b.bhascerterror
&& a.issuername == b.issuername
&& a.certname == b.certname
&& a.certexpiry == b.certexpiry
&& a.ncertbits == b.ncertbits
&& a.bisevcert == b.bisevcert
}
	[inline]
	pub fn (a CHTMLPageSecurityInfo) ne(b CHTMLPageSecurityInfo) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CHTMLPageSecurityInfo) eq(b []CHTMLPageSecurityInfo) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CHTMLPageSecurityInfo) ne(b []CHTMLPageSecurityInfo) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_chtmlpagesecurityinfo() CHTMLPageSecurityInfo {
			return CHTMLPageSecurityInfo{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_chtmlpagesecurityinfo(o CHTMLPageSecurityInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_chtmlpagesecurityinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CHTMLPageSecurityInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := chtmlpagesecurityinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgFinishedRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
pagetitle string
}
pub fn (o &CMsgFinishedRequest) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.pagetitle != '' {
res << vproto.pack_string_field(o.pagetitle, 3)
}

return res
}

pub fn cmsgfinishedrequest_unpack(buf []byte) ?CMsgFinishedRequest {
mut res := zzz_vproto_internal_new_cmsgfinishedrequest()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.pagetitle = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgFinishedRequest) eq(b CMsgFinishedRequest) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.pagetitle == b.pagetitle
}
	[inline]
	pub fn (a CMsgFinishedRequest) ne(b CMsgFinishedRequest) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgFinishedRequest) eq(b []CMsgFinishedRequest) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgFinishedRequest) ne(b []CMsgFinishedRequest) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgfinishedrequest() CMsgFinishedRequest {
			return CMsgFinishedRequest{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfinishedrequest(o CMsgFinishedRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfinishedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFinishedRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfinishedrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgLoadedRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
pagetitle string
headers []CHTMLHeader
}
pub fn (o &CMsgLoadedRequest) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.pagetitle != '' {
res << vproto.pack_string_field(o.pagetitle, 3)
}

// [packed=false]
for _, x in o.headers {
res << zzz_vproto_internal_pack_chtmlheader(x, 5)
}

return res
}

pub fn cmsgloadedrequest_unpack(buf []byte) ?CMsgLoadedRequest {
mut res := zzz_vproto_internal_new_cmsgloadedrequest()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.pagetitle = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_chtmlheader(cur_buf, tag_wiretype.wire_type)?
res.headers << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgLoadedRequest) eq(b CMsgLoadedRequest) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.pagetitle == b.pagetitle
&& a.headers.eq(b.headers)
}
	[inline]
	pub fn (a CMsgLoadedRequest) ne(b CMsgLoadedRequest) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgLoadedRequest) eq(b []CMsgLoadedRequest) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgLoadedRequest) ne(b []CMsgLoadedRequest) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgloadedrequest() CMsgLoadedRequest {
			return CMsgLoadedRequest{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgloadedrequest(o CMsgLoadedRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgloadedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLoadedRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgloadedrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgPageSecurity {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
security_info CHTMLPageSecurityInfo
}
pub fn (o &CMsgPageSecurity) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.security_info.ne(zzz_vproto_internal_new_chtmlpagesecurityinfo()) {
res << zzz_vproto_internal_pack_chtmlpagesecurityinfo(o.security_info, 3)
}

return res
}

pub fn cmsgpagesecurity_unpack(buf []byte) ?CMsgPageSecurity {
mut res := zzz_vproto_internal_new_cmsgpagesecurity()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.security_info = zzz_vproto_internal_unpack_chtmlpagesecurityinfo(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgPageSecurity) eq(b CMsgPageSecurity) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.security_info.eq(b.security_info)
}
	[inline]
	pub fn (a CMsgPageSecurity) ne(b CMsgPageSecurity) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgPageSecurity) eq(b []CMsgPageSecurity) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgPageSecurity) ne(b []CMsgPageSecurity) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgpagesecurity() CMsgPageSecurity {
			return CMsgPageSecurity{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpagesecurity(o CMsgPageSecurity, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpagesecurity(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPageSecurity) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgpagesecurity_unpack(v)?
return i, unpacked
}
pub struct CMsgStartRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
target string
postdata string
bisredirect bool
}
pub fn (o &CMsgStartRequest) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.target != '' {
res << vproto.pack_string_field(o.target, 3)
}

if o.postdata != '' {
res << vproto.pack_string_field(o.postdata, 4)
}

if o.bisredirect != false {
res << vproto.pack_bool_field(o.bisredirect, 5)
}

return res
}

pub fn cmsgstartrequest_unpack(buf []byte) ?CMsgStartRequest {
mut res := zzz_vproto_internal_new_cmsgstartrequest()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.target = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.postdata = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.bisredirect = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgStartRequest) eq(b CMsgStartRequest) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.target == b.target
&& a.postdata == b.postdata
&& a.bisredirect == b.bisredirect
}
	[inline]
	pub fn (a CMsgStartRequest) ne(b CMsgStartRequest) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgStartRequest) eq(b []CMsgStartRequest) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgStartRequest) ne(b []CMsgStartRequest) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgstartrequest() CMsgStartRequest {
			return CMsgStartRequest{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstartrequest(o CMsgStartRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstartrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStartRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgstartrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgStartRequestResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
ballow bool
}
pub fn (o &CMsgStartRequestResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.ballow != false {
res << vproto.pack_bool_field(o.ballow, 2)
}

return res
}

pub fn cmsgstartrequestresponse_unpack(buf []byte) ?CMsgStartRequestResponse {
mut res := zzz_vproto_internal_new_cmsgstartrequestresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.ballow = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgStartRequestResponse) eq(b CMsgStartRequestResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.ballow == b.ballow
}
	[inline]
	pub fn (a CMsgStartRequestResponse) ne(b CMsgStartRequestResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgStartRequestResponse) eq(b []CMsgStartRequestResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgStartRequestResponse) ne(b []CMsgStartRequestResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgstartrequestresponse() CMsgStartRequestResponse {
			return CMsgStartRequestResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstartrequestresponse(o CMsgStartRequestResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstartrequestresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStartRequestResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgstartrequestresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgShowPopup {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgShowPopup) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgshowpopup_unpack(buf []byte) ?CMsgShowPopup {
mut res := zzz_vproto_internal_new_cmsgshowpopup()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgShowPopup) eq(b CMsgShowPopup) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgShowPopup) ne(b CMsgShowPopup) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgShowPopup) eq(b []CMsgShowPopup) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgShowPopup) ne(b []CMsgShowPopup) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgshowpopup() CMsgShowPopup {
			return CMsgShowPopup{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgshowpopup(o CMsgShowPopup, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgshowpopup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowPopup) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgshowpopup_unpack(v)?
return i, unpacked
}
pub struct CMsgHidePopup {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgHidePopup) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsghidepopup_unpack(buf []byte) ?CMsgHidePopup {
mut res := zzz_vproto_internal_new_cmsghidepopup()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgHidePopup) eq(b CMsgHidePopup) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgHidePopup) ne(b CMsgHidePopup) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgHidePopup) eq(b []CMsgHidePopup) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgHidePopup) ne(b []CMsgHidePopup) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsghidepopup() CMsgHidePopup {
			return CMsgHidePopup{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsghidepopup(o CMsgHidePopup, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsghidepopup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHidePopup) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsghidepopup_unpack(v)?
return i, unpacked
}
pub struct CMsgSizePopup {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
x int
y int
wide u32
tall u32
}
pub fn (o &CMsgSizePopup) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.x != int(0) {
res << vproto.pack_int32_field(o.x, 2)
}

if o.y != int(0) {
res << vproto.pack_int32_field(o.y, 3)
}

if o.wide != u32(0) {
res << vproto.pack_uint32_field(o.wide, 4)
}

if o.tall != u32(0) {
res << vproto.pack_uint32_field(o.tall, 5)
}

return res
}

pub fn cmsgsizepopup_unpack(buf []byte) ?CMsgSizePopup {
mut res := zzz_vproto_internal_new_cmsgsizepopup()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.x = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.y = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.wide = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.tall = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSizePopup) eq(b CMsgSizePopup) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.x == b.x
&& a.y == b.y
&& a.wide == b.wide
&& a.tall == b.tall
}
	[inline]
	pub fn (a CMsgSizePopup) ne(b CMsgSizePopup) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSizePopup) eq(b []CMsgSizePopup) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSizePopup) ne(b []CMsgSizePopup) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsizepopup() CMsgSizePopup {
			return CMsgSizePopup{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsizepopup(o CMsgSizePopup, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsizepopup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSizePopup) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsizepopup_unpack(v)?
return i, unpacked
}
pub struct CMsgOpenNewTab {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
bforeground bool
}
pub fn (o &CMsgOpenNewTab) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.bforeground != false {
res << vproto.pack_bool_field(o.bforeground, 3)
}

return res
}

pub fn cmsgopennewtab_unpack(buf []byte) ?CMsgOpenNewTab {
mut res := zzz_vproto_internal_new_cmsgopennewtab()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.bforeground = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgOpenNewTab) eq(b CMsgOpenNewTab) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.bforeground == b.bforeground
}
	[inline]
	pub fn (a CMsgOpenNewTab) ne(b CMsgOpenNewTab) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgOpenNewTab) eq(b []CMsgOpenNewTab) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgOpenNewTab) ne(b []CMsgOpenNewTab) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgopennewtab() CMsgOpenNewTab {
			return CMsgOpenNewTab{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgopennewtab(o CMsgOpenNewTab, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgopennewtab(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgOpenNewTab) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgopennewtab_unpack(v)?
return i, unpacked
}
pub struct CMsgPopupHTMLWindow {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
x int
 = -2147483648
y int
 = -2147483648
wide u32
tall u32
popup_index u32
trusted_creator bool
}
pub fn (o &CMsgPopupHTMLWindow) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.x != int(0) {
res << vproto.pack_int32_field(o.x, 3)
}

if o.y != int(0) {
res << vproto.pack_int32_field(o.y, 4)
}

if o.wide != u32(0) {
res << vproto.pack_uint32_field(o.wide, 5)
}

if o.tall != u32(0) {
res << vproto.pack_uint32_field(o.tall, 6)
}

if o.popup_index != u32(0) {
res << vproto.pack_uint32_field(o.popup_index, 7)
}

if o.trusted_creator != false {
res << vproto.pack_bool_field(o.trusted_creator, 8)
}

return res
}

pub fn cmsgpopuphtmlwindow_unpack(buf []byte) ?CMsgPopupHTMLWindow {
mut res := zzz_vproto_internal_new_cmsgpopuphtmlwindow()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.x = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.y = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.wide = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.tall = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.popup_index = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

8 {
i, res.trusted_creator = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgPopupHTMLWindow) eq(b CMsgPopupHTMLWindow) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.x == b.x
&& a.y == b.y
&& a.wide == b.wide
&& a.tall == b.tall
&& a.popup_index == b.popup_index
&& a.trusted_creator == b.trusted_creator
}
	[inline]
	pub fn (a CMsgPopupHTMLWindow) ne(b CMsgPopupHTMLWindow) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgPopupHTMLWindow) eq(b []CMsgPopupHTMLWindow) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgPopupHTMLWindow) ne(b []CMsgPopupHTMLWindow) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgpopuphtmlwindow() CMsgPopupHTMLWindow {
			return CMsgPopupHTMLWindow{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpopuphtmlwindow(o CMsgPopupHTMLWindow, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpopuphtmlwindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPopupHTMLWindow) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgpopuphtmlwindow_unpack(v)?
return i, unpacked
}
pub struct CMsgPopupHTMLWindowResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
ballow bool
}
pub fn (o &CMsgPopupHTMLWindowResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.ballow != false {
res << vproto.pack_bool_field(o.ballow, 2)
}

return res
}

pub fn cmsgpopuphtmlwindowresponse_unpack(buf []byte) ?CMsgPopupHTMLWindowResponse {
mut res := zzz_vproto_internal_new_cmsgpopuphtmlwindowresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.ballow = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgPopupHTMLWindowResponse) eq(b CMsgPopupHTMLWindowResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.ballow == b.ballow
}
	[inline]
	pub fn (a CMsgPopupHTMLWindowResponse) ne(b CMsgPopupHTMLWindowResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgPopupHTMLWindowResponse) eq(b []CMsgPopupHTMLWindowResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgPopupHTMLWindowResponse) ne(b []CMsgPopupHTMLWindowResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgpopuphtmlwindowresponse() CMsgPopupHTMLWindowResponse {
			return CMsgPopupHTMLWindowResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpopuphtmlwindowresponse(o CMsgPopupHTMLWindowResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpopuphtmlwindowresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPopupHTMLWindowResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgpopuphtmlwindowresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgSetHTMLTitle {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
title string
}
pub fn (o &CMsgSetHTMLTitle) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.title != '' {
res << vproto.pack_string_field(o.title, 2)
}

return res
}

pub fn cmsgsethtmltitle_unpack(buf []byte) ?CMsgSetHTMLTitle {
mut res := zzz_vproto_internal_new_cmsgsethtmltitle()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.title = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetHTMLTitle) eq(b CMsgSetHTMLTitle) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.title == b.title
}
	[inline]
	pub fn (a CMsgSetHTMLTitle) ne(b CMsgSetHTMLTitle) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetHTMLTitle) eq(b []CMsgSetHTMLTitle) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetHTMLTitle) ne(b []CMsgSetHTMLTitle) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsethtmltitle() CMsgSetHTMLTitle {
			return CMsgSetHTMLTitle{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsethtmltitle(o CMsgSetHTMLTitle, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsethtmltitle(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetHTMLTitle) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsethtmltitle_unpack(v)?
return i, unpacked
}
pub struct CMsgLoadingResource {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
}
pub fn (o &CMsgLoadingResource) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

return res
}

pub fn cmsgloadingresource_unpack(buf []byte) ?CMsgLoadingResource {
mut res := zzz_vproto_internal_new_cmsgloadingresource()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgLoadingResource) eq(b CMsgLoadingResource) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
}
	[inline]
	pub fn (a CMsgLoadingResource) ne(b CMsgLoadingResource) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgLoadingResource) eq(b []CMsgLoadingResource) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgLoadingResource) ne(b []CMsgLoadingResource) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgloadingresource() CMsgLoadingResource {
			return CMsgLoadingResource{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgloadingresource(o CMsgLoadingResource, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgloadingresource(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLoadingResource) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgloadingresource_unpack(v)?
return i, unpacked
}
pub struct CMsgStatusText {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
text string
}
pub fn (o &CMsgStatusText) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.text != '' {
res << vproto.pack_string_field(o.text, 2)
}

return res
}

pub fn cmsgstatustext_unpack(buf []byte) ?CMsgStatusText {
mut res := zzz_vproto_internal_new_cmsgstatustext()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.text = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgStatusText) eq(b CMsgStatusText) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.text == b.text
}
	[inline]
	pub fn (a CMsgStatusText) ne(b CMsgStatusText) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgStatusText) eq(b []CMsgStatusText) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgStatusText) ne(b []CMsgStatusText) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgstatustext() CMsgStatusText {
			return CMsgStatusText{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstatustext(o CMsgStatusText, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstatustext(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStatusText) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgstatustext_unpack(v)?
return i, unpacked
}
pub struct CMsgSetCursor {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
cursor u32
custom_data []byte
wide u32
tall u32
xhotspot u32
yhotspot u32
}
pub fn (o &CMsgSetCursor) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.cursor != u32(0) {
res << vproto.pack_uint32_field(o.cursor, 2)
}

if o.custom_data != []byte{} {
res << vproto.pack_bytes_field(o.custom_data, 3)
}

if o.wide != u32(0) {
res << vproto.pack_uint32_field(o.wide, 4)
}

if o.tall != u32(0) {
res << vproto.pack_uint32_field(o.tall, 5)
}

if o.xhotspot != u32(0) {
res << vproto.pack_uint32_field(o.xhotspot, 6)
}

if o.yhotspot != u32(0) {
res << vproto.pack_uint32_field(o.yhotspot, 7)
}

return res
}

pub fn cmsgsetcursor_unpack(buf []byte) ?CMsgSetCursor {
mut res := zzz_vproto_internal_new_cmsgsetcursor()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.cursor = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.custom_data = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.wide = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.tall = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.xhotspot = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.yhotspot = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetCursor) eq(b CMsgSetCursor) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.cursor == b.cursor
&& a.custom_data == b.custom_data
&& a.wide == b.wide
&& a.tall == b.tall
&& a.xhotspot == b.xhotspot
&& a.yhotspot == b.yhotspot
}
	[inline]
	pub fn (a CMsgSetCursor) ne(b CMsgSetCursor) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetCursor) eq(b []CMsgSetCursor) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetCursor) ne(b []CMsgSetCursor) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetcursor() CMsgSetCursor {
			return CMsgSetCursor{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetcursor(o CMsgSetCursor, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetcursor(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetCursor) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetcursor_unpack(v)?
return i, unpacked
}
pub struct CMsgFileLoadDialog {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
title string
initialfile string
accept_types []string
is_save bool
}
pub fn (o &CMsgFileLoadDialog) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.title != '' {
res << vproto.pack_string_field(o.title, 2)
}

if o.initialfile != '' {
res << vproto.pack_string_field(o.initialfile, 3)
}

// [packed=false]
for _, x in o.accept_types {
res << vproto.pack_string_field(x, 4)
}

if o.is_save != false {
res << vproto.pack_bool_field(o.is_save, 5)
}

return res
}

pub fn cmsgfileloaddialog_unpack(buf []byte) ?CMsgFileLoadDialog {
mut res := zzz_vproto_internal_new_cmsgfileloaddialog()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.title = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.initialfile = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.accept_types << v
i = ii
}

5 {
i, res.is_save = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgFileLoadDialog) eq(b CMsgFileLoadDialog) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.title == b.title
&& a.initialfile == b.initialfile
&& a.accept_types == b.accept_types
&& a.is_save == b.is_save
}
	[inline]
	pub fn (a CMsgFileLoadDialog) ne(b CMsgFileLoadDialog) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgFileLoadDialog) eq(b []CMsgFileLoadDialog) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgFileLoadDialog) ne(b []CMsgFileLoadDialog) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgfileloaddialog() CMsgFileLoadDialog {
			return CMsgFileLoadDialog{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfileloaddialog(o CMsgFileLoadDialog, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfileloaddialog(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFileLoadDialog) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfileloaddialog_unpack(v)?
return i, unpacked
}
pub struct CMsgFileLoadDialogResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
files []string
}
pub fn (o &CMsgFileLoadDialogResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

// [packed=false]
for _, x in o.files {
res << vproto.pack_string_field(x, 2)
}

return res
}

pub fn cmsgfileloaddialogresponse_unpack(buf []byte) ?CMsgFileLoadDialogResponse {
mut res := zzz_vproto_internal_new_cmsgfileloaddialogresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.files << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgFileLoadDialogResponse) eq(b CMsgFileLoadDialogResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.files == b.files
}
	[inline]
	pub fn (a CMsgFileLoadDialogResponse) ne(b CMsgFileLoadDialogResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgFileLoadDialogResponse) eq(b []CMsgFileLoadDialogResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgFileLoadDialogResponse) ne(b []CMsgFileLoadDialogResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgfileloaddialogresponse() CMsgFileLoadDialogResponse {
			return CMsgFileLoadDialogResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfileloaddialogresponse(o CMsgFileLoadDialogResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfileloaddialogresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFileLoadDialogResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfileloaddialogresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgShowToolTip {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
text string
}
pub fn (o &CMsgShowToolTip) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.text != '' {
res << vproto.pack_string_field(o.text, 2)
}

return res
}

pub fn cmsgshowtooltip_unpack(buf []byte) ?CMsgShowToolTip {
mut res := zzz_vproto_internal_new_cmsgshowtooltip()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.text = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgShowToolTip) eq(b CMsgShowToolTip) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.text == b.text
}
	[inline]
	pub fn (a CMsgShowToolTip) ne(b CMsgShowToolTip) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgShowToolTip) eq(b []CMsgShowToolTip) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgShowToolTip) ne(b []CMsgShowToolTip) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgshowtooltip() CMsgShowToolTip {
			return CMsgShowToolTip{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgshowtooltip(o CMsgShowToolTip, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgshowtooltip(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowToolTip) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgshowtooltip_unpack(v)?
return i, unpacked
}
pub struct CMsgUpdateToolTip {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
text string
}
pub fn (o &CMsgUpdateToolTip) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.text != '' {
res << vproto.pack_string_field(o.text, 2)
}

return res
}

pub fn cmsgupdatetooltip_unpack(buf []byte) ?CMsgUpdateToolTip {
mut res := zzz_vproto_internal_new_cmsgupdatetooltip()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.text = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgUpdateToolTip) eq(b CMsgUpdateToolTip) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.text == b.text
}
	[inline]
	pub fn (a CMsgUpdateToolTip) ne(b CMsgUpdateToolTip) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgUpdateToolTip) eq(b []CMsgUpdateToolTip) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgUpdateToolTip) ne(b []CMsgUpdateToolTip) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgupdatetooltip() CMsgUpdateToolTip {
			return CMsgUpdateToolTip{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgupdatetooltip(o CMsgUpdateToolTip, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgupdatetooltip(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgUpdateToolTip) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgupdatetooltip_unpack(v)?
return i, unpacked
}
pub struct CMsgHideToolTip {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgHideToolTip) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsghidetooltip_unpack(buf []byte) ?CMsgHideToolTip {
mut res := zzz_vproto_internal_new_cmsghidetooltip()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgHideToolTip) eq(b CMsgHideToolTip) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgHideToolTip) ne(b CMsgHideToolTip) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgHideToolTip) eq(b []CMsgHideToolTip) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgHideToolTip) ne(b []CMsgHideToolTip) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsghidetooltip() CMsgHideToolTip {
			return CMsgHideToolTip{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsghidetooltip(o CMsgHideToolTip, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsghidetooltip(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHideToolTip) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsghidetooltip_unpack(v)?
return i, unpacked
}
pub struct CMsgSearchResults {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
activematch int
results int
}
pub fn (o &CMsgSearchResults) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.activematch != int(0) {
res << vproto.pack_int32_field(o.activematch, 2)
}

if o.results != int(0) {
res << vproto.pack_int32_field(o.results, 3)
}

return res
}

pub fn cmsgsearchresults_unpack(buf []byte) ?CMsgSearchResults {
mut res := zzz_vproto_internal_new_cmsgsearchresults()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.activematch = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.results = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSearchResults) eq(b CMsgSearchResults) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.activematch == b.activematch
&& a.results == b.results
}
	[inline]
	pub fn (a CMsgSearchResults) ne(b CMsgSearchResults) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSearchResults) eq(b []CMsgSearchResults) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSearchResults) ne(b []CMsgSearchResults) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsearchresults() CMsgSearchResults {
			return CMsgSearchResults{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsearchresults(o CMsgSearchResults, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsearchresults(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSearchResults) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsearchresults_unpack(v)?
return i, unpacked
}
pub struct CMsgClose {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgClose) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgclose_unpack(buf []byte) ?CMsgClose {
mut res := zzz_vproto_internal_new_cmsgclose()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgClose) eq(b CMsgClose) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgClose) ne(b CMsgClose) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgClose) eq(b []CMsgClose) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgClose) ne(b []CMsgClose) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgclose() CMsgClose {
			return CMsgClose{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclose(o CMsgClose, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclose(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClose) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclose_unpack(v)?
return i, unpacked
}
pub struct CMsgSetSharedPaintBuffers {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
wide u32
tall u32
source_pid u64
source_handle u64
handle u64
}
pub fn (o &CMsgSetSharedPaintBuffers) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.wide != u32(0) {
res << vproto.pack_uint32_field(o.wide, 2)
}

if o.tall != u32(0) {
res << vproto.pack_uint32_field(o.tall, 3)
}

if o.source_pid != u64(0) {
res << vproto.pack_uint64_field(o.source_pid, 4)
}

if o.source_handle != u64(0) {
res << vproto.pack_uint64_field(o.source_handle, 5)
}

if o.handle != u64(0) {
res << vproto.pack_uint64_field(o.handle, 6)
}

return res
}

pub fn cmsgsetsharedpaintbuffers_unpack(buf []byte) ?CMsgSetSharedPaintBuffers {
mut res := zzz_vproto_internal_new_cmsgsetsharedpaintbuffers()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.wide = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.tall = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.source_pid = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.source_handle = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.handle = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetSharedPaintBuffers) eq(b CMsgSetSharedPaintBuffers) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.wide == b.wide
&& a.tall == b.tall
&& a.source_pid == b.source_pid
&& a.source_handle == b.source_handle
&& a.handle == b.handle
}
	[inline]
	pub fn (a CMsgSetSharedPaintBuffers) ne(b CMsgSetSharedPaintBuffers) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetSharedPaintBuffers) eq(b []CMsgSetSharedPaintBuffers) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetSharedPaintBuffers) ne(b []CMsgSetSharedPaintBuffers) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetsharedpaintbuffers() CMsgSetSharedPaintBuffers {
			return CMsgSetSharedPaintBuffers{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetsharedpaintbuffers(o CMsgSetSharedPaintBuffers, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetsharedpaintbuffers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetSharedPaintBuffers) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetsharedpaintbuffers_unpack(v)?
return i, unpacked
}
pub struct CMsgAckSharedPaintBuffers {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgAckSharedPaintBuffers) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgacksharedpaintbuffers_unpack(buf []byte) ?CMsgAckSharedPaintBuffers {
mut res := zzz_vproto_internal_new_cmsgacksharedpaintbuffers()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgAckSharedPaintBuffers) eq(b CMsgAckSharedPaintBuffers) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgAckSharedPaintBuffers) ne(b CMsgAckSharedPaintBuffers) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgAckSharedPaintBuffers) eq(b []CMsgAckSharedPaintBuffers) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgAckSharedPaintBuffers) ne(b []CMsgAckSharedPaintBuffers) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgacksharedpaintbuffers() CMsgAckSharedPaintBuffers {
			return CMsgAckSharedPaintBuffers{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgacksharedpaintbuffers(o CMsgAckSharedPaintBuffers, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgacksharedpaintbuffers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAckSharedPaintBuffers) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgacksharedpaintbuffers_unpack(v)?
return i, unpacked
}
pub struct CMsgNeedsPaint {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
scrollx u32
scrolly u32
pagescale f32
pageserial u32
}
pub fn (o &CMsgNeedsPaint) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.scrollx != u32(0) {
res << vproto.pack_uint32_field(o.scrollx, 10)
}

if o.scrolly != u32(0) {
res << vproto.pack_uint32_field(o.scrolly, 11)
}

if o.pagescale != f32(0) {
res << vproto.pack_float_field(o.pagescale, 12)
}

if o.pageserial != u32(0) {
res << vproto.pack_uint32_field(o.pageserial, 15)
}

return res
}

pub fn cmsgneedspaint_unpack(buf []byte) ?CMsgNeedsPaint {
mut res := zzz_vproto_internal_new_cmsgneedspaint()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

10 {
i, res.scrollx = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

11 {
i, res.scrolly = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

12 {
i, res.pagescale = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

15 {
i, res.pageserial = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgNeedsPaint) eq(b CMsgNeedsPaint) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.scrollx == b.scrollx
&& a.scrolly == b.scrolly
&& a.pagescale == b.pagescale
&& a.pageserial == b.pageserial
}
	[inline]
	pub fn (a CMsgNeedsPaint) ne(b CMsgNeedsPaint) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgNeedsPaint) eq(b []CMsgNeedsPaint) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgNeedsPaint) ne(b []CMsgNeedsPaint) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgneedspaint() CMsgNeedsPaint {
			return CMsgNeedsPaint{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgneedspaint(o CMsgNeedsPaint, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgneedspaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgNeedsPaint) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgneedspaint_unpack(v)?
return i, unpacked
}
pub struct CMsgComboNeedsPaint {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
rgba u64
combobox_wide u32
combobox_tall u32
shared_memory_handle u64
shared_memory_size u64
}
pub fn (o &CMsgComboNeedsPaint) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.rgba != u64(0) {
res << vproto.pack_uint64_field(o.rgba, 2)
}

if o.combobox_wide != u32(0) {
res << vproto.pack_uint32_field(o.combobox_wide, 3)
}

if o.combobox_tall != u32(0) {
res << vproto.pack_uint32_field(o.combobox_tall, 4)
}

if o.shared_memory_handle != u64(0) {
res << vproto.pack_uint64_field(o.shared_memory_handle, 5)
}

if o.shared_memory_size != u64(0) {
res << vproto.pack_uint64_field(o.shared_memory_size, 7)
}

return res
}

pub fn cmsgcomboneedspaint_unpack(buf []byte) ?CMsgComboNeedsPaint {
mut res := zzz_vproto_internal_new_cmsgcomboneedspaint()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.rgba = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.combobox_wide = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.combobox_tall = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.shared_memory_handle = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.shared_memory_size = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgComboNeedsPaint) eq(b CMsgComboNeedsPaint) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.rgba == b.rgba
&& a.combobox_wide == b.combobox_wide
&& a.combobox_tall == b.combobox_tall
&& a.shared_memory_handle == b.shared_memory_handle
&& a.shared_memory_size == b.shared_memory_size
}
	[inline]
	pub fn (a CMsgComboNeedsPaint) ne(b CMsgComboNeedsPaint) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgComboNeedsPaint) eq(b []CMsgComboNeedsPaint) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgComboNeedsPaint) ne(b []CMsgComboNeedsPaint) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgcomboneedspaint() CMsgComboNeedsPaint {
			return CMsgComboNeedsPaint{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgcomboneedspaint(o CMsgComboNeedsPaint, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgcomboneedspaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgComboNeedsPaint) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcomboneedspaint_unpack(v)?
return i, unpacked
}
pub struct CMsgNeedsSharedTexturePaint {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
share_handle u32
width u32
height u32
scrollx u32
scrolly u32
pagescale f32
pageserial u32
}
pub fn (o &CMsgNeedsSharedTexturePaint) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.share_handle != u32(0) {
res << vproto.pack_uint32_field(o.share_handle, 2)
}

if o.width != u32(0) {
res << vproto.pack_uint32_field(o.width, 3)
}

if o.height != u32(0) {
res << vproto.pack_uint32_field(o.height, 4)
}

if o.scrollx != u32(0) {
res << vproto.pack_uint32_field(o.scrollx, 5)
}

if o.scrolly != u32(0) {
res << vproto.pack_uint32_field(o.scrolly, 6)
}

if o.pagescale != f32(0) {
res << vproto.pack_float_field(o.pagescale, 7)
}

if o.pageserial != u32(0) {
res << vproto.pack_uint32_field(o.pageserial, 8)
}

return res
}

pub fn cmsgneedssharedtexturepaint_unpack(buf []byte) ?CMsgNeedsSharedTexturePaint {
mut res := zzz_vproto_internal_new_cmsgneedssharedtexturepaint()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.share_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.width = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.height = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.scrollx = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.scrolly = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.pagescale = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

8 {
i, res.pageserial = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgNeedsSharedTexturePaint) eq(b CMsgNeedsSharedTexturePaint) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.share_handle == b.share_handle
&& a.width == b.width
&& a.height == b.height
&& a.scrollx == b.scrollx
&& a.scrolly == b.scrolly
&& a.pagescale == b.pagescale
&& a.pageserial == b.pageserial
}
	[inline]
	pub fn (a CMsgNeedsSharedTexturePaint) ne(b CMsgNeedsSharedTexturePaint) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgNeedsSharedTexturePaint) eq(b []CMsgNeedsSharedTexturePaint) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgNeedsSharedTexturePaint) ne(b []CMsgNeedsSharedTexturePaint) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgneedssharedtexturepaint() CMsgNeedsSharedTexturePaint {
			return CMsgNeedsSharedTexturePaint{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgneedssharedtexturepaint(o CMsgNeedsSharedTexturePaint, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgneedssharedtexturepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgNeedsSharedTexturePaint) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgneedssharedtexturepaint_unpack(v)?
return i, unpacked
}
pub struct CMsgGameOverlayTexturePaint {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
width u32
height u32
scrollx u32
scrolly u32
pagescale f32
pageserial u32
}
pub fn (o &CMsgGameOverlayTexturePaint) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.width != u32(0) {
res << vproto.pack_uint32_field(o.width, 3)
}

if o.height != u32(0) {
res << vproto.pack_uint32_field(o.height, 4)
}

if o.scrollx != u32(0) {
res << vproto.pack_uint32_field(o.scrollx, 5)
}

if o.scrolly != u32(0) {
res << vproto.pack_uint32_field(o.scrolly, 6)
}

if o.pagescale != f32(0) {
res << vproto.pack_float_field(o.pagescale, 7)
}

if o.pageserial != u32(0) {
res << vproto.pack_uint32_field(o.pageserial, 8)
}

return res
}

pub fn cmsggameoverlaytexturepaint_unpack(buf []byte) ?CMsgGameOverlayTexturePaint {
mut res := zzz_vproto_internal_new_cmsggameoverlaytexturepaint()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.width = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.height = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.scrollx = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.scrolly = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.pagescale = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

8 {
i, res.pageserial = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgGameOverlayTexturePaint) eq(b CMsgGameOverlayTexturePaint) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.width == b.width
&& a.height == b.height
&& a.scrollx == b.scrollx
&& a.scrolly == b.scrolly
&& a.pagescale == b.pagescale
&& a.pageserial == b.pageserial
}
	[inline]
	pub fn (a CMsgGameOverlayTexturePaint) ne(b CMsgGameOverlayTexturePaint) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgGameOverlayTexturePaint) eq(b []CMsgGameOverlayTexturePaint) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgGameOverlayTexturePaint) ne(b []CMsgGameOverlayTexturePaint) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsggameoverlaytexturepaint() CMsgGameOverlayTexturePaint {
			return CMsgGameOverlayTexturePaint{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggameoverlaytexturepaint(o CMsgGameOverlayTexturePaint, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggameoverlaytexturepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameOverlayTexturePaint) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggameoverlaytexturepaint_unpack(v)?
return i, unpacked
}
pub struct CMsgGetZoom {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgGetZoom) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsggetzoom_unpack(buf []byte) ?CMsgGetZoom {
mut res := zzz_vproto_internal_new_cmsggetzoom()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgGetZoom) eq(b CMsgGetZoom) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgGetZoom) ne(b CMsgGetZoom) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgGetZoom) eq(b []CMsgGetZoom) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgGetZoom) ne(b []CMsgGetZoom) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsggetzoom() CMsgGetZoom {
			return CMsgGetZoom{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggetzoom(o CMsgGetZoom, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggetzoom(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetZoom) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggetzoom_unpack(v)?
return i, unpacked
}
pub struct CMsgGetZoomResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
zoom f32
}
pub fn (o &CMsgGetZoomResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.zoom != f32(0) {
res << vproto.pack_float_field(o.zoom, 2)
}

return res
}

pub fn cmsggetzoomresponse_unpack(buf []byte) ?CMsgGetZoomResponse {
mut res := zzz_vproto_internal_new_cmsggetzoomresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.zoom = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgGetZoomResponse) eq(b CMsgGetZoomResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.zoom == b.zoom
}
	[inline]
	pub fn (a CMsgGetZoomResponse) ne(b CMsgGetZoomResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgGetZoomResponse) eq(b []CMsgGetZoomResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgGetZoomResponse) ne(b []CMsgGetZoomResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsggetzoomresponse() CMsgGetZoomResponse {
			return CMsgGetZoomResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggetzoomresponse(o CMsgGetZoomResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggetzoomresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetZoomResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggetzoomresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgLinkAtPosition {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
x u32
y u32
}
pub fn (o &CMsgLinkAtPosition) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.x != u32(0) {
res << vproto.pack_uint32_field(o.x, 2)
}

if o.y != u32(0) {
res << vproto.pack_uint32_field(o.y, 3)
}

return res
}

pub fn cmsglinkatposition_unpack(buf []byte) ?CMsgLinkAtPosition {
mut res := zzz_vproto_internal_new_cmsglinkatposition()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.x = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.y = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgLinkAtPosition) eq(b CMsgLinkAtPosition) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.x == b.x
&& a.y == b.y
}
	[inline]
	pub fn (a CMsgLinkAtPosition) ne(b CMsgLinkAtPosition) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgLinkAtPosition) eq(b []CMsgLinkAtPosition) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgLinkAtPosition) ne(b []CMsgLinkAtPosition) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsglinkatposition() CMsgLinkAtPosition {
			return CMsgLinkAtPosition{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsglinkatposition(o CMsgLinkAtPosition, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsglinkatposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLinkAtPosition) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsglinkatposition_unpack(v)?
return i, unpacked
}
pub struct CMsgLinkAtPositionResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
x u32
y u32
url string
blivelink bool
binput bool
}
pub fn (o &CMsgLinkAtPositionResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.x != u32(0) {
res << vproto.pack_uint32_field(o.x, 2)
}

if o.y != u32(0) {
res << vproto.pack_uint32_field(o.y, 3)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 4)
}

if o.blivelink != false {
res << vproto.pack_bool_field(o.blivelink, 5)
}

if o.binput != false {
res << vproto.pack_bool_field(o.binput, 6)
}

return res
}

pub fn cmsglinkatpositionresponse_unpack(buf []byte) ?CMsgLinkAtPositionResponse {
mut res := zzz_vproto_internal_new_cmsglinkatpositionresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.x = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.y = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.blivelink = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.binput = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgLinkAtPositionResponse) eq(b CMsgLinkAtPositionResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.x == b.x
&& a.y == b.y
&& a.url == b.url
&& a.blivelink == b.blivelink
&& a.binput == b.binput
}
	[inline]
	pub fn (a CMsgLinkAtPositionResponse) ne(b CMsgLinkAtPositionResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgLinkAtPositionResponse) eq(b []CMsgLinkAtPositionResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgLinkAtPositionResponse) ne(b []CMsgLinkAtPositionResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsglinkatpositionresponse() CMsgLinkAtPositionResponse {
			return CMsgLinkAtPositionResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsglinkatpositionresponse(o CMsgLinkAtPositionResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsglinkatpositionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLinkAtPositionResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsglinkatpositionresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgZoomToElementAtPosition {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
x u32
y u32
}
pub fn (o &CMsgZoomToElementAtPosition) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.x != u32(0) {
res << vproto.pack_uint32_field(o.x, 2)
}

if o.y != u32(0) {
res << vproto.pack_uint32_field(o.y, 3)
}

return res
}

pub fn cmsgzoomtoelementatposition_unpack(buf []byte) ?CMsgZoomToElementAtPosition {
mut res := zzz_vproto_internal_new_cmsgzoomtoelementatposition()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.x = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.y = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgZoomToElementAtPosition) eq(b CMsgZoomToElementAtPosition) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.x == b.x
&& a.y == b.y
}
	[inline]
	pub fn (a CMsgZoomToElementAtPosition) ne(b CMsgZoomToElementAtPosition) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgZoomToElementAtPosition) eq(b []CMsgZoomToElementAtPosition) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgZoomToElementAtPosition) ne(b []CMsgZoomToElementAtPosition) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgzoomtoelementatposition() CMsgZoomToElementAtPosition {
			return CMsgZoomToElementAtPosition{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgzoomtoelementatposition(o CMsgZoomToElementAtPosition, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgzoomtoelementatposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgZoomToElementAtPosition) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgzoomtoelementatposition_unpack(v)?
return i, unpacked
}
pub struct CMsgZoomToElementAtPositionResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
scale f32
duration f32
}
pub fn (o &CMsgZoomToElementAtPositionResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.scale != f32(0) {
res << vproto.pack_float_field(o.scale, 2)
}

if o.duration != f32(0) {
res << vproto.pack_float_field(o.duration, 3)
}

return res
}

pub fn cmsgzoomtoelementatpositionresponse_unpack(buf []byte) ?CMsgZoomToElementAtPositionResponse {
mut res := zzz_vproto_internal_new_cmsgzoomtoelementatpositionresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.scale = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.duration = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgZoomToElementAtPositionResponse) eq(b CMsgZoomToElementAtPositionResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.scale == b.scale
&& a.duration == b.duration
}
	[inline]
	pub fn (a CMsgZoomToElementAtPositionResponse) ne(b CMsgZoomToElementAtPositionResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgZoomToElementAtPositionResponse) eq(b []CMsgZoomToElementAtPositionResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgZoomToElementAtPositionResponse) ne(b []CMsgZoomToElementAtPositionResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgzoomtoelementatpositionresponse() CMsgZoomToElementAtPositionResponse {
			return CMsgZoomToElementAtPositionResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgzoomtoelementatpositionresponse(o CMsgZoomToElementAtPositionResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgzoomtoelementatpositionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgZoomToElementAtPositionResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgzoomtoelementatpositionresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgScalePageToValue {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
scale f32
x f32
y f32
}
pub fn (o &CMsgScalePageToValue) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.scale != f32(0) {
res << vproto.pack_float_field(o.scale, 2)
}

if o.x != f32(0) {
res << vproto.pack_float_field(o.x, 3)
}

if o.y != f32(0) {
res << vproto.pack_float_field(o.y, 4)
}

return res
}

pub fn cmsgscalepagetovalue_unpack(buf []byte) ?CMsgScalePageToValue {
mut res := zzz_vproto_internal_new_cmsgscalepagetovalue()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.scale = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.x = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.y = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgScalePageToValue) eq(b CMsgScalePageToValue) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.scale == b.scale
&& a.x == b.x
&& a.y == b.y
}
	[inline]
	pub fn (a CMsgScalePageToValue) ne(b CMsgScalePageToValue) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgScalePageToValue) eq(b []CMsgScalePageToValue) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgScalePageToValue) ne(b []CMsgScalePageToValue) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgscalepagetovalue() CMsgScalePageToValue {
			return CMsgScalePageToValue{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgscalepagetovalue(o CMsgScalePageToValue, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgscalepagetovalue(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScalePageToValue) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgscalepagetovalue_unpack(v)?
return i, unpacked
}
pub struct CMsgForcePopupsToDirectHWND {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
force_direct_hwnd_popups bool
}
pub fn (o &CMsgForcePopupsToDirectHWND) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.force_direct_hwnd_popups != false {
res << vproto.pack_bool_field(o.force_direct_hwnd_popups, 2)
}

return res
}

pub fn cmsgforcepopupstodirecthwnd_unpack(buf []byte) ?CMsgForcePopupsToDirectHWND {
mut res := zzz_vproto_internal_new_cmsgforcepopupstodirecthwnd()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.force_direct_hwnd_popups = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgForcePopupsToDirectHWND) eq(b CMsgForcePopupsToDirectHWND) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.force_direct_hwnd_popups == b.force_direct_hwnd_popups
}
	[inline]
	pub fn (a CMsgForcePopupsToDirectHWND) ne(b CMsgForcePopupsToDirectHWND) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgForcePopupsToDirectHWND) eq(b []CMsgForcePopupsToDirectHWND) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgForcePopupsToDirectHWND) ne(b []CMsgForcePopupsToDirectHWND) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgforcepopupstodirecthwnd() CMsgForcePopupsToDirectHWND {
			return CMsgForcePopupsToDirectHWND{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgforcepopupstodirecthwnd(o CMsgForcePopupsToDirectHWND, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgforcepopupstodirecthwnd(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgForcePopupsToDirectHWND) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgforcepopupstodirecthwnd_unpack(v)?
return i, unpacked
}
pub struct CMsgScalePageToValueResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
zoom f32
}
pub fn (o &CMsgScalePageToValueResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.zoom != f32(0) {
res << vproto.pack_float_field(o.zoom, 2)
}

return res
}

pub fn cmsgscalepagetovalueresponse_unpack(buf []byte) ?CMsgScalePageToValueResponse {
mut res := zzz_vproto_internal_new_cmsgscalepagetovalueresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.zoom = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgScalePageToValueResponse) eq(b CMsgScalePageToValueResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.zoom == b.zoom
}
	[inline]
	pub fn (a CMsgScalePageToValueResponse) ne(b CMsgScalePageToValueResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgScalePageToValueResponse) eq(b []CMsgScalePageToValueResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgScalePageToValueResponse) ne(b []CMsgScalePageToValueResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgscalepagetovalueresponse() CMsgScalePageToValueResponse {
			return CMsgScalePageToValueResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgscalepagetovalueresponse(o CMsgScalePageToValueResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgscalepagetovalueresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScalePageToValueResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgscalepagetovalueresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgSavePageToJPEG {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
filename string
width u32
height u32
}
pub fn (o &CMsgSavePageToJPEG) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.filename != '' {
res << vproto.pack_string_field(o.filename, 3)
}

if o.width != u32(0) {
res << vproto.pack_uint32_field(o.width, 4)
}

if o.height != u32(0) {
res << vproto.pack_uint32_field(o.height, 5)
}

return res
}

pub fn cmsgsavepagetojpeg_unpack(buf []byte) ?CMsgSavePageToJPEG {
mut res := zzz_vproto_internal_new_cmsgsavepagetojpeg()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.filename = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.width = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.height = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSavePageToJPEG) eq(b CMsgSavePageToJPEG) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.filename == b.filename
&& a.width == b.width
&& a.height == b.height
}
	[inline]
	pub fn (a CMsgSavePageToJPEG) ne(b CMsgSavePageToJPEG) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSavePageToJPEG) eq(b []CMsgSavePageToJPEG) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSavePageToJPEG) ne(b []CMsgSavePageToJPEG) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsavepagetojpeg() CMsgSavePageToJPEG {
			return CMsgSavePageToJPEG{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsavepagetojpeg(o CMsgSavePageToJPEG, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsavepagetojpeg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSavePageToJPEG) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsavepagetojpeg_unpack(v)?
return i, unpacked
}
pub struct CMsgSavePageToJPEGResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
filename string
}
pub fn (o &CMsgSavePageToJPEGResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.filename != '' {
res << vproto.pack_string_field(o.filename, 3)
}

return res
}

pub fn cmsgsavepagetojpegresponse_unpack(buf []byte) ?CMsgSavePageToJPEGResponse {
mut res := zzz_vproto_internal_new_cmsgsavepagetojpegresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.filename = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSavePageToJPEGResponse) eq(b CMsgSavePageToJPEGResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.filename == b.filename
}
	[inline]
	pub fn (a CMsgSavePageToJPEGResponse) ne(b CMsgSavePageToJPEGResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSavePageToJPEGResponse) eq(b []CMsgSavePageToJPEGResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSavePageToJPEGResponse) ne(b []CMsgSavePageToJPEGResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsavepagetojpegresponse() CMsgSavePageToJPEGResponse {
			return CMsgSavePageToJPEGResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsavepagetojpegresponse(o CMsgSavePageToJPEGResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsavepagetojpegresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSavePageToJPEGResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsavepagetojpegresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgJSAlert {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
message string
}
pub fn (o &CMsgJSAlert) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.message != '' {
res << vproto.pack_string_field(o.message, 2)
}

return res
}

pub fn cmsgjsalert_unpack(buf []byte) ?CMsgJSAlert {
mut res := zzz_vproto_internal_new_cmsgjsalert()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.message = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJSAlert) eq(b CMsgJSAlert) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.message == b.message
}
	[inline]
	pub fn (a CMsgJSAlert) ne(b CMsgJSAlert) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJSAlert) eq(b []CMsgJSAlert) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJSAlert) ne(b []CMsgJSAlert) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjsalert() CMsgJSAlert {
			return CMsgJSAlert{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsalert(o CMsgJSAlert, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsalert(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSAlert) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjsalert_unpack(v)?
return i, unpacked
}
pub struct CMsgJSConfirm {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
message string
}
pub fn (o &CMsgJSConfirm) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.message != '' {
res << vproto.pack_string_field(o.message, 2)
}

return res
}

pub fn cmsgjsconfirm_unpack(buf []byte) ?CMsgJSConfirm {
mut res := zzz_vproto_internal_new_cmsgjsconfirm()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.message = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJSConfirm) eq(b CMsgJSConfirm) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.message == b.message
}
	[inline]
	pub fn (a CMsgJSConfirm) ne(b CMsgJSConfirm) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJSConfirm) eq(b []CMsgJSConfirm) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJSConfirm) ne(b []CMsgJSConfirm) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjsconfirm() CMsgJSConfirm {
			return CMsgJSConfirm{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsconfirm(o CMsgJSConfirm, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsconfirm(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSConfirm) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjsconfirm_unpack(v)?
return i, unpacked
}
pub struct CMsgJSDialogResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
result bool
}
pub fn (o &CMsgJSDialogResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.result != false {
res << vproto.pack_bool_field(o.result, 2)
}

return res
}

pub fn cmsgjsdialogresponse_unpack(buf []byte) ?CMsgJSDialogResponse {
mut res := zzz_vproto_internal_new_cmsgjsdialogresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.result = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJSDialogResponse) eq(b CMsgJSDialogResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.result == b.result
}
	[inline]
	pub fn (a CMsgJSDialogResponse) ne(b CMsgJSDialogResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJSDialogResponse) eq(b []CMsgJSDialogResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJSDialogResponse) ne(b []CMsgJSDialogResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjsdialogresponse() CMsgJSDialogResponse {
			return CMsgJSDialogResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsdialogresponse(o CMsgJSDialogResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsdialogresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSDialogResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjsdialogresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgCanGoBackAndForward {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
bgoback bool
bgoforward bool
}
pub fn (o &CMsgCanGoBackAndForward) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.bgoback != false {
res << vproto.pack_bool_field(o.bgoback, 2)
}

if o.bgoforward != false {
res << vproto.pack_bool_field(o.bgoforward, 3)
}

return res
}

pub fn cmsgcangobackandforward_unpack(buf []byte) ?CMsgCanGoBackAndForward {
mut res := zzz_vproto_internal_new_cmsgcangobackandforward()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.bgoback = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.bgoforward = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgCanGoBackAndForward) eq(b CMsgCanGoBackAndForward) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.bgoback == b.bgoback
&& a.bgoforward == b.bgoforward
}
	[inline]
	pub fn (a CMsgCanGoBackAndForward) ne(b CMsgCanGoBackAndForward) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgCanGoBackAndForward) eq(b []CMsgCanGoBackAndForward) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgCanGoBackAndForward) ne(b []CMsgCanGoBackAndForward) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgcangobackandforward() CMsgCanGoBackAndForward {
			return CMsgCanGoBackAndForward{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgcangobackandforward(o CMsgCanGoBackAndForward, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgcangobackandforward(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCanGoBackAndForward) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcangobackandforward_unpack(v)?
return i, unpacked
}
pub struct CMsgOpenSteamURL {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
referrer string
}
pub fn (o &CMsgOpenSteamURL) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

if o.referrer != '' {
res << vproto.pack_string_field(o.referrer, 3)
}

return res
}

pub fn cmsgopensteamurl_unpack(buf []byte) ?CMsgOpenSteamURL {
mut res := zzz_vproto_internal_new_cmsgopensteamurl()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.referrer = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgOpenSteamURL) eq(b CMsgOpenSteamURL) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.referrer == b.referrer
}
	[inline]
	pub fn (a CMsgOpenSteamURL) ne(b CMsgOpenSteamURL) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgOpenSteamURL) eq(b []CMsgOpenSteamURL) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgOpenSteamURL) ne(b []CMsgOpenSteamURL) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgopensteamurl() CMsgOpenSteamURL {
			return CMsgOpenSteamURL{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgopensteamurl(o CMsgOpenSteamURL, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgopensteamurl(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgOpenSteamURL) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgopensteamurl_unpack(v)?
return i, unpacked
}
pub struct CMsgSetCookie {
mut:
unknown_fields []vproto.UnknownField
pub mut:
key string
value string
path string
host string
expires u32
secure bool
httponly bool
}
pub fn (o &CMsgSetCookie) pack() []byte {
mut res := []byte{}
if o.key != '' {
res << vproto.pack_string_field(o.key, 1)
}

if o.value != '' {
res << vproto.pack_string_field(o.value, 2)
}

if o.path != '' {
res << vproto.pack_string_field(o.path, 3)
}

if o.host != '' {
res << vproto.pack_string_field(o.host, 4)
}

if o.expires != u32(0) {
res << vproto.pack_uint32_field(o.expires, 5)
}

if o.secure != false {
res << vproto.pack_bool_field(o.secure, 6)
}

if o.httponly != false {
res << vproto.pack_bool_field(o.httponly, 7)
}

return res
}

pub fn cmsgsetcookie_unpack(buf []byte) ?CMsgSetCookie {
mut res := zzz_vproto_internal_new_cmsgsetcookie()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.key = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.value = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.path = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.host = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.expires = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.secure = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.httponly = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetCookie) eq(b CMsgSetCookie) bool {
		return true
&& a.key == b.key
&& a.value == b.value
&& a.path == b.path
&& a.host == b.host
&& a.expires == b.expires
&& a.secure == b.secure
&& a.httponly == b.httponly
}
	[inline]
	pub fn (a CMsgSetCookie) ne(b CMsgSetCookie) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetCookie) eq(b []CMsgSetCookie) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetCookie) ne(b []CMsgSetCookie) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetcookie() CMsgSetCookie {
			return CMsgSetCookie{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetcookie(o CMsgSetCookie, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetcookie(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetCookie) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetcookie_unpack(v)?
return i, unpacked
}
pub struct CMsgSetTargetFrameRate {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
ntargetframerate u32
}
pub fn (o &CMsgSetTargetFrameRate) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.ntargetframerate != u32(0) {
res << vproto.pack_uint32_field(o.ntargetframerate, 2)
}

return res
}

pub fn cmsgsettargetframerate_unpack(buf []byte) ?CMsgSetTargetFrameRate {
mut res := zzz_vproto_internal_new_cmsgsettargetframerate()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.ntargetframerate = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetTargetFrameRate) eq(b CMsgSetTargetFrameRate) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.ntargetframerate == b.ntargetframerate
}
	[inline]
	pub fn (a CMsgSetTargetFrameRate) ne(b CMsgSetTargetFrameRate) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetTargetFrameRate) eq(b []CMsgSetTargetFrameRate) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetTargetFrameRate) ne(b []CMsgSetTargetFrameRate) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsettargetframerate() CMsgSetTargetFrameRate {
			return CMsgSetTargetFrameRate{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsettargetframerate(o CMsgSetTargetFrameRate, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsettargetframerate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetTargetFrameRate) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsettargetframerate_unpack(v)?
return i, unpacked
}
pub struct CMsgPauseRepaint {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgPauseRepaint) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgpauserepaint_unpack(buf []byte) ?CMsgPauseRepaint {
mut res := zzz_vproto_internal_new_cmsgpauserepaint()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgPauseRepaint) eq(b CMsgPauseRepaint) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgPauseRepaint) ne(b CMsgPauseRepaint) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgPauseRepaint) eq(b []CMsgPauseRepaint) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgPauseRepaint) ne(b []CMsgPauseRepaint) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgpauserepaint() CMsgPauseRepaint {
			return CMsgPauseRepaint{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpauserepaint(o CMsgPauseRepaint, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpauserepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPauseRepaint) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgpauserepaint_unpack(v)?
return i, unpacked
}
pub struct CMsgFullRepaint {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgFullRepaint) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgfullrepaint_unpack(buf []byte) ?CMsgFullRepaint {
mut res := zzz_vproto_internal_new_cmsgfullrepaint()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgFullRepaint) eq(b CMsgFullRepaint) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgFullRepaint) ne(b CMsgFullRepaint) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgFullRepaint) eq(b []CMsgFullRepaint) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgFullRepaint) ne(b []CMsgFullRepaint) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgfullrepaint() CMsgFullRepaint {
			return CMsgFullRepaint{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfullrepaint(o CMsgFullRepaint, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfullrepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFullRepaint) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfullrepaint_unpack(v)?
return i, unpacked
}
pub struct CMsgRequestFullScreen {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgRequestFullScreen) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgrequestfullscreen_unpack(buf []byte) ?CMsgRequestFullScreen {
mut res := zzz_vproto_internal_new_cmsgrequestfullscreen()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgRequestFullScreen) eq(b CMsgRequestFullScreen) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgRequestFullScreen) ne(b CMsgRequestFullScreen) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgRequestFullScreen) eq(b []CMsgRequestFullScreen) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgRequestFullScreen) ne(b []CMsgRequestFullScreen) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgrequestfullscreen() CMsgRequestFullScreen {
			return CMsgRequestFullScreen{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgrequestfullscreen(o CMsgRequestFullScreen, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgrequestfullscreen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRequestFullScreen) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgrequestfullscreen_unpack(v)?
return i, unpacked
}
pub struct CMsgExitFullScreen {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgExitFullScreen) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgexitfullscreen_unpack(buf []byte) ?CMsgExitFullScreen {
mut res := zzz_vproto_internal_new_cmsgexitfullscreen()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgExitFullScreen) eq(b CMsgExitFullScreen) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgExitFullScreen) ne(b CMsgExitFullScreen) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgExitFullScreen) eq(b []CMsgExitFullScreen) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgExitFullScreen) ne(b []CMsgExitFullScreen) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgexitfullscreen() CMsgExitFullScreen {
			return CMsgExitFullScreen{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgexitfullscreen(o CMsgExitFullScreen, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgexitfullscreen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgExitFullScreen) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgexitfullscreen_unpack(v)?
return i, unpacked
}
pub struct CMsgToggleFindInPageDialog {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgToggleFindInPageDialog) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgtogglefindinpagedialog_unpack(buf []byte) ?CMsgToggleFindInPageDialog {
mut res := zzz_vproto_internal_new_cmsgtogglefindinpagedialog()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgToggleFindInPageDialog) eq(b CMsgToggleFindInPageDialog) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgToggleFindInPageDialog) ne(b CMsgToggleFindInPageDialog) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgToggleFindInPageDialog) eq(b []CMsgToggleFindInPageDialog) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgToggleFindInPageDialog) ne(b []CMsgToggleFindInPageDialog) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgtogglefindinpagedialog() CMsgToggleFindInPageDialog {
			return CMsgToggleFindInPageDialog{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgtogglefindinpagedialog(o CMsgToggleFindInPageDialog, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgtogglefindinpagedialog(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgToggleFindInPageDialog) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgtogglefindinpagedialog_unpack(v)?
return i, unpacked
}
pub struct CMsgSetPIDShuttingDown {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgSetPIDShuttingDown) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgsetpidshuttingdown_unpack(buf []byte) ?CMsgSetPIDShuttingDown {
mut res := zzz_vproto_internal_new_cmsgsetpidshuttingdown()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetPIDShuttingDown) eq(b CMsgSetPIDShuttingDown) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgSetPIDShuttingDown) ne(b CMsgSetPIDShuttingDown) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetPIDShuttingDown) eq(b []CMsgSetPIDShuttingDown) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetPIDShuttingDown) ne(b []CMsgSetPIDShuttingDown) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetpidshuttingdown() CMsgSetPIDShuttingDown {
			return CMsgSetPIDShuttingDown{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetpidshuttingdown(o CMsgSetPIDShuttingDown, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetpidshuttingdown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetPIDShuttingDown) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetpidshuttingdown_unpack(v)?
return i, unpacked
}
pub struct CMsgDisableBackgroundThrottling {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgDisableBackgroundThrottling) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgdisablebackgroundthrottling_unpack(buf []byte) ?CMsgDisableBackgroundThrottling {
mut res := zzz_vproto_internal_new_cmsgdisablebackgroundthrottling()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgDisableBackgroundThrottling) eq(b CMsgDisableBackgroundThrottling) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgDisableBackgroundThrottling) ne(b CMsgDisableBackgroundThrottling) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgDisableBackgroundThrottling) eq(b []CMsgDisableBackgroundThrottling) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgDisableBackgroundThrottling) ne(b []CMsgDisableBackgroundThrottling) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgdisablebackgroundthrottling() CMsgDisableBackgroundThrottling {
			return CMsgDisableBackgroundThrottling{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgdisablebackgroundthrottling(o CMsgDisableBackgroundThrottling, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgdisablebackgroundthrottling(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDisableBackgroundThrottling) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdisablebackgroundthrottling_unpack(v)?
return i, unpacked
}
pub struct CMsgAckPIDShuttingDown {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgAckPIDShuttingDown) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgackpidshuttingdown_unpack(buf []byte) ?CMsgAckPIDShuttingDown {
mut res := zzz_vproto_internal_new_cmsgackpidshuttingdown()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgAckPIDShuttingDown) eq(b CMsgAckPIDShuttingDown) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgAckPIDShuttingDown) ne(b CMsgAckPIDShuttingDown) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgAckPIDShuttingDown) eq(b []CMsgAckPIDShuttingDown) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgAckPIDShuttingDown) ne(b []CMsgAckPIDShuttingDown) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgackpidshuttingdown() CMsgAckPIDShuttingDown {
			return CMsgAckPIDShuttingDown{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgackpidshuttingdown(o CMsgAckPIDShuttingDown, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgackpidshuttingdown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAckPIDShuttingDown) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgackpidshuttingdown_unpack(v)?
return i, unpacked
}
pub struct CMsgGetCookiesForURL {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
}
pub fn (o &CMsgGetCookiesForURL) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

return res
}

pub fn cmsggetcookiesforurl_unpack(buf []byte) ?CMsgGetCookiesForURL {
mut res := zzz_vproto_internal_new_cmsggetcookiesforurl()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgGetCookiesForURL) eq(b CMsgGetCookiesForURL) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
}
	[inline]
	pub fn (a CMsgGetCookiesForURL) ne(b CMsgGetCookiesForURL) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgGetCookiesForURL) eq(b []CMsgGetCookiesForURL) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgGetCookiesForURL) ne(b []CMsgGetCookiesForURL) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsggetcookiesforurl() CMsgGetCookiesForURL {
			return CMsgGetCookiesForURL{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggetcookiesforurl(o CMsgGetCookiesForURL, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggetcookiesforurl(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetCookiesForURL) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggetcookiesforurl_unpack(v)?
return i, unpacked
}
pub struct CCookie {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
value string
domain string
path string
}
pub fn (o &CCookie) pack() []byte {
mut res := []byte{}
if o.name != '' {
res << vproto.pack_string_field(o.name, 1)
}

if o.value != '' {
res << vproto.pack_string_field(o.value, 2)
}

if o.domain != '' {
res << vproto.pack_string_field(o.domain, 3)
}

if o.path != '' {
res << vproto.pack_string_field(o.path, 4)
}

return res
}

pub fn ccookie_unpack(buf []byte) ?CCookie {
mut res := zzz_vproto_internal_new_ccookie()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.value = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.domain = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.path = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CCookie) eq(b CCookie) bool {
		return true
&& a.name == b.name
&& a.value == b.value
&& a.domain == b.domain
&& a.path == b.path
}
	[inline]
	pub fn (a CCookie) ne(b CCookie) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CCookie) eq(b []CCookie) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CCookie) ne(b []CCookie) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_ccookie() CCookie {
			return CCookie{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccookie(o CCookie, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccookie(buf []byte, tag_wiretype vproto.WireType) ?(int, CCookie) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccookie_unpack(v)?
return i, unpacked
}
pub struct CMsgGetCookiesForURLResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
cookies []CCookie
}
pub fn (o &CMsgGetCookiesForURLResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

// [packed=false]
for _, x in o.cookies {
res << zzz_vproto_internal_pack_ccookie(x, 3)
}

return res
}

pub fn cmsggetcookiesforurlresponse_unpack(buf []byte) ?CMsgGetCookiesForURLResponse {
mut res := zzz_vproto_internal_new_cmsggetcookiesforurlresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_ccookie(cur_buf, tag_wiretype.wire_type)?
res.cookies << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgGetCookiesForURLResponse) eq(b CMsgGetCookiesForURLResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
&& a.cookies.eq(b.cookies)
}
	[inline]
	pub fn (a CMsgGetCookiesForURLResponse) ne(b CMsgGetCookiesForURLResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgGetCookiesForURLResponse) eq(b []CMsgGetCookiesForURLResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgGetCookiesForURLResponse) ne(b []CMsgGetCookiesForURLResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsggetcookiesforurlresponse() CMsgGetCookiesForURLResponse {
			return CMsgGetCookiesForURLResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggetcookiesforurlresponse(o CMsgGetCookiesForURLResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggetcookiesforurlresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetCookiesForURLResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggetcookiesforurlresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgNodeHasFocus {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
binput bool
name string
elementtagname string
searchbuttontext string
bhasmultipleinputs bool
input_type string
}
pub fn (o &CMsgNodeHasFocus) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.binput != false {
res << vproto.pack_bool_field(o.binput, 2)
}

if o.name != '' {
res << vproto.pack_string_field(o.name, 3)
}

if o.elementtagname != '' {
res << vproto.pack_string_field(o.elementtagname, 4)
}

if o.searchbuttontext != '' {
res << vproto.pack_string_field(o.searchbuttontext, 5)
}

if o.bhasmultipleinputs != false {
res << vproto.pack_bool_field(o.bhasmultipleinputs, 6)
}

if o.input_type != '' {
res << vproto.pack_string_field(o.input_type, 7)
}

return res
}

pub fn cmsgnodehasfocus_unpack(buf []byte) ?CMsgNodeHasFocus {
mut res := zzz_vproto_internal_new_cmsgnodehasfocus()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.binput = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.elementtagname = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.searchbuttontext = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.bhasmultipleinputs = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.input_type = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgNodeHasFocus) eq(b CMsgNodeHasFocus) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.binput == b.binput
&& a.name == b.name
&& a.elementtagname == b.elementtagname
&& a.searchbuttontext == b.searchbuttontext
&& a.bhasmultipleinputs == b.bhasmultipleinputs
&& a.input_type == b.input_type
}
	[inline]
	pub fn (a CMsgNodeHasFocus) ne(b CMsgNodeHasFocus) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgNodeHasFocus) eq(b []CMsgNodeHasFocus) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgNodeHasFocus) ne(b []CMsgNodeHasFocus) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgnodehasfocus() CMsgNodeHasFocus {
			return CMsgNodeHasFocus{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgnodehasfocus(o CMsgNodeHasFocus, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgnodehasfocus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgNodeHasFocus) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgnodehasfocus_unpack(v)?
return i, unpacked
}
pub struct CMsgZoomToFocusedElement {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgZoomToFocusedElement) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgzoomtofocusedelement_unpack(buf []byte) ?CMsgZoomToFocusedElement {
mut res := zzz_vproto_internal_new_cmsgzoomtofocusedelement()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgZoomToFocusedElement) eq(b CMsgZoomToFocusedElement) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgZoomToFocusedElement) ne(b CMsgZoomToFocusedElement) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgZoomToFocusedElement) eq(b []CMsgZoomToFocusedElement) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgZoomToFocusedElement) ne(b []CMsgZoomToFocusedElement) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgzoomtofocusedelement() CMsgZoomToFocusedElement {
			return CMsgZoomToFocusedElement{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgzoomtofocusedelement(o CMsgZoomToFocusedElement, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgzoomtofocusedelement(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgZoomToFocusedElement) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgzoomtofocusedelement_unpack(v)?
return i, unpacked
}
pub struct CMsgCloseFullScreenFlashIfOpen {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgCloseFullScreenFlashIfOpen) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgclosefullscreenflashifopen_unpack(buf []byte) ?CMsgCloseFullScreenFlashIfOpen {
mut res := zzz_vproto_internal_new_cmsgclosefullscreenflashifopen()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgCloseFullScreenFlashIfOpen) eq(b CMsgCloseFullScreenFlashIfOpen) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgCloseFullScreenFlashIfOpen) ne(b CMsgCloseFullScreenFlashIfOpen) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgCloseFullScreenFlashIfOpen) eq(b []CMsgCloseFullScreenFlashIfOpen) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgCloseFullScreenFlashIfOpen) ne(b []CMsgCloseFullScreenFlashIfOpen) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgclosefullscreenflashifopen() CMsgCloseFullScreenFlashIfOpen {
			return CMsgCloseFullScreenFlashIfOpen{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclosefullscreenflashifopen(o CMsgCloseFullScreenFlashIfOpen, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclosefullscreenflashifopen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCloseFullScreenFlashIfOpen) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclosefullscreenflashifopen_unpack(v)?
return i, unpacked
}
pub struct CMsgPauseFullScreenFlashMovieIfOpen {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgPauseFullScreenFlashMovieIfOpen) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgpausefullscreenflashmovieifopen_unpack(buf []byte) ?CMsgPauseFullScreenFlashMovieIfOpen {
mut res := zzz_vproto_internal_new_cmsgpausefullscreenflashmovieifopen()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgPauseFullScreenFlashMovieIfOpen) eq(b CMsgPauseFullScreenFlashMovieIfOpen) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgPauseFullScreenFlashMovieIfOpen) ne(b CMsgPauseFullScreenFlashMovieIfOpen) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgPauseFullScreenFlashMovieIfOpen) eq(b []CMsgPauseFullScreenFlashMovieIfOpen) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgPauseFullScreenFlashMovieIfOpen) ne(b []CMsgPauseFullScreenFlashMovieIfOpen) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgpausefullscreenflashmovieifopen() CMsgPauseFullScreenFlashMovieIfOpen {
			return CMsgPauseFullScreenFlashMovieIfOpen{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpausefullscreenflashmovieifopen(o CMsgPauseFullScreenFlashMovieIfOpen, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpausefullscreenflashmovieifopen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPauseFullScreenFlashMovieIfOpen) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgpausefullscreenflashmovieifopen_unpack(v)?
return i, unpacked
}
pub struct CMsgFocusedNodeText {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgFocusedNodeText) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgfocusednodetext_unpack(buf []byte) ?CMsgFocusedNodeText {
mut res := zzz_vproto_internal_new_cmsgfocusednodetext()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgFocusedNodeText) eq(b CMsgFocusedNodeText) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgFocusedNodeText) ne(b CMsgFocusedNodeText) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgFocusedNodeText) eq(b []CMsgFocusedNodeText) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgFocusedNodeText) ne(b []CMsgFocusedNodeText) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgfocusednodetext() CMsgFocusedNodeText {
			return CMsgFocusedNodeText{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfocusednodetext(o CMsgFocusedNodeText, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfocusednodetext(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFocusedNodeText) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfocusednodetext_unpack(v)?
return i, unpacked
}
pub struct CMsgFocusedNodeTextResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
value string
}
pub fn (o &CMsgFocusedNodeTextResponse) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.value != '' {
res << vproto.pack_string_field(o.value, 2)
}

return res
}

pub fn cmsgfocusednodetextresponse_unpack(buf []byte) ?CMsgFocusedNodeTextResponse {
mut res := zzz_vproto_internal_new_cmsgfocusednodetextresponse()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.value = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgFocusedNodeTextResponse) eq(b CMsgFocusedNodeTextResponse) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.value == b.value
}
	[inline]
	pub fn (a CMsgFocusedNodeTextResponse) ne(b CMsgFocusedNodeTextResponse) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgFocusedNodeTextResponse) eq(b []CMsgFocusedNodeTextResponse) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgFocusedNodeTextResponse) ne(b []CMsgFocusedNodeTextResponse) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgfocusednodetextresponse() CMsgFocusedNodeTextResponse {
			return CMsgFocusedNodeTextResponse{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfocusednodetextresponse(o CMsgFocusedNodeTextResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfocusednodetextresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFocusedNodeTextResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfocusednodetextresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgBuildID {
mut:
unknown_fields []vproto.UnknownField
pub mut:
build_id u64
}
pub fn (o &CMsgBuildID) pack() []byte {
mut res := []byte{}
if o.build_id != u64(0) {
res << vproto.pack_uint64_field(o.build_id, 1)
}

return res
}

pub fn cmsgbuildid_unpack(buf []byte) ?CMsgBuildID {
mut res := zzz_vproto_internal_new_cmsgbuildid()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.build_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBuildID) eq(b CMsgBuildID) bool {
		return true
&& a.build_id == b.build_id
}
	[inline]
	pub fn (a CMsgBuildID) ne(b CMsgBuildID) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBuildID) eq(b []CMsgBuildID) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBuildID) ne(b []CMsgBuildID) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbuildid() CMsgBuildID {
			return CMsgBuildID{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbuildid(o CMsgBuildID, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbuildid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBuildID) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbuildid_unpack(v)?
return i, unpacked
}
pub struct CMsgOpenDevTools {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgOpenDevTools) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgopendevtools_unpack(buf []byte) ?CMsgOpenDevTools {
mut res := zzz_vproto_internal_new_cmsgopendevtools()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgOpenDevTools) eq(b CMsgOpenDevTools) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgOpenDevTools) ne(b CMsgOpenDevTools) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgOpenDevTools) eq(b []CMsgOpenDevTools) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgOpenDevTools) ne(b []CMsgOpenDevTools) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgopendevtools() CMsgOpenDevTools {
			return CMsgOpenDevTools{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgopendevtools(o CMsgOpenDevTools, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgopendevtools(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgOpenDevTools) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgopendevtools_unpack(v)?
return i, unpacked
}
pub struct CMsgCloseDevTools {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgCloseDevTools) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgclosedevtools_unpack(buf []byte) ?CMsgCloseDevTools {
mut res := zzz_vproto_internal_new_cmsgclosedevtools()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgCloseDevTools) eq(b CMsgCloseDevTools) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgCloseDevTools) ne(b CMsgCloseDevTools) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgCloseDevTools) eq(b []CMsgCloseDevTools) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgCloseDevTools) ne(b []CMsgCloseDevTools) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgclosedevtools() CMsgCloseDevTools {
			return CMsgCloseDevTools{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclosedevtools(o CMsgCloseDevTools, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclosedevtools(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCloseDevTools) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclosedevtools_unpack(v)?
return i, unpacked
}
pub struct CMsgUnlockH264 {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
unlock_code string
}
pub fn (o &CMsgUnlockH264) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.unlock_code != '' {
res << vproto.pack_string_field(o.unlock_code, 2)
}

return res
}

pub fn cmsgunlockh264_unpack(buf []byte) ?CMsgUnlockH264 {
mut res := zzz_vproto_internal_new_cmsgunlockh264()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.unlock_code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgUnlockH264) eq(b CMsgUnlockH264) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.unlock_code == b.unlock_code
}
	[inline]
	pub fn (a CMsgUnlockH264) ne(b CMsgUnlockH264) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgUnlockH264) eq(b []CMsgUnlockH264) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgUnlockH264) ne(b []CMsgUnlockH264) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgunlockh264() CMsgUnlockH264 {
			return CMsgUnlockH264{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgunlockh264(o CMsgUnlockH264, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgunlockh264(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgUnlockH264) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgunlockh264_unpack(v)?
return i, unpacked
}
pub struct CMsgScreenInformationChanged {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
override_width u32
override_height u32
monitor_left u32
monitor_top u32
monitor_right u32
monitor_bottom u32
usable_left u32
usable_top u32
usable_right u32
usable_bottom u32
}
pub fn (o &CMsgScreenInformationChanged) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.override_width != u32(0) {
res << vproto.pack_uint32_field(o.override_width, 2)
}

if o.override_height != u32(0) {
res << vproto.pack_uint32_field(o.override_height, 3)
}

if o.monitor_left != u32(0) {
res << vproto.pack_uint32_field(o.monitor_left, 4)
}

if o.monitor_top != u32(0) {
res << vproto.pack_uint32_field(o.monitor_top, 5)
}

if o.monitor_right != u32(0) {
res << vproto.pack_uint32_field(o.monitor_right, 6)
}

if o.monitor_bottom != u32(0) {
res << vproto.pack_uint32_field(o.monitor_bottom, 7)
}

if o.usable_left != u32(0) {
res << vproto.pack_uint32_field(o.usable_left, 8)
}

if o.usable_top != u32(0) {
res << vproto.pack_uint32_field(o.usable_top, 9)
}

if o.usable_right != u32(0) {
res << vproto.pack_uint32_field(o.usable_right, 10)
}

if o.usable_bottom != u32(0) {
res << vproto.pack_uint32_field(o.usable_bottom, 11)
}

return res
}

pub fn cmsgscreeninformationchanged_unpack(buf []byte) ?CMsgScreenInformationChanged {
mut res := zzz_vproto_internal_new_cmsgscreeninformationchanged()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.override_width = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.override_height = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.monitor_left = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.monitor_top = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.monitor_right = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.monitor_bottom = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

8 {
i, res.usable_left = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

9 {
i, res.usable_top = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

10 {
i, res.usable_right = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

11 {
i, res.usable_bottom = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgScreenInformationChanged) eq(b CMsgScreenInformationChanged) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.override_width == b.override_width
&& a.override_height == b.override_height
&& a.monitor_left == b.monitor_left
&& a.monitor_top == b.monitor_top
&& a.monitor_right == b.monitor_right
&& a.monitor_bottom == b.monitor_bottom
&& a.usable_left == b.usable_left
&& a.usable_top == b.usable_top
&& a.usable_right == b.usable_right
&& a.usable_bottom == b.usable_bottom
}
	[inline]
	pub fn (a CMsgScreenInformationChanged) ne(b CMsgScreenInformationChanged) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgScreenInformationChanged) eq(b []CMsgScreenInformationChanged) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgScreenInformationChanged) ne(b []CMsgScreenInformationChanged) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgscreeninformationchanged() CMsgScreenInformationChanged {
			return CMsgScreenInformationChanged{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgscreeninformationchanged(o CMsgScreenInformationChanged, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgscreeninformationchanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScreenInformationChanged) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgscreeninformationchanged_unpack(v)?
return i, unpacked
}
pub struct CMsgClearAllCookies {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgClearAllCookies) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgclearallcookies_unpack(buf []byte) ?CMsgClearAllCookies {
mut res := zzz_vproto_internal_new_cmsgclearallcookies()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgClearAllCookies) eq(b CMsgClearAllCookies) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgClearAllCookies) ne(b CMsgClearAllCookies) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgClearAllCookies) eq(b []CMsgClearAllCookies) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgClearAllCookies) ne(b []CMsgClearAllCookies) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgclearallcookies() CMsgClearAllCookies {
			return CMsgClearAllCookies{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclearallcookies(o CMsgClearAllCookies, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclearallcookies(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClearAllCookies) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclearallcookies_unpack(v)?
return i, unpacked
}
pub struct CMsgScreenDPI {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
dpi_scaling f32
}
pub fn (o &CMsgScreenDPI) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.dpi_scaling != f32(0) {
res << vproto.pack_float_field(o.dpi_scaling, 2)
}

return res
}

pub fn cmsgscreendpi_unpack(buf []byte) ?CMsgScreenDPI {
mut res := zzz_vproto_internal_new_cmsgscreendpi()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.dpi_scaling = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgScreenDPI) eq(b CMsgScreenDPI) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.dpi_scaling == b.dpi_scaling
}
	[inline]
	pub fn (a CMsgScreenDPI) ne(b CMsgScreenDPI) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgScreenDPI) eq(b []CMsgScreenDPI) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgScreenDPI) ne(b []CMsgScreenDPI) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgscreendpi() CMsgScreenDPI {
			return CMsgScreenDPI{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgscreendpi(o CMsgScreenDPI, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgscreendpi(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScreenDPI) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgscreendpi_unpack(v)?
return i, unpacked
}
pub struct CMsgAuthedSteamDomains {
mut:
unknown_fields []vproto.UnknownField
pub mut:
domains []string
}
pub fn (o &CMsgAuthedSteamDomains) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.domains {
res << vproto.pack_string_field(x, 1)
}

return res
}

pub fn cmsgauthedsteamdomains_unpack(buf []byte) ?CMsgAuthedSteamDomains {
mut res := zzz_vproto_internal_new_cmsgauthedsteamdomains()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.domains << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgAuthedSteamDomains) eq(b CMsgAuthedSteamDomains) bool {
		return true
&& a.domains == b.domains
}
	[inline]
	pub fn (a CMsgAuthedSteamDomains) ne(b CMsgAuthedSteamDomains) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgAuthedSteamDomains) eq(b []CMsgAuthedSteamDomains) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgAuthedSteamDomains) ne(b []CMsgAuthedSteamDomains) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgauthedsteamdomains() CMsgAuthedSteamDomains {
			return CMsgAuthedSteamDomains{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgauthedsteamdomains(o CMsgAuthedSteamDomains, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgauthedsteamdomains(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAuthedSteamDomains) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgauthedsteamdomains_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamAuthNeeded {
mut:
unknown_fields []vproto.UnknownField
pub mut:
filler bool
}
pub fn (o &CMsgSteamAuthNeeded) pack() []byte {
mut res := []byte{}
if o.filler != false {
res << vproto.pack_bool_field(o.filler, 1)
}

return res
}

pub fn cmsgsteamauthneeded_unpack(buf []byte) ?CMsgSteamAuthNeeded {
mut res := zzz_vproto_internal_new_cmsgsteamauthneeded()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.filler = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSteamAuthNeeded) eq(b CMsgSteamAuthNeeded) bool {
		return true
&& a.filler == b.filler
}
	[inline]
	pub fn (a CMsgSteamAuthNeeded) ne(b CMsgSteamAuthNeeded) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSteamAuthNeeded) eq(b []CMsgSteamAuthNeeded) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSteamAuthNeeded) ne(b []CMsgSteamAuthNeeded) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsteamauthneeded() CMsgSteamAuthNeeded {
			return CMsgSteamAuthNeeded{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamauthneeded(o CMsgSteamAuthNeeded, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamauthneeded(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamAuthNeeded) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamauthneeded_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamAuthCookiesSet {
mut:
unknown_fields []vproto.UnknownField
pub mut:
success bool
}
pub fn (o &CMsgSteamAuthCookiesSet) pack() []byte {
mut res := []byte{}
if o.success != false {
res << vproto.pack_bool_field(o.success, 1)
}

return res
}

pub fn cmsgsteamauthcookiesset_unpack(buf []byte) ?CMsgSteamAuthCookiesSet {
mut res := zzz_vproto_internal_new_cmsgsteamauthcookiesset()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.success = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSteamAuthCookiesSet) eq(b CMsgSteamAuthCookiesSet) bool {
		return true
&& a.success == b.success
}
	[inline]
	pub fn (a CMsgSteamAuthCookiesSet) ne(b CMsgSteamAuthCookiesSet) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSteamAuthCookiesSet) eq(b []CMsgSteamAuthCookiesSet) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSteamAuthCookiesSet) ne(b []CMsgSteamAuthCookiesSet) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsteamauthcookiesset() CMsgSteamAuthCookiesSet {
			return CMsgSteamAuthCookiesSet{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamauthcookiesset(o CMsgSteamAuthCookiesSet, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamauthcookiesset(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamAuthCookiesSet) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamauthcookiesset_unpack(v)?
return i, unpacked
}
pub struct CMsgJSRegisterMethod {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
name string
method_type EJSRegisterMethodType
 = .k_ejsregistermethodtype_invalid
}
pub fn (o &CMsgJSRegisterMethod) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.name != '' {
res << vproto.pack_string_field(o.name, 2)
}

if o.method_type != zzz_vproto_internal_new_ejsregistermethodtype() {
res << zzz_vproto_internal_pack_ejsregistermethodtype(o.method_type, 3)
}

return res
}

pub fn cmsgjsregistermethod_unpack(buf []byte) ?CMsgJSRegisterMethod {
mut res := zzz_vproto_internal_new_cmsgjsregistermethod()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.method_type = zzz_vproto_internal_unpack_ejsregistermethodtype(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJSRegisterMethod) eq(b CMsgJSRegisterMethod) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.name == b.name
&& a.method_type == b.method_type
}
	[inline]
	pub fn (a CMsgJSRegisterMethod) ne(b CMsgJSRegisterMethod) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJSRegisterMethod) eq(b []CMsgJSRegisterMethod) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJSRegisterMethod) ne(b []CMsgJSRegisterMethod) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjsregistermethod() CMsgJSRegisterMethod {
			return CMsgJSRegisterMethod{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsregistermethod(o CMsgJSRegisterMethod, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsregistermethod(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSRegisterMethod) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjsregistermethod_unpack(v)?
return i, unpacked
}
pub struct CJSMethodArgument {
mut:
unknown_fields []vproto.UnknownField
pub mut:
json_data string
function_handle u64
}
pub fn (o &CJSMethodArgument) pack() []byte {
mut res := []byte{}
if o.json_data != '' {
res << vproto.pack_string_field(o.json_data, 1)
}

if o.function_handle != u64(0) {
res << vproto.pack_uint64_field(o.function_handle, 2)
}

return res
}

pub fn cjsmethodargument_unpack(buf []byte) ?CJSMethodArgument {
mut res := zzz_vproto_internal_new_cjsmethodargument()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.json_data = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.function_handle = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CJSMethodArgument) eq(b CJSMethodArgument) bool {
		return true
&& a.json_data == b.json_data
&& a.function_handle == b.function_handle
}
	[inline]
	pub fn (a CJSMethodArgument) ne(b CJSMethodArgument) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CJSMethodArgument) eq(b []CJSMethodArgument) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CJSMethodArgument) ne(b []CJSMethodArgument) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cjsmethodargument() CJSMethodArgument {
			return CJSMethodArgument{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cjsmethodargument(o CJSMethodArgument, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cjsmethodargument(buf []byte, tag_wiretype vproto.WireType) ?(int, CJSMethodArgument) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cjsmethodargument_unpack(v)?
return i, unpacked
}
pub struct CMsgJSValue_JSObjectProperty {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
value CMsgJSValue
}
pub fn (o &CMsgJSValue_JSObjectProperty) pack() []byte {
mut res := []byte{}
if o.name != '' {
res << vproto.pack_string_field(o.name, 1)
}

if o.value.ne(zzz_vproto_internal_new_cmsgjsvalue()) {
res << zzz_vproto_internal_pack_cmsgjsvalue(o.value, 2)
}

return res
}

pub fn cmsgjsvalue_jsobjectproperty_unpack(buf []byte) ?CMsgJSValue_JSObjectProperty {
mut res := zzz_vproto_internal_new_cmsgjsvalue_jsobjectproperty()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.value = zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJSValue_JSObjectProperty) eq(b CMsgJSValue_JSObjectProperty) bool {
		return true
&& a.name == b.name
&& a.value.eq(b.value)
}
	[inline]
	pub fn (a CMsgJSValue_JSObjectProperty) ne(b CMsgJSValue_JSObjectProperty) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJSValue_JSObjectProperty) eq(b []CMsgJSValue_JSObjectProperty) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJSValue_JSObjectProperty) ne(b []CMsgJSValue_JSObjectProperty) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjsvalue_jsobjectproperty() CMsgJSValue_JSObjectProperty {
			return CMsgJSValue_JSObjectProperty{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsvalue_jsobjectproperty(o CMsgJSValue_JSObjectProperty, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsvalue_jsobjectproperty(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSValue_JSObjectProperty) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjsvalue_jsobjectproperty_unpack(v)?
return i, unpacked
}
pub struct CMsgJSValue {
mut:
unknown_fields []vproto.UnknownField
pub mut:
bool_value bool
int_value int
uint_value u32
double_value f64
string_value string
function_handle u64
is_array bool
array_values []CMsgJSValue
is_object bool
object_properties []CMsgJSValue_JSObjectProperty
}
pub fn (o &CMsgJSValue) pack() []byte {
mut res := []byte{}
if o.bool_value != false {
res << vproto.pack_bool_field(o.bool_value, 1)
}

if o.int_value != int(0) {
res << vproto.pack_int32_field(o.int_value, 2)
}

if o.uint_value != u32(0) {
res << vproto.pack_uint32_field(o.uint_value, 3)
}

if o.double_value != f64(0) {
res << vproto.pack_double_field(o.double_value, 4)
}

if o.string_value != '' {
res << vproto.pack_string_field(o.string_value, 5)
}

if o.function_handle != u64(0) {
res << vproto.pack_uint64_field(o.function_handle, 6)
}

if o.is_array != false {
res << vproto.pack_bool_field(o.is_array, 8)
}

// [packed=false]
for _, x in o.array_values {
res << zzz_vproto_internal_pack_cmsgjsvalue(x, 9)
}

if o.is_object != false {
res << vproto.pack_bool_field(o.is_object, 10)
}

// [packed=false]
for _, x in o.object_properties {
res << zzz_vproto_internal_pack_cmsgjsvalue_jsobjectproperty(x, 11)
}

return res
}

pub fn cmsgjsvalue_unpack(buf []byte) ?CMsgJSValue {
mut res := zzz_vproto_internal_new_cmsgjsvalue()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.bool_value = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.int_value = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.uint_value = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.double_value = vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.string_value = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.function_handle = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

8 {
i, res.is_array = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

9 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
res.array_values << v
i = ii
}

10 {
i, res.is_object = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

11 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgjsvalue_jsobjectproperty(cur_buf, tag_wiretype.wire_type)?
res.object_properties << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJSValue) eq(b CMsgJSValue) bool {
		return true
&& a.bool_value == b.bool_value
&& a.int_value == b.int_value
&& a.uint_value == b.uint_value
&& a.double_value == b.double_value
&& a.string_value == b.string_value
&& a.function_handle == b.function_handle
&& a.is_array == b.is_array
&& a.array_values.eq(b.array_values)
&& a.is_object == b.is_object
&& a.object_properties.eq(b.object_properties)
}
	[inline]
	pub fn (a CMsgJSValue) ne(b CMsgJSValue) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJSValue) eq(b []CMsgJSValue) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJSValue) ne(b []CMsgJSValue) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjsvalue() CMsgJSValue {
			return CMsgJSValue{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsvalue(o CMsgJSValue, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsvalue(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSValue) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjsvalue_unpack(v)?
return i, unpacked
}
pub struct CMsgJSMethodCall {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
name string
arguments []CMsgJSValue
}
pub fn (o &CMsgJSMethodCall) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.name != '' {
res << vproto.pack_string_field(o.name, 2)
}

// [packed=false]
for _, x in o.arguments {
res << zzz_vproto_internal_pack_cmsgjsvalue(x, 3)
}

return res
}

pub fn cmsgjsmethodcall_unpack(buf []byte) ?CMsgJSMethodCall {
mut res := zzz_vproto_internal_new_cmsgjsmethodcall()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
res.arguments << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJSMethodCall) eq(b CMsgJSMethodCall) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.name == b.name
&& a.arguments.eq(b.arguments)
}
	[inline]
	pub fn (a CMsgJSMethodCall) ne(b CMsgJSMethodCall) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJSMethodCall) eq(b []CMsgJSMethodCall) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJSMethodCall) ne(b []CMsgJSMethodCall) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjsmethodcall() CMsgJSMethodCall {
			return CMsgJSMethodCall{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsmethodcall(o CMsgJSMethodCall, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsmethodcall(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSMethodCall) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjsmethodcall_unpack(v)?
return i, unpacked
}
pub struct CMsgJSExecuteCallback {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
function_handle u64
arguments []CMsgJSValue
}
pub fn (o &CMsgJSExecuteCallback) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.function_handle != u64(0) {
res << vproto.pack_uint64_field(o.function_handle, 2)
}

// [packed=false]
for _, x in o.arguments {
res << zzz_vproto_internal_pack_cmsgjsvalue(x, 3)
}

return res
}

pub fn cmsgjsexecutecallback_unpack(buf []byte) ?CMsgJSExecuteCallback {
mut res := zzz_vproto_internal_new_cmsgjsexecutecallback()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.function_handle = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
res.arguments << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJSExecuteCallback) eq(b CMsgJSExecuteCallback) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.function_handle == b.function_handle
&& a.arguments.eq(b.arguments)
}
	[inline]
	pub fn (a CMsgJSExecuteCallback) ne(b CMsgJSExecuteCallback) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJSExecuteCallback) eq(b []CMsgJSExecuteCallback) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJSExecuteCallback) ne(b []CMsgJSExecuteCallback) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjsexecutecallback() CMsgJSExecuteCallback {
			return CMsgJSExecuteCallback{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsexecutecallback(o CMsgJSExecuteCallback, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsexecutecallback(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSExecuteCallback) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjsexecutecallback_unpack(v)?
return i, unpacked
}
pub struct CMsgJSReleaseCallback {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
function_handle u64
}
pub fn (o &CMsgJSReleaseCallback) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.function_handle != u64(0) {
res << vproto.pack_uint64_field(o.function_handle, 2)
}

return res
}

pub fn cmsgjsreleasecallback_unpack(buf []byte) ?CMsgJSReleaseCallback {
mut res := zzz_vproto_internal_new_cmsgjsreleasecallback()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.function_handle = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJSReleaseCallback) eq(b CMsgJSReleaseCallback) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.function_handle == b.function_handle
}
	[inline]
	pub fn (a CMsgJSReleaseCallback) ne(b CMsgJSReleaseCallback) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJSReleaseCallback) eq(b []CMsgJSReleaseCallback) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJSReleaseCallback) ne(b []CMsgJSReleaseCallback) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjsreleasecallback() CMsgJSReleaseCallback {
			return CMsgJSReleaseCallback{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsreleasecallback(o CMsgJSReleaseCallback, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsreleasecallback(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSReleaseCallback) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjsreleasecallback_unpack(v)?
return i, unpacked
}
pub struct CMsgJSRaiseException {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
exception string
}
pub fn (o &CMsgJSRaiseException) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.exception != '' {
res << vproto.pack_string_field(o.exception, 2)
}

return res
}

pub fn cmsgjsraiseexception_unpack(buf []byte) ?CMsgJSRaiseException {
mut res := zzz_vproto_internal_new_cmsgjsraiseexception()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.exception = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJSRaiseException) eq(b CMsgJSRaiseException) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.exception == b.exception
}
	[inline]
	pub fn (a CMsgJSRaiseException) ne(b CMsgJSRaiseException) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJSRaiseException) eq(b []CMsgJSRaiseException) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJSRaiseException) ne(b []CMsgJSRaiseException) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjsraiseexception() CMsgJSRaiseException {
			return CMsgJSRaiseException{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsraiseexception(o CMsgJSRaiseException, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsraiseexception(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSRaiseException) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjsraiseexception_unpack(v)?
return i, unpacked
}
pub struct CMsgLoadLocalization {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
localization_path string
language string
}
pub fn (o &CMsgLoadLocalization) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.localization_path != '' {
res << vproto.pack_string_field(o.localization_path, 2)
}

if o.language != '' {
res << vproto.pack_string_field(o.language, 3)
}

return res
}

pub fn cmsgloadlocalization_unpack(buf []byte) ?CMsgLoadLocalization {
mut res := zzz_vproto_internal_new_cmsgloadlocalization()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.localization_path = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.language = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgLoadLocalization) eq(b CMsgLoadLocalization) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.localization_path == b.localization_path
&& a.language == b.language
}
	[inline]
	pub fn (a CMsgLoadLocalization) ne(b CMsgLoadLocalization) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgLoadLocalization) eq(b []CMsgLoadLocalization) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgLoadLocalization) ne(b []CMsgLoadLocalization) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgloadlocalization() CMsgLoadLocalization {
			return CMsgLoadLocalization{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgloadlocalization(o CMsgLoadLocalization, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgloadlocalization(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLoadLocalization) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgloadlocalization_unpack(v)?
return i, unpacked
}
pub struct CMsgJumpListLink {
mut:
unknown_fields []vproto.UnknownField
pub mut:
display_name string
url_link string
icon_path string
}
pub fn (o &CMsgJumpListLink) pack() []byte {
mut res := []byte{}
if o.display_name != '' {
res << vproto.pack_string_field(o.display_name, 1)
}

if o.url_link != '' {
res << vproto.pack_string_field(o.url_link, 2)
}

if o.icon_path != '' {
res << vproto.pack_string_field(o.icon_path, 3)
}

return res
}

pub fn cmsgjumplistlink_unpack(buf []byte) ?CMsgJumpListLink {
mut res := zzz_vproto_internal_new_cmsgjumplistlink()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.display_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url_link = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.icon_path = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgJumpListLink) eq(b CMsgJumpListLink) bool {
		return true
&& a.display_name == b.display_name
&& a.url_link == b.url_link
&& a.icon_path == b.icon_path
}
	[inline]
	pub fn (a CMsgJumpListLink) ne(b CMsgJumpListLink) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgJumpListLink) eq(b []CMsgJumpListLink) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgJumpListLink) ne(b []CMsgJumpListLink) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjumplistlink() CMsgJumpListLink {
			return CMsgJumpListLink{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjumplistlink(o CMsgJumpListLink, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjumplistlink(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJumpListLink) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjumplistlink_unpack(v)?
return i, unpacked
}
pub struct CMSgJumpListMRUApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
display_name string
url_link string
icon_path string
}
pub fn (o &CMSgJumpListMRUApp) pack() []byte {
mut res := []byte{}
if o.appid != u32(0) {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.display_name != '' {
res << vproto.pack_string_field(o.display_name, 2)
}

if o.url_link != '' {
res << vproto.pack_string_field(o.url_link, 3)
}

if o.icon_path != '' {
res << vproto.pack_string_field(o.icon_path, 4)
}

return res
}

pub fn cmsgjumplistmruapp_unpack(buf []byte) ?CMSgJumpListMRUApp {
mut res := zzz_vproto_internal_new_cmsgjumplistmruapp()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.display_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.url_link = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.icon_path = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMSgJumpListMRUApp) eq(b CMSgJumpListMRUApp) bool {
		return true
&& a.appid == b.appid
&& a.display_name == b.display_name
&& a.url_link == b.url_link
&& a.icon_path == b.icon_path
}
	[inline]
	pub fn (a CMSgJumpListMRUApp) ne(b CMSgJumpListMRUApp) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMSgJumpListMRUApp) eq(b []CMSgJumpListMRUApp) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMSgJumpListMRUApp) ne(b []CMSgJumpListMRUApp) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgjumplistmruapp() CMSgJumpListMRUApp {
			return CMSgJumpListMRUApp{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjumplistmruapp(o CMSgJumpListMRUApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjumplistmruapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMSgJumpListMRUApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgjumplistmruapp_unpack(v)?
return i, unpacked
}
pub struct CMsgSetJumpList {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_path string
mru_title string
apps []CMSgJumpListMRUApp
links []CMsgJumpListLink
}
pub fn (o &CMsgSetJumpList) pack() []byte {
mut res := []byte{}
if o.steam_path != '' {
res << vproto.pack_string_field(o.steam_path, 1)
}

if o.mru_title != '' {
res << vproto.pack_string_field(o.mru_title, 2)
}

// [packed=false]
for _, x in o.apps {
res << zzz_vproto_internal_pack_cmsgjumplistmruapp(x, 3)
}

// [packed=false]
for _, x in o.links {
res << zzz_vproto_internal_pack_cmsgjumplistlink(x, 4)
}

return res
}

pub fn cmsgsetjumplist_unpack(buf []byte) ?CMsgSetJumpList {
mut res := zzz_vproto_internal_new_cmsgsetjumplist()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.steam_path = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.mru_title = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgjumplistmruapp(cur_buf, tag_wiretype.wire_type)?
res.apps << v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgjumplistlink(cur_buf, tag_wiretype.wire_type)?
res.links << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetJumpList) eq(b CMsgSetJumpList) bool {
		return true
&& a.steam_path == b.steam_path
&& a.mru_title == b.mru_title
&& a.apps.eq(b.apps)
&& a.links.eq(b.links)
}
	[inline]
	pub fn (a CMsgSetJumpList) ne(b CMsgSetJumpList) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetJumpList) eq(b []CMsgSetJumpList) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetJumpList) ne(b []CMsgSetJumpList) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetjumplist() CMsgSetJumpList {
			return CMsgSetJumpList{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetjumplist(o CMsgSetJumpList, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetjumplist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetJumpList) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetjumplist_unpack(v)?
return i, unpacked
}
pub struct CMsgSetGameOverlayTargetPIDs {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
target_pid []u32
}
pub fn (o &CMsgSetGameOverlayTargetPIDs) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

// [packed=false]
for _, x in o.target_pid {
res << vproto.pack_uint32_field(x, 2)
}

return res
}

pub fn cmsgsetgameoverlaytargetpids_unpack(buf []byte) ?CMsgSetGameOverlayTargetPIDs {
mut res := zzz_vproto_internal_new_cmsgsetgameoverlaytargetpids()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.target_pid << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetGameOverlayTargetPIDs) eq(b CMsgSetGameOverlayTargetPIDs) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.target_pid == b.target_pid
}
	[inline]
	pub fn (a CMsgSetGameOverlayTargetPIDs) ne(b CMsgSetGameOverlayTargetPIDs) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetGameOverlayTargetPIDs) eq(b []CMsgSetGameOverlayTargetPIDs) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetGameOverlayTargetPIDs) ne(b []CMsgSetGameOverlayTargetPIDs) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetgameoverlaytargetpids() CMsgSetGameOverlayTargetPIDs {
			return CMsgSetGameOverlayTargetPIDs{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetgameoverlaytargetpids(o CMsgSetGameOverlayTargetPIDs, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetgameoverlaytargetpids(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetGameOverlayTargetPIDs) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetgameoverlaytargetpids_unpack(v)?
return i, unpacked
}
pub struct CMsgGameOverlayTargetTextureID {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
target_pid u32
texture_handle u32
}
pub fn (o &CMsgGameOverlayTargetTextureID) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.target_pid != u32(0) {
res << vproto.pack_uint32_field(o.target_pid, 2)
}

if o.texture_handle != u32(0) {
res << vproto.pack_uint32_field(o.texture_handle, 3)
}

return res
}

pub fn cmsggameoverlaytargettextureid_unpack(buf []byte) ?CMsgGameOverlayTargetTextureID {
mut res := zzz_vproto_internal_new_cmsggameoverlaytargettextureid()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.target_pid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.texture_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgGameOverlayTargetTextureID) eq(b CMsgGameOverlayTargetTextureID) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.target_pid == b.target_pid
&& a.texture_handle == b.texture_handle
}
	[inline]
	pub fn (a CMsgGameOverlayTargetTextureID) ne(b CMsgGameOverlayTargetTextureID) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgGameOverlayTargetTextureID) eq(b []CMsgGameOverlayTargetTextureID) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgGameOverlayTargetTextureID) ne(b []CMsgGameOverlayTargetTextureID) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsggameoverlaytargettextureid() CMsgGameOverlayTargetTextureID {
			return CMsgGameOverlayTargetTextureID{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggameoverlaytargettextureid(o CMsgGameOverlayTargetTextureID, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggameoverlaytargettextureid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameOverlayTargetTextureID) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggameoverlaytargettextureid_unpack(v)?
return i, unpacked
}
pub struct CMsgDraggableRegionsChanged_DraggableRects {
mut:
unknown_fields []vproto.UnknownField
pub mut:
x int
y int
width int
height int
draggable bool
}
pub fn (o &CMsgDraggableRegionsChanged_DraggableRects) pack() []byte {
mut res := []byte{}
if o.x != int(0) {
res << vproto.pack_int32_field(o.x, 1)
}

if o.y != int(0) {
res << vproto.pack_int32_field(o.y, 2)
}

if o.width != int(0) {
res << vproto.pack_int32_field(o.width, 3)
}

if o.height != int(0) {
res << vproto.pack_int32_field(o.height, 4)
}

if o.draggable != false {
res << vproto.pack_bool_field(o.draggable, 5)
}

return res
}

pub fn cmsgdraggableregionschanged_draggablerects_unpack(buf []byte) ?CMsgDraggableRegionsChanged_DraggableRects {
mut res := zzz_vproto_internal_new_cmsgdraggableregionschanged_draggablerects()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.x = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.y = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.width = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.height = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.draggable = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgDraggableRegionsChanged_DraggableRects) eq(b CMsgDraggableRegionsChanged_DraggableRects) bool {
		return true
&& a.x == b.x
&& a.y == b.y
&& a.width == b.width
&& a.height == b.height
&& a.draggable == b.draggable
}
	[inline]
	pub fn (a CMsgDraggableRegionsChanged_DraggableRects) ne(b CMsgDraggableRegionsChanged_DraggableRects) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgDraggableRegionsChanged_DraggableRects) eq(b []CMsgDraggableRegionsChanged_DraggableRects) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgDraggableRegionsChanged_DraggableRects) ne(b []CMsgDraggableRegionsChanged_DraggableRects) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgdraggableregionschanged_draggablerects() CMsgDraggableRegionsChanged_DraggableRects {
			return CMsgDraggableRegionsChanged_DraggableRects{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgdraggableregionschanged_draggablerects(o CMsgDraggableRegionsChanged_DraggableRects, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgdraggableregionschanged_draggablerects(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDraggableRegionsChanged_DraggableRects) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdraggableregionschanged_draggablerects_unpack(v)?
return i, unpacked
}
pub struct CMsgDraggableRegionsChanged {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
rects []CMsgDraggableRegionsChanged_DraggableRects
}
pub fn (o &CMsgDraggableRegionsChanged) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

// [packed=false]
for _, x in o.rects {
res << zzz_vproto_internal_pack_cmsgdraggableregionschanged_draggablerects(x, 2)
}

return res
}

pub fn cmsgdraggableregionschanged_unpack(buf []byte) ?CMsgDraggableRegionsChanged {
mut res := zzz_vproto_internal_new_cmsgdraggableregionschanged()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgdraggableregionschanged_draggablerects(cur_buf, tag_wiretype.wire_type)?
res.rects << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgDraggableRegionsChanged) eq(b CMsgDraggableRegionsChanged) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.rects.eq(b.rects)
}
	[inline]
	pub fn (a CMsgDraggableRegionsChanged) ne(b CMsgDraggableRegionsChanged) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgDraggableRegionsChanged) eq(b []CMsgDraggableRegionsChanged) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgDraggableRegionsChanged) ne(b []CMsgDraggableRegionsChanged) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgdraggableregionschanged() CMsgDraggableRegionsChanged {
			return CMsgDraggableRegionsChanged{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgdraggableregionschanged(o CMsgDraggableRegionsChanged, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgdraggableregionschanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDraggableRegionsChanged) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdraggableregionschanged_unpack(v)?
return i, unpacked
}
pub struct CMsgResizeGripChanged {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
width int
height int
}
pub fn (o &CMsgResizeGripChanged) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.width != int(0) {
res << vproto.pack_int32_field(o.width, 2)
}

if o.height != int(0) {
res << vproto.pack_int32_field(o.height, 3)
}

return res
}

pub fn cmsgresizegripchanged_unpack(buf []byte) ?CMsgResizeGripChanged {
mut res := zzz_vproto_internal_new_cmsgresizegripchanged()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.width = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.height = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgResizeGripChanged) eq(b CMsgResizeGripChanged) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.width == b.width
&& a.height == b.height
}
	[inline]
	pub fn (a CMsgResizeGripChanged) ne(b CMsgResizeGripChanged) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgResizeGripChanged) eq(b []CMsgResizeGripChanged) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgResizeGripChanged) ne(b []CMsgResizeGripChanged) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgresizegripchanged() CMsgResizeGripChanged {
			return CMsgResizeGripChanged{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgresizegripchanged(o CMsgResizeGripChanged, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgresizegripchanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgResizeGripChanged) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgresizegripchanged_unpack(v)?
return i, unpacked
}
pub struct CMsgSetWindowPosition {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
x int
y int
width int
height int
min_width int
min_height int
}
pub fn (o &CMsgSetWindowPosition) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.x != int(0) {
res << vproto.pack_int32_field(o.x, 2)
}

if o.y != int(0) {
res << vproto.pack_int32_field(o.y, 3)
}

if o.width != int(0) {
res << vproto.pack_int32_field(o.width, 4)
}

if o.height != int(0) {
res << vproto.pack_int32_field(o.height, 5)
}

if o.min_width != int(0) {
res << vproto.pack_int32_field(o.min_width, 6)
}

if o.min_height != int(0) {
res << vproto.pack_int32_field(o.min_height, 7)
}

return res
}

pub fn cmsgsetwindowposition_unpack(buf []byte) ?CMsgSetWindowPosition {
mut res := zzz_vproto_internal_new_cmsgsetwindowposition()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.x = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.y = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

4 {
i, res.width = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

5 {
i, res.height = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

6 {
i, res.min_width = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

7 {
i, res.min_height = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetWindowPosition) eq(b CMsgSetWindowPosition) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.x == b.x
&& a.y == b.y
&& a.width == b.width
&& a.height == b.height
&& a.min_width == b.min_width
&& a.min_height == b.min_height
}
	[inline]
	pub fn (a CMsgSetWindowPosition) ne(b CMsgSetWindowPosition) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetWindowPosition) eq(b []CMsgSetWindowPosition) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetWindowPosition) ne(b []CMsgSetWindowPosition) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetwindowposition() CMsgSetWindowPosition {
			return CMsgSetWindowPosition{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetwindowposition(o CMsgSetWindowPosition, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetwindowposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetWindowPosition) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetwindowposition_unpack(v)?
return i, unpacked
}
pub struct CMsgShowWindow {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgShowWindow) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgshowwindow_unpack(buf []byte) ?CMsgShowWindow {
mut res := zzz_vproto_internal_new_cmsgshowwindow()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgShowWindow) eq(b CMsgShowWindow) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgShowWindow) ne(b CMsgShowWindow) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgShowWindow) eq(b []CMsgShowWindow) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgShowWindow) ne(b []CMsgShowWindow) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgshowwindow() CMsgShowWindow {
			return CMsgShowWindow{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgshowwindow(o CMsgShowWindow, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgshowwindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowWindow) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgshowwindow_unpack(v)?
return i, unpacked
}
pub struct CMsgHideWindow {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgHideWindow) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsghidewindow_unpack(buf []byte) ?CMsgHideWindow {
mut res := zzz_vproto_internal_new_cmsghidewindow()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgHideWindow) eq(b CMsgHideWindow) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgHideWindow) ne(b CMsgHideWindow) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgHideWindow) eq(b []CMsgHideWindow) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgHideWindow) ne(b []CMsgHideWindow) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsghidewindow() CMsgHideWindow {
			return CMsgHideWindow{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsghidewindow(o CMsgHideWindow, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsghidewindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHideWindow) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsghidewindow_unpack(v)?
return i, unpacked
}
pub struct CMsgBringWindowToFront {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgBringWindowToFront) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgbringwindowtofront_unpack(buf []byte) ?CMsgBringWindowToFront {
mut res := zzz_vproto_internal_new_cmsgbringwindowtofront()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgBringWindowToFront) eq(b CMsgBringWindowToFront) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgBringWindowToFront) ne(b CMsgBringWindowToFront) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgBringWindowToFront) eq(b []CMsgBringWindowToFront) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgBringWindowToFront) ne(b []CMsgBringWindowToFront) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgbringwindowtofront() CMsgBringWindowToFront {
			return CMsgBringWindowToFront{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbringwindowtofront(o CMsgBringWindowToFront, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbringwindowtofront(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBringWindowToFront) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbringwindowtofront_unpack(v)?
return i, unpacked
}
pub struct CMsgSetForegroundWindow {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgSetForegroundWindow) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgsetforegroundwindow_unpack(buf []byte) ?CMsgSetForegroundWindow {
mut res := zzz_vproto_internal_new_cmsgsetforegroundwindow()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgSetForegroundWindow) eq(b CMsgSetForegroundWindow) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgSetForegroundWindow) ne(b CMsgSetForegroundWindow) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgSetForegroundWindow) eq(b []CMsgSetForegroundWindow) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgSetForegroundWindow) ne(b []CMsgSetForegroundWindow) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgsetforegroundwindow() CMsgSetForegroundWindow {
			return CMsgSetForegroundWindow{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetforegroundwindow(o CMsgSetForegroundWindow, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetforegroundwindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetForegroundWindow) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsetforegroundwindow_unpack(v)?
return i, unpacked
}
pub struct CMsgMaximizeRestoreWindow {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgMaximizeRestoreWindow) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgmaximizerestorewindow_unpack(buf []byte) ?CMsgMaximizeRestoreWindow {
mut res := zzz_vproto_internal_new_cmsgmaximizerestorewindow()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgMaximizeRestoreWindow) eq(b CMsgMaximizeRestoreWindow) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgMaximizeRestoreWindow) ne(b CMsgMaximizeRestoreWindow) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgMaximizeRestoreWindow) eq(b []CMsgMaximizeRestoreWindow) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgMaximizeRestoreWindow) ne(b []CMsgMaximizeRestoreWindow) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgmaximizerestorewindow() CMsgMaximizeRestoreWindow {
			return CMsgMaximizeRestoreWindow{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmaximizerestorewindow(o CMsgMaximizeRestoreWindow, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmaximizerestorewindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMaximizeRestoreWindow) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgmaximizerestorewindow_unpack(v)?
return i, unpacked
}
pub struct CMsgMinimizeWindow {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgMinimizeWindow) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgminimizewindow_unpack(buf []byte) ?CMsgMinimizeWindow {
mut res := zzz_vproto_internal_new_cmsgminimizewindow()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgMinimizeWindow) eq(b CMsgMinimizeWindow) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgMinimizeWindow) ne(b CMsgMinimizeWindow) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgMinimizeWindow) eq(b []CMsgMinimizeWindow) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgMinimizeWindow) ne(b []CMsgMinimizeWindow) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgminimizewindow() CMsgMinimizeWindow {
			return CMsgMinimizeWindow{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgminimizewindow(o CMsgMinimizeWindow, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgminimizewindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMinimizeWindow) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgminimizewindow_unpack(v)?
return i, unpacked
}
pub struct CMsgShowBrowserContextMenu {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgShowBrowserContextMenu) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgshowbrowsercontextmenu_unpack(buf []byte) ?CMsgShowBrowserContextMenu {
mut res := zzz_vproto_internal_new_cmsgshowbrowsercontextmenu()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgShowBrowserContextMenu) eq(b CMsgShowBrowserContextMenu) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgShowBrowserContextMenu) ne(b CMsgShowBrowserContextMenu) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgShowBrowserContextMenu) eq(b []CMsgShowBrowserContextMenu) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgShowBrowserContextMenu) ne(b []CMsgShowBrowserContextMenu) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgshowbrowsercontextmenu() CMsgShowBrowserContextMenu {
			return CMsgShowBrowserContextMenu{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgshowbrowsercontextmenu(o CMsgShowBrowserContextMenu, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgshowbrowsercontextmenu(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowBrowserContextMenu) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgshowbrowsercontextmenu_unpack(v)?
return i, unpacked
}
pub struct CMsgImeSetComposition {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
text string
}
pub fn (o &CMsgImeSetComposition) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.text != '' {
res << vproto.pack_string_field(o.text, 2)
}

return res
}

pub fn cmsgimesetcomposition_unpack(buf []byte) ?CMsgImeSetComposition {
mut res := zzz_vproto_internal_new_cmsgimesetcomposition()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.text = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgImeSetComposition) eq(b CMsgImeSetComposition) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.text == b.text
}
	[inline]
	pub fn (a CMsgImeSetComposition) ne(b CMsgImeSetComposition) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgImeSetComposition) eq(b []CMsgImeSetComposition) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgImeSetComposition) ne(b []CMsgImeSetComposition) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgimesetcomposition() CMsgImeSetComposition {
			return CMsgImeSetComposition{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgimesetcomposition(o CMsgImeSetComposition, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgimesetcomposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeSetComposition) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgimesetcomposition_unpack(v)?
return i, unpacked
}
pub struct CMsgImeCommitText {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
text string
}
pub fn (o &CMsgImeCommitText) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.text != '' {
res << vproto.pack_string_field(o.text, 2)
}

return res
}

pub fn cmsgimecommittext_unpack(buf []byte) ?CMsgImeCommitText {
mut res := zzz_vproto_internal_new_cmsgimecommittext()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.text = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgImeCommitText) eq(b CMsgImeCommitText) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.text == b.text
}
	[inline]
	pub fn (a CMsgImeCommitText) ne(b CMsgImeCommitText) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgImeCommitText) eq(b []CMsgImeCommitText) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgImeCommitText) ne(b []CMsgImeCommitText) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgimecommittext() CMsgImeCommitText {
			return CMsgImeCommitText{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgimecommittext(o CMsgImeCommitText, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgimecommittext(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeCommitText) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgimecommittext_unpack(v)?
return i, unpacked
}
pub struct CMsgImeCancelComposition {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
}
pub fn (o &CMsgImeCancelComposition) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

return res
}

pub fn cmsgimecancelcomposition_unpack(buf []byte) ?CMsgImeCancelComposition {
mut res := zzz_vproto_internal_new_cmsgimecancelcomposition()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgImeCancelComposition) eq(b CMsgImeCancelComposition) bool {
		return true
&& a.browser_handle == b.browser_handle
}
	[inline]
	pub fn (a CMsgImeCancelComposition) ne(b CMsgImeCancelComposition) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgImeCancelComposition) eq(b []CMsgImeCancelComposition) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgImeCancelComposition) ne(b []CMsgImeCancelComposition) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgimecancelcomposition() CMsgImeCancelComposition {
			return CMsgImeCancelComposition{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgimecancelcomposition(o CMsgImeCancelComposition, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgimecancelcomposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeCancelComposition) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgimecancelcomposition_unpack(v)?
return i, unpacked
}
pub struct CMsgImeCompositionRangeChanged {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
x u32
y u32
}
pub fn (o &CMsgImeCompositionRangeChanged) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.x != u32(0) {
res << vproto.pack_uint32_field(o.x, 2)
}

if o.y != u32(0) {
res << vproto.pack_uint32_field(o.y, 3)
}

return res
}

pub fn cmsgimecompositionrangechanged_unpack(buf []byte) ?CMsgImeCompositionRangeChanged {
mut res := zzz_vproto_internal_new_cmsgimecompositionrangechanged()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.x = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.y = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgImeCompositionRangeChanged) eq(b CMsgImeCompositionRangeChanged) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.x == b.x
&& a.y == b.y
}
	[inline]
	pub fn (a CMsgImeCompositionRangeChanged) ne(b CMsgImeCompositionRangeChanged) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgImeCompositionRangeChanged) eq(b []CMsgImeCompositionRangeChanged) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgImeCompositionRangeChanged) ne(b []CMsgImeCompositionRangeChanged) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgimecompositionrangechanged() CMsgImeCompositionRangeChanged {
			return CMsgImeCompositionRangeChanged{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgimecompositionrangechanged(o CMsgImeCompositionRangeChanged, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgimecompositionrangechanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeCompositionRangeChanged) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgimecompositionrangechanged_unpack(v)?
return i, unpacked
}
pub struct CMsgInspectElement {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
x u32
y u32
}
pub fn (o &CMsgInspectElement) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.x != u32(0) {
res << vproto.pack_uint32_field(o.x, 2)
}

if o.y != u32(0) {
res << vproto.pack_uint32_field(o.y, 3)
}

return res
}

pub fn cmsginspectelement_unpack(buf []byte) ?CMsgInspectElement {
mut res := zzz_vproto_internal_new_cmsginspectelement()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.x = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

3 {
i, res.y = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgInspectElement) eq(b CMsgInspectElement) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.x == b.x
&& a.y == b.y
}
	[inline]
	pub fn (a CMsgInspectElement) ne(b CMsgInspectElement) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgInspectElement) eq(b []CMsgInspectElement) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgInspectElement) ne(b []CMsgInspectElement) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsginspectelement() CMsgInspectElement {
			return CMsgInspectElement{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsginspectelement(o CMsgInspectElement, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsginspectelement(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgInspectElement) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsginspectelement_unpack(v)?
return i, unpacked
}
pub struct CMsgDisableF5 {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
disable bool
}
pub fn (o &CMsgDisableF5) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.disable != false {
res << vproto.pack_bool_field(o.disable, 2)
}

return res
}

pub fn cmsgdisablef5_unpack(buf []byte) ?CMsgDisableF5 {
mut res := zzz_vproto_internal_new_cmsgdisablef5()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.disable = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgDisableF5) eq(b CMsgDisableF5) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.disable == b.disable
}
	[inline]
	pub fn (a CMsgDisableF5) ne(b CMsgDisableF5) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgDisableF5) eq(b []CMsgDisableF5) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgDisableF5) ne(b []CMsgDisableF5) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgdisablef5() CMsgDisableF5 {
			return CMsgDisableF5{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgdisablef5(o CMsgDisableF5, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgdisablef5(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDisableF5) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdisablef5_unpack(v)?
return i, unpacked
}
pub struct CMsgStartDownload {
mut:
unknown_fields []vproto.UnknownField
pub mut:
browser_handle u32
url string
}
pub fn (o &CMsgStartDownload) pack() []byte {
mut res := []byte{}
if o.browser_handle != u32(0) {
res << vproto.pack_uint32_field(o.browser_handle, 1)
}

if o.url != '' {
res << vproto.pack_string_field(o.url, 2)
}

return res
}

pub fn cmsgstartdownload_unpack(buf []byte) ?CMsgStartDownload {
mut res := zzz_vproto_internal_new_cmsgstartdownload()
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
i, res.browser_handle = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
}

2 {
i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}


	[inline]
	pub fn (a CMsgStartDownload) eq(b CMsgStartDownload) bool {
		return true
&& a.browser_handle == b.browser_handle
&& a.url == b.url
}
	[inline]
	pub fn (a CMsgStartDownload) ne(b CMsgStartDownload) bool {
		return !a.eq(b)
	}

	[inline]
	pub fn (a []CMsgStartDownload) eq(b []CMsgStartDownload) bool {
		if a.len != b.len { return false }
		for i, _ in a {
			if a[i].ne(b[i]) {
				return false
			}
		}
		return true
	}

	[inline]
	pub fn (a []CMsgStartDownload) ne(b []CMsgStartDownload) bool {
		return !a.eq(b)
	}
	


		// FOR INTERNAL USE ONLY
		[inline]
		pub fn zzz_vproto_internal_new_cmsgstartdownload() CMsgStartDownload {
			return CMsgStartDownload{}
		}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstartdownload(o CMsgStartDownload, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstartdownload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStartDownload) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgstartdownload_unpack(v)?
return i, unpacked
}
