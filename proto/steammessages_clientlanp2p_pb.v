// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CMsgClientLANP2PRequestChunks_ChunkKey {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	depot_id       u32
	sha            []byte
}

pub fn (o &CMsgClientLANP2PRequestChunks_ChunkKey) pack() []byte {
	mut res := []byte{}
	if o.depot_id != u32(0) {
		res << vproto.pack_uint32_field(o.depot_id, 1)
	}
	if o.sha != []byte{} {
		res << vproto.pack_bytes_field(o.sha, 2)
	}
	return res
}

pub fn cmsgclientlanp2prequestchunks_chunkkey_unpack(buf []byte) ?CMsgClientLANP2PRequestChunks_ChunkKey {
	mut res := zzz_vproto_internal_new_cmsgclientlanp2prequestchunks_chunkkey()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.depot_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.sha = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLANP2PRequestChunks_ChunkKey) eq(b CMsgClientLANP2PRequestChunks_ChunkKey) bool {
	return true && a.depot_id == b.depot_id && a.sha == b.sha
}

[inline]
pub fn (a CMsgClientLANP2PRequestChunks_ChunkKey) ne(b CMsgClientLANP2PRequestChunks_ChunkKey) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLANP2PRequestChunks_ChunkKey) eq(b []CMsgClientLANP2PRequestChunks_ChunkKey) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLANP2PRequestChunks_ChunkKey) ne(b []CMsgClientLANP2PRequestChunks_ChunkKey) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlanp2prequestchunks_chunkkey() CMsgClientLANP2PRequestChunks_ChunkKey {
	return CMsgClientLANP2PRequestChunks_ChunkKey{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlanp2prequestchunks_chunkkey(o CMsgClientLANP2PRequestChunks_ChunkKey, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlanp2prequestchunks_chunkkey(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLANP2PRequestChunks_ChunkKey) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlanp2prequestchunks_chunkkey_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLANP2PRequestChunks {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	chunk_keys     []CMsgClientLANP2PRequestChunks_ChunkKey
}

pub fn (o &CMsgClientLANP2PRequestChunks) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.chunk_keys {
		res << zzz_vproto_internal_pack_cmsgclientlanp2prequestchunks_chunkkey(x, 1)
	}
	return res
}

pub fn cmsgclientlanp2prequestchunks_unpack(buf []byte) ?CMsgClientLANP2PRequestChunks {
	mut res := zzz_vproto_internal_new_cmsgclientlanp2prequestchunks()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientlanp2prequestchunks_chunkkey(cur_buf,
					tag_wiretype.wire_type) ?
				res.chunk_keys << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLANP2PRequestChunks) eq(b CMsgClientLANP2PRequestChunks) bool {
	return true && a.chunk_keys.eq(b.chunk_keys)
}

[inline]
pub fn (a CMsgClientLANP2PRequestChunks) ne(b CMsgClientLANP2PRequestChunks) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLANP2PRequestChunks) eq(b []CMsgClientLANP2PRequestChunks) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLANP2PRequestChunks) ne(b []CMsgClientLANP2PRequestChunks) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlanp2prequestchunks() CMsgClientLANP2PRequestChunks {
	return CMsgClientLANP2PRequestChunks{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlanp2prequestchunks(o CMsgClientLANP2PRequestChunks, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlanp2prequestchunks(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLANP2PRequestChunks) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlanp2prequestchunks_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLANP2PRequestChunksResponse_ChunkData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         u32
	depot_id       u32
	sha            []byte
	chunk_data     []byte
	encrypted      bool
	compressed     bool
}

pub fn (o &CMsgClientLANP2PRequestChunksResponse_ChunkData) pack() []byte {
	mut res := []byte{}
	if o.result != u32(0) {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	if o.depot_id != u32(0) {
		res << vproto.pack_uint32_field(o.depot_id, 2)
	}
	if o.sha != []byte{} {
		res << vproto.pack_bytes_field(o.sha, 3)
	}
	if o.chunk_data != []byte{} {
		res << vproto.pack_bytes_field(o.chunk_data, 4)
	}
	if o.encrypted != false {
		res << vproto.pack_bool_field(o.encrypted, 5)
	}
	if o.compressed != false {
		res << vproto.pack_bool_field(o.compressed, 6)
	}
	return res
}

pub fn cmsgclientlanp2prequestchunksresponse_chunkdata_unpack(buf []byte) ?CMsgClientLANP2PRequestChunksResponse_ChunkData {
	mut res := zzz_vproto_internal_new_cmsgclientlanp2prequestchunksresponse_chunkdata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.result = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.depot_id = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.sha = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.chunk_data = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.encrypted = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.compressed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLANP2PRequestChunksResponse_ChunkData) eq(b CMsgClientLANP2PRequestChunksResponse_ChunkData) bool {
	return true && a.result == b.result && a.depot_id == b.depot_id && a.sha == b.sha &&
		a.chunk_data == b.chunk_data && a.encrypted == b.encrypted && a.compressed == b.compressed
}

[inline]
pub fn (a CMsgClientLANP2PRequestChunksResponse_ChunkData) ne(b CMsgClientLANP2PRequestChunksResponse_ChunkData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLANP2PRequestChunksResponse_ChunkData) eq(b []CMsgClientLANP2PRequestChunksResponse_ChunkData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLANP2PRequestChunksResponse_ChunkData) ne(b []CMsgClientLANP2PRequestChunksResponse_ChunkData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlanp2prequestchunksresponse_chunkdata() CMsgClientLANP2PRequestChunksResponse_ChunkData {
	return CMsgClientLANP2PRequestChunksResponse_ChunkData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlanp2prequestchunksresponse_chunkdata(o CMsgClientLANP2PRequestChunksResponse_ChunkData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlanp2prequestchunksresponse_chunkdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLANP2PRequestChunksResponse_ChunkData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlanp2prequestchunksresponse_chunkdata_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLANP2PRequestChunksResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	chunk_responses []CMsgClientLANP2PRequestChunksResponse_ChunkData
}

pub fn (o &CMsgClientLANP2PRequestChunksResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.chunk_responses {
		res <<
			zzz_vproto_internal_pack_cmsgclientlanp2prequestchunksresponse_chunkdata(x, 1)
	}
	return res
}

pub fn cmsgclientlanp2prequestchunksresponse_unpack(buf []byte) ?CMsgClientLANP2PRequestChunksResponse {
	mut res := zzz_vproto_internal_new_cmsgclientlanp2prequestchunksresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientlanp2prequestchunksresponse_chunkdata(cur_buf,
					tag_wiretype.wire_type) ?
				res.chunk_responses << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLANP2PRequestChunksResponse) eq(b CMsgClientLANP2PRequestChunksResponse) bool {
	return true && a.chunk_responses.eq(b.chunk_responses)
}

[inline]
pub fn (a CMsgClientLANP2PRequestChunksResponse) ne(b CMsgClientLANP2PRequestChunksResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLANP2PRequestChunksResponse) eq(b []CMsgClientLANP2PRequestChunksResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLANP2PRequestChunksResponse) ne(b []CMsgClientLANP2PRequestChunksResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlanp2prequestchunksresponse() CMsgClientLANP2PRequestChunksResponse {
	return CMsgClientLANP2PRequestChunksResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlanp2prequestchunksresponse(o CMsgClientLANP2PRequestChunksResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlanp2prequestchunksresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLANP2PRequestChunksResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlanp2prequestchunksresponse_unpack(v) ?
	return i, unpacked
}
