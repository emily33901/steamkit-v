// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EContentDeltaChunkDataLocation {
	k_econtentdeltachunkdatalocationinprotobuf = 0
	k_econtentdeltachunkdatalocationafterprotobuf = 1
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_econtentdeltachunkdatalocation() EContentDeltaChunkDataLocation {
	return .k_econtentdeltachunkdatalocationinprotobuf
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_econtentdeltachunkdatalocation(e EContentDeltaChunkDataLocation, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_econtentdeltachunkdatalocation_packed(e []EContentDeltaChunkDataLocation, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_econtentdeltachunkdatalocation(buf []byte, tag_wiretype vproto.WireType) ?(int, EContentDeltaChunkDataLocation) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, EContentDeltaChunkDataLocation(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_econtentdeltachunkdatalocation_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EContentDeltaChunkDataLocation) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct ContentManifestPayloadFileMapping_ChunkData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sha            []byte
	crc            u32
	offset         u64
	cb_original    u32
	cb_compressed  u32
}

pub fn (o &ContentManifestPayloadFileMapping_ChunkData) pack() []byte {
	mut res := []byte{}
	if o.sha != []byte{} {
		res << vproto.pack_bytes_field(o.sha, 1)
	}
	if o.crc != u32(0) {
		res << vproto.pack_32bit_field(o.crc, 2)
	}
	if o.offset != u64(0) {
		res << vproto.pack_uint64_field(o.offset, 3)
	}
	if o.cb_original != u32(0) {
		res << vproto.pack_uint32_field(o.cb_original, 4)
	}
	if o.cb_compressed != u32(0) {
		res << vproto.pack_uint32_field(o.cb_compressed, 5)
	}
	return res
}

pub fn contentmanifestpayloadfilemapping_chunkdata_unpack(buf []byte) ?ContentManifestPayloadFileMapping_ChunkData {
	mut res := zzz_vproto_internal_new_contentmanifestpayloadfilemapping_chunkdata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.sha = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.crc = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.offset = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.cb_original = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.cb_compressed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ContentManifestPayloadFileMapping_ChunkData) eq(b ContentManifestPayloadFileMapping_ChunkData) bool {
	return true && a.sha == b.sha && a.crc == b.crc && a.offset == b.offset && a.cb_original ==
		b.cb_original && a.cb_compressed == b.cb_compressed
}

[inline]
pub fn (a ContentManifestPayloadFileMapping_ChunkData) ne(b ContentManifestPayloadFileMapping_ChunkData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ContentManifestPayloadFileMapping_ChunkData) eq(b []ContentManifestPayloadFileMapping_ChunkData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ContentManifestPayloadFileMapping_ChunkData) ne(b []ContentManifestPayloadFileMapping_ChunkData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_contentmanifestpayloadfilemapping_chunkdata() ContentManifestPayloadFileMapping_ChunkData {
	return ContentManifestPayloadFileMapping_ChunkData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_contentmanifestpayloadfilemapping_chunkdata(o ContentManifestPayloadFileMapping_ChunkData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_contentmanifestpayloadfilemapping_chunkdata(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentManifestPayloadFileMapping_ChunkData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := contentmanifestpayloadfilemapping_chunkdata_unpack(v) ?
	return i, unpacked
}

pub struct ContentManifestPayload_FileMapping {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	filename       string
	size           u64
	flags          u32
	sha_filename   []byte
	sha_content    []byte
	chunks         []ContentManifestPayloadFileMapping_ChunkData
	linktarget     string
}

pub fn (o &ContentManifestPayload_FileMapping) pack() []byte {
	mut res := []byte{}
	if o.filename != '' {
		res << vproto.pack_string_field(o.filename, 1)
	}
	if o.size != u64(0) {
		res << vproto.pack_uint64_field(o.size, 2)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 3)
	}
	if o.sha_filename != []byte{} {
		res << vproto.pack_bytes_field(o.sha_filename, 4)
	}
	if o.sha_content != []byte{} {
		res << vproto.pack_bytes_field(o.sha_content, 5)
	}
	// [packed=false]
	for _, x in o.chunks {
		res <<
			zzz_vproto_internal_pack_contentmanifestpayloadfilemapping_chunkdata(x, 6)
	}
	if o.linktarget != '' {
		res << vproto.pack_string_field(o.linktarget, 7)
	}
	return res
}

pub fn contentmanifestpayload_filemapping_unpack(buf []byte) ?ContentManifestPayload_FileMapping {
	mut res := zzz_vproto_internal_new_contentmanifestpayload_filemapping()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.filename = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.size = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.flags = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.sha_filename = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.sha_content = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_contentmanifestpayloadfilemapping_chunkdata(cur_buf,
					tag_wiretype.wire_type) ?
				res.chunks << v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.linktarget = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ContentManifestPayload_FileMapping) eq(b ContentManifestPayload_FileMapping) bool {
	return true && a.filename == b.filename && a.size == b.size && a.flags == b.flags &&
		a.sha_filename == b.sha_filename && a.sha_content == b.sha_content && a.chunks.eq(b.chunks) &&
		a.linktarget == b.linktarget
}

[inline]
pub fn (a ContentManifestPayload_FileMapping) ne(b ContentManifestPayload_FileMapping) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ContentManifestPayload_FileMapping) eq(b []ContentManifestPayload_FileMapping) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ContentManifestPayload_FileMapping) ne(b []ContentManifestPayload_FileMapping) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_contentmanifestpayload_filemapping() ContentManifestPayload_FileMapping {
	return ContentManifestPayload_FileMapping{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_contentmanifestpayload_filemapping(o ContentManifestPayload_FileMapping, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_contentmanifestpayload_filemapping(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentManifestPayload_FileMapping) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := contentmanifestpayload_filemapping_unpack(v) ?
	return i, unpacked
}

pub struct ContentManifestPayload {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	mappings       []ContentManifestPayload_FileMapping
}

pub fn (o &ContentManifestPayload) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.mappings {
		res << zzz_vproto_internal_pack_contentmanifestpayload_filemapping(x, 1)
	}
	return res
}

pub fn contentmanifestpayload_unpack(buf []byte) ?ContentManifestPayload {
	mut res := zzz_vproto_internal_new_contentmanifestpayload()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_contentmanifestpayload_filemapping(cur_buf,
					tag_wiretype.wire_type) ?
				res.mappings << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ContentManifestPayload) eq(b ContentManifestPayload) bool {
	return true && a.mappings.eq(b.mappings)
}

[inline]
pub fn (a ContentManifestPayload) ne(b ContentManifestPayload) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ContentManifestPayload) eq(b []ContentManifestPayload) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ContentManifestPayload) ne(b []ContentManifestPayload) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_contentmanifestpayload() ContentManifestPayload {
	return ContentManifestPayload{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_contentmanifestpayload(o ContentManifestPayload, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_contentmanifestpayload(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentManifestPayload) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := contentmanifestpayload_unpack(v) ?
	return i, unpacked
}

pub struct ContentManifestMetadata {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	depot_id            u32
	gid_manifest        u64
	creation_time       u32
	filenames_encrypted bool
	cb_disk_original    u64
	cb_disk_compressed  u64
	unique_chunks       u32
	crc_encrypted       u32
	crc_clear           u32
}

pub fn (o &ContentManifestMetadata) pack() []byte {
	mut res := []byte{}
	if o.depot_id != u32(0) {
		res << vproto.pack_uint32_field(o.depot_id, 1)
	}
	if o.gid_manifest != u64(0) {
		res << vproto.pack_uint64_field(o.gid_manifest, 2)
	}
	if o.creation_time != u32(0) {
		res << vproto.pack_uint32_field(o.creation_time, 3)
	}
	if o.filenames_encrypted != false {
		res << vproto.pack_bool_field(o.filenames_encrypted, 4)
	}
	if o.cb_disk_original != u64(0) {
		res << vproto.pack_uint64_field(o.cb_disk_original, 5)
	}
	if o.cb_disk_compressed != u64(0) {
		res << vproto.pack_uint64_field(o.cb_disk_compressed, 6)
	}
	if o.unique_chunks != u32(0) {
		res << vproto.pack_uint32_field(o.unique_chunks, 7)
	}
	if o.crc_encrypted != u32(0) {
		res << vproto.pack_uint32_field(o.crc_encrypted, 8)
	}
	if o.crc_clear != u32(0) {
		res << vproto.pack_uint32_field(o.crc_clear, 9)
	}
	return res
}

pub fn contentmanifestmetadata_unpack(buf []byte) ?ContentManifestMetadata {
	mut res := zzz_vproto_internal_new_contentmanifestmetadata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.depot_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.gid_manifest = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.creation_time = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.filenames_encrypted = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.cb_disk_original = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.cb_disk_compressed = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.unique_chunks = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.crc_encrypted = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.crc_clear = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ContentManifestMetadata) eq(b ContentManifestMetadata) bool {
	return true && a.depot_id == b.depot_id && a.gid_manifest == b.gid_manifest && a.creation_time ==
		b.creation_time && a.filenames_encrypted == b.filenames_encrypted && a.cb_disk_original == b.cb_disk_original &&
		a.cb_disk_compressed == b.cb_disk_compressed && a.unique_chunks == b.unique_chunks &&
		a.crc_encrypted == b.crc_encrypted && a.crc_clear == b.crc_clear
}

[inline]
pub fn (a ContentManifestMetadata) ne(b ContentManifestMetadata) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ContentManifestMetadata) eq(b []ContentManifestMetadata) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ContentManifestMetadata) ne(b []ContentManifestMetadata) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_contentmanifestmetadata() ContentManifestMetadata {
	return ContentManifestMetadata{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_contentmanifestmetadata(o ContentManifestMetadata, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_contentmanifestmetadata(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentManifestMetadata) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := contentmanifestmetadata_unpack(v) ?
	return i, unpacked
}

pub struct ContentManifestSignature {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	signature      []byte
}

pub fn (o &ContentManifestSignature) pack() []byte {
	mut res := []byte{}
	if o.signature != []byte{} {
		res << vproto.pack_bytes_field(o.signature, 1)
	}
	return res
}

pub fn contentmanifestsignature_unpack(buf []byte) ?ContentManifestSignature {
	mut res := zzz_vproto_internal_new_contentmanifestsignature()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.signature = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ContentManifestSignature) eq(b ContentManifestSignature) bool {
	return true && a.signature == b.signature
}

[inline]
pub fn (a ContentManifestSignature) ne(b ContentManifestSignature) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ContentManifestSignature) eq(b []ContentManifestSignature) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ContentManifestSignature) ne(b []ContentManifestSignature) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_contentmanifestsignature() ContentManifestSignature {
	return ContentManifestSignature{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_contentmanifestsignature(o ContentManifestSignature, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_contentmanifestsignature(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentManifestSignature) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := contentmanifestsignature_unpack(v) ?
	return i, unpacked
}

pub struct ContentDeltaChunks_DeltaChunk {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sha_source     []byte
	sha_target     []byte
	size_original  u32
	patch_method   u32
	chunk          []byte
	size_delta     u32
}

pub fn (o &ContentDeltaChunks_DeltaChunk) pack() []byte {
	mut res := []byte{}
	if o.sha_source != []byte{} {
		res << vproto.pack_bytes_field(o.sha_source, 1)
	}
	if o.sha_target != []byte{} {
		res << vproto.pack_bytes_field(o.sha_target, 2)
	}
	if o.size_original != u32(0) {
		res << vproto.pack_uint32_field(o.size_original, 3)
	}
	if o.patch_method != u32(0) {
		res << vproto.pack_uint32_field(o.patch_method, 4)
	}
	if o.chunk != []byte{} {
		res << vproto.pack_bytes_field(o.chunk, 5)
	}
	if o.size_delta != u32(0) {
		res << vproto.pack_uint32_field(o.size_delta, 6)
	}
	return res
}

pub fn contentdeltachunks_deltachunk_unpack(buf []byte) ?ContentDeltaChunks_DeltaChunk {
	mut res := zzz_vproto_internal_new_contentdeltachunks_deltachunk()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.sha_source = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.sha_target = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.size_original = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.patch_method = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.chunk = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.size_delta = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ContentDeltaChunks_DeltaChunk) eq(b ContentDeltaChunks_DeltaChunk) bool {
	return true && a.sha_source == b.sha_source && a.sha_target == b.sha_target && a.size_original ==
		b.size_original && a.patch_method == b.patch_method && a.chunk == b.chunk && a.size_delta == b.size_delta
}

[inline]
pub fn (a ContentDeltaChunks_DeltaChunk) ne(b ContentDeltaChunks_DeltaChunk) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ContentDeltaChunks_DeltaChunk) eq(b []ContentDeltaChunks_DeltaChunk) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ContentDeltaChunks_DeltaChunk) ne(b []ContentDeltaChunks_DeltaChunk) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_contentdeltachunks_deltachunk() ContentDeltaChunks_DeltaChunk {
	return ContentDeltaChunks_DeltaChunk{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_contentdeltachunks_deltachunk(o ContentDeltaChunks_DeltaChunk, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_contentdeltachunks_deltachunk(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentDeltaChunks_DeltaChunk) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := contentdeltachunks_deltachunk_unpack(v) ?
	return i, unpacked
}

pub struct ContentDeltaChunks {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	depot_id            u32
	manifest_id_source  u64
	manifest_id_target  u64
	deltachunks         []ContentDeltaChunks_DeltaChunk
	chunk_data_location EContentDeltaChunkDataLocation = .k_econtentdeltachunkdatalocationinprotobuf
}

pub fn (o &ContentDeltaChunks) pack() []byte {
	mut res := []byte{}
	if o.depot_id != u32(0) {
		res << vproto.pack_uint32_field(o.depot_id, 1)
	}
	if o.manifest_id_source != u64(0) {
		res << vproto.pack_uint64_field(o.manifest_id_source, 2)
	}
	if o.manifest_id_target != u64(0) {
		res << vproto.pack_uint64_field(o.manifest_id_target, 3)
	}
	// [packed=false]
	for _, x in o.deltachunks {
		res << zzz_vproto_internal_pack_contentdeltachunks_deltachunk(x, 4)
	}
	if o.chunk_data_location != zzz_vproto_internal_new_econtentdeltachunkdatalocation() {
		res <<
			zzz_vproto_internal_pack_econtentdeltachunkdatalocation(o.chunk_data_location, 5)
	}
	return res
}

pub fn contentdeltachunks_unpack(buf []byte) ?ContentDeltaChunks {
	mut res := zzz_vproto_internal_new_contentdeltachunks()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.depot_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.manifest_id_source = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
				res.manifest_id_target = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_contentdeltachunks_deltachunk(cur_buf,
					tag_wiretype.wire_type) ?
				res.deltachunks << v
				i = ii
			}
			5 {
				ii, v := zzz_vproto_internal_unpack_econtentdeltachunkdatalocation(cur_buf,
					tag_wiretype.wire_type) ?
				res.chunk_data_location = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ContentDeltaChunks) eq(b ContentDeltaChunks) bool {
	return true && a.depot_id == b.depot_id && a.manifest_id_source == b.manifest_id_source &&
		a.manifest_id_target == b.manifest_id_target && a.deltachunks.eq(b.deltachunks) && a.chunk_data_location ==
		b.chunk_data_location
}

[inline]
pub fn (a ContentDeltaChunks) ne(b ContentDeltaChunks) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ContentDeltaChunks) eq(b []ContentDeltaChunks) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ContentDeltaChunks) ne(b []ContentDeltaChunks) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_contentdeltachunks() ContentDeltaChunks {
	return ContentDeltaChunks{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_contentdeltachunks(o ContentDeltaChunks, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_contentdeltachunks(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentDeltaChunks) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := contentdeltachunks_unpack(v) ?
	return i, unpacked
}
