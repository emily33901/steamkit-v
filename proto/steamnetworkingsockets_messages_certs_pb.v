// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CMsgSteamNetworkingIdentityLegacyBinary {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steam_id         u64
	xbox_pairwise_id string
	generic_bytes    []byte
	generic_string   string
	ipv6_and_port    []byte
}

pub fn (o &CMsgSteamNetworkingIdentityLegacyBinary) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 16)
	}
	if o.xbox_pairwise_id != '' {
		res << vproto.pack_string_field(o.xbox_pairwise_id, 17)
	}
	if o.generic_bytes != []byte{} {
		res << vproto.pack_bytes_field(o.generic_bytes, 2)
	}
	if o.generic_string != '' {
		res << vproto.pack_string_field(o.generic_string, 3)
	}
	if o.ipv6_and_port != []byte{} {
		res << vproto.pack_bytes_field(o.ipv6_and_port, 4)
	}
	return res
}

pub fn cmsgsteamnetworkingidentitylegacybinary_unpack(buf []byte) ?CMsgSteamNetworkingIdentityLegacyBinary {
	mut res := zzz_vproto_internal_new_cmsgsteamnetworkingidentitylegacybinary()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			16 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steam_id = v
				i = ii
			}
			17 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.xbox_pairwise_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.generic_bytes = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.generic_string = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.ipv6_and_port = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamNetworkingIdentityLegacyBinary) eq(b CMsgSteamNetworkingIdentityLegacyBinary) bool {
	return true && a.steam_id == b.steam_id && a.xbox_pairwise_id == b.xbox_pairwise_id &&
		a.generic_bytes == b.generic_bytes && a.generic_string == b.generic_string && a.ipv6_and_port ==
		b.ipv6_and_port
}

[inline]
pub fn (a CMsgSteamNetworkingIdentityLegacyBinary) ne(b CMsgSteamNetworkingIdentityLegacyBinary) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamNetworkingIdentityLegacyBinary) eq(b []CMsgSteamNetworkingIdentityLegacyBinary) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamNetworkingIdentityLegacyBinary) ne(b []CMsgSteamNetworkingIdentityLegacyBinary) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingidentitylegacybinary() CMsgSteamNetworkingIdentityLegacyBinary {
	return CMsgSteamNetworkingIdentityLegacyBinary{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingidentitylegacybinary(o CMsgSteamNetworkingIdentityLegacyBinary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingidentitylegacybinary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingIdentityLegacyBinary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamnetworkingidentitylegacybinary_unpack(v) ?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramCertificate_EKeyType {
	invalid = 0
	ed25519 = 1
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_cmsgsteamdatagramcertificate_ekeytype() CMsgSteamDatagramCertificate_EKeyType {
	return .invalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramcertificate_ekeytype(e CMsgSteamDatagramCertificate_EKeyType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramcertificate_ekeytype_packed(e []CMsgSteamDatagramCertificate_EKeyType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramcertificate_ekeytype(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramCertificate_EKeyType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, CMsgSteamDatagramCertificate_EKeyType(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramcertificate_ekeytype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramCertificate_EKeyType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramCertificate {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	key_type                  CMsgSteamDatagramCertificate_EKeyType = .invalid
	key_data                  []byte
	legacy_steam_id           u64
	legacy_identity_binary    CMsgSteamNetworkingIdentityLegacyBinary
	identity_string           string
	gameserver_datacenter_ids []u32
	time_created              u32
	time_expiry               u32
	app_ids                   []u32
}

pub fn (o &CMsgSteamDatagramCertificate) pack() []byte {
	mut res := []byte{}
	if o.key_type != zzz_vproto_internal_new_cmsgsteamdatagramcertificate_ekeytype() {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramcertificate_ekeytype(o.key_type, 1)
	}
	if o.key_data != []byte{} {
		res << vproto.pack_bytes_field(o.key_data, 2)
	}
	if o.legacy_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.legacy_steam_id, 4)
	}
	if o.legacy_identity_binary.ne(zzz_vproto_internal_new_cmsgsteamnetworkingidentitylegacybinary()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamnetworkingidentitylegacybinary(o.legacy_identity_binary, 11)
	}
	if o.identity_string != '' {
		res << vproto.pack_string_field(o.identity_string, 12)
	}
	// [packed=false]
	for _, x in o.gameserver_datacenter_ids {
		res << vproto.pack_32bit_field(x, 5)
	}
	if o.time_created != u32(0) {
		res << vproto.pack_32bit_field(o.time_created, 8)
	}
	if o.time_expiry != u32(0) {
		res << vproto.pack_32bit_field(o.time_expiry, 9)
	}
	// [packed=false]
	for _, x in o.app_ids {
		res << vproto.pack_uint32_field(x, 10)
	}
	return res
}

pub fn cmsgsteamdatagramcertificate_unpack(buf []byte) ?CMsgSteamDatagramCertificate {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramcertificate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificate_ekeytype(cur_buf,
					tag_wiretype.wire_type) ?
				res.key_type = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.key_data = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_steam_id = v
				i = ii
			}
			11 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingidentitylegacybinary(cur_buf,
					tag_wiretype.wire_type) ?
				res.legacy_identity_binary = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.identity_string = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.gameserver_datacenter_ids << v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.time_created = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.time_expiry = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.app_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramCertificate) eq(b CMsgSteamDatagramCertificate) bool {
	return true && a.key_type == b.key_type && a.key_data == b.key_data && a.legacy_steam_id ==
		b.legacy_steam_id && a.legacy_identity_binary.eq(b.legacy_identity_binary) && a.identity_string ==
		b.identity_string && a.gameserver_datacenter_ids == b.gameserver_datacenter_ids && a.time_created ==
		b.time_created && a.time_expiry == b.time_expiry && a.app_ids == b.app_ids
}

[inline]
pub fn (a CMsgSteamDatagramCertificate) ne(b CMsgSteamDatagramCertificate) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramCertificate) eq(b []CMsgSteamDatagramCertificate) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramCertificate) ne(b []CMsgSteamDatagramCertificate) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramcertificate() CMsgSteamDatagramCertificate {
	return CMsgSteamDatagramCertificate{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramcertificate(o CMsgSteamDatagramCertificate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramcertificate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramCertificate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramcertificate_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramCertificateSigned {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	cert             []byte
	ca_key_id        u64
	ca_signature     []byte
	private_key_data []byte
}

pub fn (o &CMsgSteamDatagramCertificateSigned) pack() []byte {
	mut res := []byte{}
	if o.cert != []byte{} {
		res << vproto.pack_bytes_field(o.cert, 4)
	}
	if o.ca_key_id != u64(0) {
		res << vproto.pack_64bit_field(o.ca_key_id, 5)
	}
	if o.ca_signature != []byte{} {
		res << vproto.pack_bytes_field(o.ca_signature, 6)
	}
	if o.private_key_data != []byte{} {
		res << vproto.pack_bytes_field(o.private_key_data, 1)
	}
	return res
}

pub fn cmsgsteamdatagramcertificatesigned_unpack(buf []byte) ?CMsgSteamDatagramCertificateSigned {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramcertificatesigned()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			4 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.cert = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.ca_key_id = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.ca_signature = v
				i = ii
			}
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.private_key_data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramCertificateSigned) eq(b CMsgSteamDatagramCertificateSigned) bool {
	return true && a.cert == b.cert && a.ca_key_id == b.ca_key_id && a.ca_signature == b.ca_signature &&
		a.private_key_data == b.private_key_data
}

[inline]
pub fn (a CMsgSteamDatagramCertificateSigned) ne(b CMsgSteamDatagramCertificateSigned) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramCertificateSigned) eq(b []CMsgSteamDatagramCertificateSigned) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramCertificateSigned) ne(b []CMsgSteamDatagramCertificateSigned) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramcertificatesigned() CMsgSteamDatagramCertificateSigned {
	return CMsgSteamDatagramCertificateSigned{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o CMsgSteamDatagramCertificateSigned, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramCertificateSigned) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramcertificatesigned_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramCertificateRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cert           CMsgSteamDatagramCertificate
}

pub fn (o &CMsgSteamDatagramCertificateRequest) pack() []byte {
	mut res := []byte{}
	if o.cert.ne(zzz_vproto_internal_new_cmsgsteamdatagramcertificate()) {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificate(o.cert, 1)
	}
	return res
}

pub fn cmsgsteamdatagramcertificaterequest_unpack(buf []byte) ?CMsgSteamDatagramCertificateRequest {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramcertificaterequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificate(cur_buf,
					tag_wiretype.wire_type) ?
				res.cert = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramCertificateRequest) eq(b CMsgSteamDatagramCertificateRequest) bool {
	return true && a.cert.eq(b.cert)
}

[inline]
pub fn (a CMsgSteamDatagramCertificateRequest) ne(b CMsgSteamDatagramCertificateRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramCertificateRequest) eq(b []CMsgSteamDatagramCertificateRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramCertificateRequest) ne(b []CMsgSteamDatagramCertificateRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramcertificaterequest() CMsgSteamDatagramCertificateRequest {
	return CMsgSteamDatagramCertificateRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramcertificaterequest(o CMsgSteamDatagramCertificateRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramcertificaterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramCertificateRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramcertificaterequest_unpack(v) ?
	return i, unpacked
}
