// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EDisplayStatus {
	k_edisplaystatusinvalid = 0
	k_edisplaystatuslaunching = 1
	k_edisplaystatusuninstalling = 2
	k_edisplaystatusinstalling = 3
	k_edisplaystatusrunning = 4
	k_edisplaystatusvalidating = 5
	k_edisplaystatusupdating = 6
	k_edisplaystatusdownloading = 7
	k_edisplaystatussynchronizing = 8
	k_edisplaystatusreadytoinstall = 9
	k_edisplaystatusreadytopreload = 10
	k_edisplaystatusreadytolaunch = 11
	k_edisplaystatusregionrestricted = 12
	k_edisplaystatuspresaleonly = 13
	k_edisplaystatusinvalidplatform = 14
	k_edisplaystatuspreloadcomplete = 16
	k_edisplaystatusborrowerlocked = 17
	k_edisplaystatusupdatepaused = 18
	k_edisplaystatusupdatequeued = 19
	k_edisplaystatusupdaterequired = 20
	k_edisplaystatusupdatedisabled = 21
	k_edisplaystatusdownloadpaused = 22
	k_edisplaystatusdownloadqueued = 23
	k_edisplaystatusdownloadrequired = 24
	k_edisplaystatusdownloaddisabled = 25
	k_edisplaystatuslicensepending = 26
	k_edisplaystatuslicenseexpired = 27
	k_edisplaystatusavailforfree = 28
	k_edisplaystatusavailtoborrow = 29
	k_edisplaystatusavailguestpass = 30
	k_edisplaystatuspurchase = 31
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_edisplaystatus() EDisplayStatus {
	return .k_edisplaystatusinvalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_edisplaystatus(e EDisplayStatus, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_edisplaystatus_packed(e []EDisplayStatus, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_edisplaystatus(buf []byte, tag_wiretype vproto.WireType) ?(int, EDisplayStatus) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, EDisplayStatus(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_edisplaystatus_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EDisplayStatus) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EProtoAppType {
	k_eapptypeinvalid = 0
	k_eapptypegame = 1
	k_eapptypeapplication = 2
	k_eapptypetool = 4
	k_eapptypedemo = 8
	k_eapptypedeprected = 16
	k_eapptypedlc = 32
	k_eapptypeguide = 64
	k_eapptypedriver = 128
	k_eapptypeconfig = 256
	k_eapptypehardware = 512
	k_eapptypefranchise = 1024
	k_eapptypevideo = 2048
	k_eapptypeplugin = 4096
	k_eapptypemusicalbum = 8192
	k_eapptypeseries = 16384
	k_eapptypecomic = 32768
	k_eapptypebeta = 65536
	k_eapptypeshortcut = 1073741824
	k_eapptypedepotonly = -2147483648
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_eprotoapptype() EProtoAppType {
	return .k_eapptypeinvalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_eprotoapptype(e EProtoAppType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_eprotoapptype_packed(e []EProtoAppType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_eprotoapptype(buf []byte, tag_wiretype vproto.WireType) ?(int, EProtoAppType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, EProtoAppType(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_eprotoapptype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EProtoAppType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EAppAssociationType {
	k_eappassociationtypeinvalid = 0
	k_eappassociationtypepublisher = 1
	k_eappassociationtypedeveloper = 2
	k_eappassociationtypefranchise = 3
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_eappassociationtype() EAppAssociationType {
	return .k_eappassociationtypeinvalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_eappassociationtype(e EAppAssociationType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_eappassociationtype_packed(e []EAppAssociationType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_eappassociationtype(buf []byte, tag_wiretype vproto.WireType) ?(int, EAppAssociationType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, EAppAssociationType(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_eappassociationtype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EAppAssociationType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EAppControllerSupportLevel {
	k_eappcontrollersupportlevelnone = 0
	k_eappcontrollersupportlevelpartial = 1
	k_eappcontrollersupportlevelfull = 2
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_eappcontrollersupportlevel() EAppControllerSupportLevel {
	return .k_eappcontrollersupportlevelnone
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_eappcontrollersupportlevel(e EAppControllerSupportLevel, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_eappcontrollersupportlevel_packed(e []EAppControllerSupportLevel, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_eappcontrollersupportlevel(buf []byte, tag_wiretype vproto.WireType) ?(int, EAppControllerSupportLevel) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, EAppControllerSupportLevel(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_eappcontrollersupportlevel_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EAppControllerSupportLevel) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CAppOverview_AppAssociation {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	@type          EAppAssociationType = .k_eappassociationtypeinvalid
	name           string
}

pub fn (o &CAppOverview_AppAssociation) pack() []byte {
	mut res := []byte{}
	if o.@type != zzz_vproto_internal_new_eappassociationtype() {
		res << zzz_vproto_internal_pack_eappassociationtype(o.@type, 1)
	}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn cappoverview_appassociation_unpack(buf []byte) ?CAppOverview_AppAssociation {
	mut res := zzz_vproto_internal_new_cappoverview_appassociation()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.@type = zzz_vproto_internal_unpack_eappassociationtype(cur_buf,
					tag_wiretype.wire_type) ?
			}
			2 {
				i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CAppOverview_AppAssociation) eq(b CAppOverview_AppAssociation) bool {
	return true && a.@type == b.@type && a.name == b.name
}

[inline]
pub fn (a CAppOverview_AppAssociation) ne(b CAppOverview_AppAssociation) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CAppOverview_AppAssociation) eq(b []CAppOverview_AppAssociation) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CAppOverview_AppAssociation) ne(b []CAppOverview_AppAssociation) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cappoverview_appassociation() CAppOverview_AppAssociation {
	return CAppOverview_AppAssociation{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cappoverview_appassociation(o CAppOverview_AppAssociation, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cappoverview_appassociation(buf []byte, tag_wiretype vproto.WireType) ?(int, CAppOverview_AppAssociation) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cappoverview_appassociation_unpack(v) ?
	return i, unpacked
}

pub struct CAppOverview_PerClientData {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	clientid                         u64
	client_name                      string
	display_status                   EDisplayStatus = .k_edisplaystatusinvalid
	status_percentage                u32
	active_beta                      string
	installed                        bool
	bytes_downloaded                 u64
	bytes_total                      u64
	streaming_to_local_client        bool
	is_available_on_current_platform bool
	is_invalid_os_type               bool
	playtime_left                    u32
}

pub fn (o &CAppOverview_PerClientData) pack() []byte {
	mut res := []byte{}
	if o.clientid != u64(0) {
		res << vproto.pack_uint64_field(o.clientid, 1)
	}
	if o.client_name != '' {
		res << vproto.pack_string_field(o.client_name, 2)
	}
	if o.display_status != zzz_vproto_internal_new_edisplaystatus() {
		res << zzz_vproto_internal_pack_edisplaystatus(o.display_status, 3)
	}
	if o.status_percentage != u32(0) {
		res << vproto.pack_uint32_field(o.status_percentage, 4)
	}
	if o.active_beta != '' {
		res << vproto.pack_string_field(o.active_beta, 5)
	}
	if o.installed != false {
		res << vproto.pack_bool_field(o.installed, 6)
	}
	if o.bytes_downloaded != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_downloaded, 7)
	}
	if o.bytes_total != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_total, 8)
	}
	if o.streaming_to_local_client != false {
		res << vproto.pack_bool_field(o.streaming_to_local_client, 9)
	}
	if o.is_available_on_current_platform != false {
		res << vproto.pack_bool_field(o.is_available_on_current_platform, 10)
	}
	if o.is_invalid_os_type != false {
		res << vproto.pack_bool_field(o.is_invalid_os_type, 11)
	}
	if o.playtime_left != u32(0) {
		res << vproto.pack_uint32_field(o.playtime_left, 12)
	}
	return res
}

pub fn cappoverview_perclientdata_unpack(buf []byte) ?CAppOverview_PerClientData {
	mut res := zzz_vproto_internal_new_cappoverview_perclientdata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.clientid = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.client_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.display_status = zzz_vproto_internal_unpack_edisplaystatus(cur_buf,
					tag_wiretype.wire_type) ?
			}
			4 {
				i, res.status_percentage = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.active_beta = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.installed = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.bytes_downloaded = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.bytes_total = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.streaming_to_local_client = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.is_available_on_current_platform = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			11 {
				i, res.is_invalid_os_type = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			12 {
				i, res.playtime_left = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CAppOverview_PerClientData) eq(b CAppOverview_PerClientData) bool {
	return true && a.clientid == b.clientid && a.client_name == b.client_name && a.display_status ==
		b.display_status && a.status_percentage == b.status_percentage && a.active_beta == b.active_beta &&
		a.installed == b.installed && a.bytes_downloaded == b.bytes_downloaded && a.bytes_total == b.bytes_total &&
		a.streaming_to_local_client == b.streaming_to_local_client && a.is_available_on_current_platform ==
		b.is_available_on_current_platform && a.is_invalid_os_type == b.is_invalid_os_type &&
		a.playtime_left == b.playtime_left
}

[inline]
pub fn (a CAppOverview_PerClientData) ne(b CAppOverview_PerClientData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CAppOverview_PerClientData) eq(b []CAppOverview_PerClientData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CAppOverview_PerClientData) ne(b []CAppOverview_PerClientData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cappoverview_perclientdata() CAppOverview_PerClientData {
	return CAppOverview_PerClientData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cappoverview_perclientdata(o CAppOverview_PerClientData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cappoverview_perclientdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CAppOverview_PerClientData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cappoverview_perclientdata_unpack(v) ?
	return i, unpacked
}

pub struct CAppOverview {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	appid                           u32
	display_name                    string
	visible_in_game_list            bool
	sort_as                         string
	app_type                        EProtoAppType = .k_eapptypeinvalid
	mru_index                       u32
	rt_recent_activity_time         u32
	minutes_playtime_forever        u32
	minutes_playtime_last_two_weeks u32
	rt_last_time_played             u32
	store_tag                       []u32
	association                     []CAppOverview_AppAssociation
	store_category                  []u32
	rt_original_release_date        u32
	rt_steam_release_date           u32
	icon_hash                       string
	logo_hash                       string
	controller_support              EAppControllerSupportLevel = .k_eappcontrollersupportlevelnone
	vr_supported                    bool
	metacritic_score                u32
	size_on_disk                    u64
	third_party_mod                 bool
	icon_data                       string
	icon_data_format                string
	gameid                          string
	library_capsule_filename        string
	per_client_data                 []CAppOverview_PerClientData
	most_available_clientid         u64
	selected_clientid               u64
	rt_store_asset_mtime            u32
	rt_custom_image_mtime           u32
	optional_parent_app_id          u32
	owner_account_id                u32
	compat_mapping_enabled          bool
	compat_mapping_priority         u32
	compat_mapping_tool_name        string
	review_score_with_bombs         u32
	review_percentage_with_bombs    u32
	review_score_without_bombs      u32
	review_percentage_without_bombs u32
	library_id                      string
}

pub fn (o &CAppOverview) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.display_name != '' {
		res << vproto.pack_string_field(o.display_name, 2)
	}
	if o.visible_in_game_list != false {
		res << vproto.pack_bool_field(o.visible_in_game_list, 4)
	}
	if o.sort_as != '' {
		res << vproto.pack_string_field(o.sort_as, 6)
	}
	if o.app_type != zzz_vproto_internal_new_eprotoapptype() {
		res << zzz_vproto_internal_pack_eprotoapptype(o.app_type, 7)
	}
	if o.mru_index != u32(0) {
		res << vproto.pack_uint32_field(o.mru_index, 13)
	}
	if o.rt_recent_activity_time != u32(0) {
		res << vproto.pack_uint32_field(o.rt_recent_activity_time, 14)
	}
	if o.minutes_playtime_forever != u32(0) {
		res << vproto.pack_uint32_field(o.minutes_playtime_forever, 16)
	}
	if o.minutes_playtime_last_two_weeks != u32(0) {
		res << vproto.pack_uint32_field(o.minutes_playtime_last_two_weeks, 17)
	}
	if o.rt_last_time_played != u32(0) {
		res << vproto.pack_uint32_field(o.rt_last_time_played, 18)
	}
	// [packed=false]
	for _, x in o.store_tag {
		res << vproto.pack_uint32_field(x, 19)
	}
	// [packed=false]
	for _, x in o.association {
		res << zzz_vproto_internal_pack_cappoverview_appassociation(x, 20)
	}
	// [packed=false]
	for _, x in o.store_category {
		res << vproto.pack_uint32_field(x, 23)
	}
	if o.rt_original_release_date != u32(0) {
		res << vproto.pack_uint32_field(o.rt_original_release_date, 25)
	}
	if o.rt_steam_release_date != u32(0) {
		res << vproto.pack_uint32_field(o.rt_steam_release_date, 26)
	}
	if o.icon_hash != '' {
		res << vproto.pack_string_field(o.icon_hash, 27)
	}
	if o.logo_hash != '' {
		res << vproto.pack_string_field(o.logo_hash, 30)
	}
	if o.controller_support != zzz_vproto_internal_new_eappcontrollersupportlevel() {
		res <<
			zzz_vproto_internal_pack_eappcontrollersupportlevel(o.controller_support, 31)
	}
	if o.vr_supported != false {
		res << vproto.pack_bool_field(o.vr_supported, 32)
	}
	if o.metacritic_score != u32(0) {
		res << vproto.pack_uint32_field(o.metacritic_score, 36)
	}
	if o.size_on_disk != u64(0) {
		res << vproto.pack_uint64_field(o.size_on_disk, 37)
	}
	if o.third_party_mod != false {
		res << vproto.pack_bool_field(o.third_party_mod, 38)
	}
	if o.icon_data != '' {
		res << vproto.pack_string_field(o.icon_data, 39)
	}
	if o.icon_data_format != '' {
		res << vproto.pack_string_field(o.icon_data_format, 40)
	}
	if o.gameid != '' {
		res << vproto.pack_string_field(o.gameid, 41)
	}
	if o.library_capsule_filename != '' {
		res << vproto.pack_string_field(o.library_capsule_filename, 42)
	}
	// [packed=false]
	for _, x in o.per_client_data {
		res << zzz_vproto_internal_pack_cappoverview_perclientdata(x, 43)
	}
	if o.most_available_clientid != u64(0) {
		res << vproto.pack_uint64_field(o.most_available_clientid, 44)
	}
	if o.selected_clientid != u64(0) {
		res << vproto.pack_uint64_field(o.selected_clientid, 45)
	}
	if o.rt_store_asset_mtime != u32(0) {
		res << vproto.pack_uint32_field(o.rt_store_asset_mtime, 46)
	}
	if o.rt_custom_image_mtime != u32(0) {
		res << vproto.pack_uint32_field(o.rt_custom_image_mtime, 47)
	}
	if o.optional_parent_app_id != u32(0) {
		res << vproto.pack_uint32_field(o.optional_parent_app_id, 48)
	}
	if o.owner_account_id != u32(0) {
		res << vproto.pack_uint32_field(o.owner_account_id, 49)
	}
	if o.compat_mapping_enabled != false {
		res << vproto.pack_bool_field(o.compat_mapping_enabled, 50)
	}
	if o.compat_mapping_priority != u32(0) {
		res << vproto.pack_uint32_field(o.compat_mapping_priority, 51)
	}
	if o.compat_mapping_tool_name != '' {
		res << vproto.pack_string_field(o.compat_mapping_tool_name, 52)
	}
	if o.review_score_with_bombs != u32(0) {
		res << vproto.pack_uint32_field(o.review_score_with_bombs, 53)
	}
	if o.review_percentage_with_bombs != u32(0) {
		res << vproto.pack_uint32_field(o.review_percentage_with_bombs, 54)
	}
	if o.review_score_without_bombs != u32(0) {
		res << vproto.pack_uint32_field(o.review_score_without_bombs, 55)
	}
	if o.review_percentage_without_bombs != u32(0) {
		res << vproto.pack_uint32_field(o.review_percentage_without_bombs, 56)
	}
	if o.library_id != '' {
		res << vproto.pack_string_field(o.library_id, 57)
	}
	return res
}

pub fn cappoverview_unpack(buf []byte) ?CAppOverview {
	mut res := zzz_vproto_internal_new_cappoverview()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.display_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.visible_in_game_list = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.sort_as = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.app_type = zzz_vproto_internal_unpack_eprotoapptype(cur_buf, tag_wiretype.wire_type) ?
			}
			13 {
				i, res.mru_index = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			14 {
				i, res.rt_recent_activity_time = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			16 {
				i, res.minutes_playtime_forever = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			17 {
				i, res.minutes_playtime_last_two_weeks = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			18 {
				i, res.rt_last_time_played = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			19 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.store_tag << v
				i = ii
			}
			20 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cappoverview_appassociation(cur_buf,
					tag_wiretype.wire_type) ?
				res.association << v
				i = ii
			}
			23 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.store_category << v
				i = ii
			}
			25 {
				i, res.rt_original_release_date = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			26 {
				i, res.rt_steam_release_date = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			27 {
				i, res.icon_hash = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			30 {
				i, res.logo_hash = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			31 {
				i, res.controller_support = zzz_vproto_internal_unpack_eappcontrollersupportlevel(cur_buf,
					tag_wiretype.wire_type) ?
			}
			32 {
				i, res.vr_supported = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			36 {
				i, res.metacritic_score = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			37 {
				i, res.size_on_disk = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			38 {
				i, res.third_party_mod = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			39 {
				i, res.icon_data = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			40 {
				i, res.icon_data_format = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			41 {
				i, res.gameid = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			42 {
				i, res.library_capsule_filename = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			43 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cappoverview_perclientdata(cur_buf,
					tag_wiretype.wire_type) ?
				res.per_client_data << v
				i = ii
			}
			44 {
				i, res.most_available_clientid = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			45 {
				i, res.selected_clientid = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			46 {
				i, res.rt_store_asset_mtime = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			47 {
				i, res.rt_custom_image_mtime = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			48 {
				i, res.optional_parent_app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			49 {
				i, res.owner_account_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			50 {
				i, res.compat_mapping_enabled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			51 {
				i, res.compat_mapping_priority = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			52 {
				i, res.compat_mapping_tool_name = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			53 {
				i, res.review_score_with_bombs = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			54 {
				i, res.review_percentage_with_bombs = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			55 {
				i, res.review_score_without_bombs = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			56 {
				i, res.review_percentage_without_bombs = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			57 {
				i, res.library_id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CAppOverview) eq(b CAppOverview) bool {
	return true && a.appid == b.appid && a.display_name == b.display_name && a.visible_in_game_list ==
		b.visible_in_game_list && a.sort_as == b.sort_as && a.app_type == b.app_type && a.mru_index ==
		b.mru_index && a.rt_recent_activity_time == b.rt_recent_activity_time && a.minutes_playtime_forever ==
		b.minutes_playtime_forever && a.minutes_playtime_last_two_weeks == b.minutes_playtime_last_two_weeks &&
		a.rt_last_time_played == b.rt_last_time_played && a.store_tag == b.store_tag && a.association.eq(b.association) &&
		a.store_category == b.store_category && a.rt_original_release_date == b.rt_original_release_date &&
		a.rt_steam_release_date == b.rt_steam_release_date && a.icon_hash == b.icon_hash && a.logo_hash ==
		b.logo_hash && a.controller_support == b.controller_support && a.vr_supported == b.vr_supported &&
		a.metacritic_score == b.metacritic_score && a.size_on_disk == b.size_on_disk && a.third_party_mod ==
		b.third_party_mod && a.icon_data == b.icon_data && a.icon_data_format == b.icon_data_format &&
		a.gameid == b.gameid && a.library_capsule_filename == b.library_capsule_filename && a.per_client_data.eq(b.per_client_data) &&
		a.most_available_clientid == b.most_available_clientid && a.selected_clientid == b.selected_clientid &&
		a.rt_store_asset_mtime == b.rt_store_asset_mtime && a.rt_custom_image_mtime == b.rt_custom_image_mtime &&
		a.optional_parent_app_id == b.optional_parent_app_id && a.owner_account_id == b.owner_account_id &&
		a.compat_mapping_enabled == b.compat_mapping_enabled && a.compat_mapping_priority == b.compat_mapping_priority &&
		a.compat_mapping_tool_name == b.compat_mapping_tool_name && a.review_score_with_bombs == b.review_score_with_bombs &&
		a.review_percentage_with_bombs == b.review_percentage_with_bombs && a.review_score_without_bombs ==
		b.review_score_without_bombs && a.review_percentage_without_bombs == b.review_percentage_without_bombs &&
		a.library_id == b.library_id
}

[inline]
pub fn (a CAppOverview) ne(b CAppOverview) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CAppOverview) eq(b []CAppOverview) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CAppOverview) ne(b []CAppOverview) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cappoverview() CAppOverview {
	return CAppOverview{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cappoverview(o CAppOverview, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cappoverview(buf []byte, tag_wiretype vproto.WireType) ?(int, CAppOverview) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cappoverview_unpack(v) ?
	return i, unpacked
}

pub struct CAppOverview_Change {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_overview   []CAppOverview
	removed_appid  []u32
}

pub fn (o &CAppOverview_Change) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.app_overview {
		res << zzz_vproto_internal_pack_cappoverview(x, 1)
	}
	// [packed=false]
	for _, x in o.removed_appid {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cappoverview_change_unpack(buf []byte) ?CAppOverview_Change {
	mut res := zzz_vproto_internal_new_cappoverview_change()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cappoverview(cur_buf, tag_wiretype.wire_type) ?
				res.app_overview << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.removed_appid << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CAppOverview_Change) eq(b CAppOverview_Change) bool {
	return true && a.app_overview.eq(b.app_overview) && a.removed_appid == b.removed_appid
}

[inline]
pub fn (a CAppOverview_Change) ne(b CAppOverview_Change) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CAppOverview_Change) eq(b []CAppOverview_Change) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CAppOverview_Change) ne(b []CAppOverview_Change) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cappoverview_change() CAppOverview_Change {
	return CAppOverview_Change{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cappoverview_change(o CAppOverview_Change, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cappoverview_change(buf []byte, tag_wiretype vproto.WireType) ?(int, CAppOverview_Change) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cappoverview_change_unpack(v) ?
	return i, unpacked
}

pub struct CAppBootstrapData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	hidden         bool
	user_tag       []string
}

pub fn (o &CAppBootstrapData) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.hidden != false {
		res << vproto.pack_bool_field(o.hidden, 2)
	}
	// [packed=false]
	for _, x in o.user_tag {
		res << vproto.pack_string_field(x, 3)
	}
	return res
}

pub fn cappbootstrapdata_unpack(buf []byte) ?CAppBootstrapData {
	mut res := zzz_vproto_internal_new_cappbootstrapdata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.hidden = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.user_tag << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CAppBootstrapData) eq(b CAppBootstrapData) bool {
	return true && a.appid == b.appid && a.hidden == b.hidden && a.user_tag == b.user_tag
}

[inline]
pub fn (a CAppBootstrapData) ne(b CAppBootstrapData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CAppBootstrapData) eq(b []CAppBootstrapData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CAppBootstrapData) ne(b []CAppBootstrapData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cappbootstrapdata() CAppBootstrapData {
	return CAppBootstrapData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cappbootstrapdata(o CAppBootstrapData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cappbootstrapdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CAppBootstrapData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cappbootstrapdata_unpack(v) ?
	return i, unpacked
}

pub struct CLibraryBootstrapData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_data       []CAppBootstrapData
}

pub fn (o &CLibraryBootstrapData) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.app_data {
		res << zzz_vproto_internal_pack_cappbootstrapdata(x, 1)
	}
	return res
}

pub fn clibrarybootstrapdata_unpack(buf []byte) ?CLibraryBootstrapData {
	mut res := zzz_vproto_internal_new_clibrarybootstrapdata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cappbootstrapdata(cur_buf, tag_wiretype.wire_type) ?
				res.app_data << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CLibraryBootstrapData) eq(b CLibraryBootstrapData) bool {
	return true && a.app_data.eq(b.app_data)
}

[inline]
pub fn (a CLibraryBootstrapData) ne(b CLibraryBootstrapData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CLibraryBootstrapData) eq(b []CLibraryBootstrapData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CLibraryBootstrapData) ne(b []CLibraryBootstrapData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_clibrarybootstrapdata() CLibraryBootstrapData {
	return CLibraryBootstrapData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_clibrarybootstrapdata(o CLibraryBootstrapData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_clibrarybootstrapdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CLibraryBootstrapData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := clibrarybootstrapdata_unpack(v) ?
	return i, unpacked
}
