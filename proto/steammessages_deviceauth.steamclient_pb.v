// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CDeviceAuth_GetOwnAuthorizedDevices_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	include_canceled bool
}

pub fn (o &CDeviceAuth_GetOwnAuthorizedDevices_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.include_canceled != false {
		res << vproto.pack_bool_field(o.include_canceled, 2)
	}
	return res
}

pub fn cdeviceauth_getownauthorizeddevices_request_unpack(buf []byte) ?CDeviceAuth_GetOwnAuthorizedDevices_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_getownauthorizeddevices_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.include_canceled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetOwnAuthorizedDevices_Request) eq(b CDeviceAuth_GetOwnAuthorizedDevices_Request) bool {
	return true && a.steamid == b.steamid && a.include_canceled == b.include_canceled
}

[inline]
pub fn (a CDeviceAuth_GetOwnAuthorizedDevices_Request) ne(b CDeviceAuth_GetOwnAuthorizedDevices_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetOwnAuthorizedDevices_Request) eq(b []CDeviceAuth_GetOwnAuthorizedDevices_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetOwnAuthorizedDevices_Request) ne(b []CDeviceAuth_GetOwnAuthorizedDevices_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getownauthorizeddevices_request() CDeviceAuth_GetOwnAuthorizedDevices_Request {
	return CDeviceAuth_GetOwnAuthorizedDevices_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getownauthorizeddevices_request(o CDeviceAuth_GetOwnAuthorizedDevices_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getownauthorizeddevices_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetOwnAuthorizedDevices_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getownauthorizeddevices_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetOwnAuthorizedDevices_Response_Device {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	auth_device_token u64
	device_name       string
	is_pending        bool
	is_canceled       bool
	last_time_used    u32
	last_borrower_id  u64
	last_app_played   u32
	is_limited        bool
}

pub fn (o &CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) pack() []byte {
	mut res := []byte{}
	if o.auth_device_token != u64(0) {
		res << vproto.pack_64bit_field(o.auth_device_token, 1)
	}
	if o.device_name != '' {
		res << vproto.pack_string_field(o.device_name, 2)
	}
	if o.is_pending != false {
		res << vproto.pack_bool_field(o.is_pending, 3)
	}
	if o.is_canceled != false {
		res << vproto.pack_bool_field(o.is_canceled, 4)
	}
	if o.last_time_used != u32(0) {
		res << vproto.pack_uint32_field(o.last_time_used, 5)
	}
	if o.last_borrower_id != u64(0) {
		res << vproto.pack_64bit_field(o.last_borrower_id, 6)
	}
	if o.last_app_played != u32(0) {
		res << vproto.pack_uint32_field(o.last_app_played, 7)
	}
	if o.is_limited != false {
		res << vproto.pack_bool_field(o.is_limited, 8)
	}
	return res
}

pub fn cdeviceauth_getownauthorizeddevices_response_device_unpack(buf []byte) ?CDeviceAuth_GetOwnAuthorizedDevices_Response_Device {
	mut res := zzz_vproto_internal_new_cdeviceauth_getownauthorizeddevices_response_device()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.auth_device_token = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.device_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.is_pending = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.is_canceled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.last_time_used = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.last_borrower_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.last_app_played = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.is_limited = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) eq(b CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) bool {
	return true && a.auth_device_token == b.auth_device_token && a.device_name == b.device_name &&
		a.is_pending == b.is_pending && a.is_canceled == b.is_canceled && a.last_time_used == b.last_time_used &&
		a.last_borrower_id == b.last_borrower_id && a.last_app_played == b.last_app_played &&
		a.is_limited == b.is_limited
}

[inline]
pub fn (a CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) ne(b CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) eq(b []CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) ne(b []CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getownauthorizeddevices_response_device() CDeviceAuth_GetOwnAuthorizedDevices_Response_Device {
	return CDeviceAuth_GetOwnAuthorizedDevices_Response_Device{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getownauthorizeddevices_response_device(o CDeviceAuth_GetOwnAuthorizedDevices_Response_Device, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getownauthorizeddevices_response_device(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getownauthorizeddevices_response_device_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetOwnAuthorizedDevices_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	devices        []CDeviceAuth_GetOwnAuthorizedDevices_Response_Device
}

pub fn (o &CDeviceAuth_GetOwnAuthorizedDevices_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.devices {
		res <<
			zzz_vproto_internal_pack_cdeviceauth_getownauthorizeddevices_response_device(x, 1)
	}
	return res
}

pub fn cdeviceauth_getownauthorizeddevices_response_unpack(buf []byte) ?CDeviceAuth_GetOwnAuthorizedDevices_Response {
	mut res := zzz_vproto_internal_new_cdeviceauth_getownauthorizeddevices_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getownauthorizeddevices_response_device(cur_buf,
					tag_wiretype.wire_type) ?
				res.devices << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetOwnAuthorizedDevices_Response) eq(b CDeviceAuth_GetOwnAuthorizedDevices_Response) bool {
	return true && a.devices.eq(b.devices)
}

[inline]
pub fn (a CDeviceAuth_GetOwnAuthorizedDevices_Response) ne(b CDeviceAuth_GetOwnAuthorizedDevices_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetOwnAuthorizedDevices_Response) eq(b []CDeviceAuth_GetOwnAuthorizedDevices_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetOwnAuthorizedDevices_Response) ne(b []CDeviceAuth_GetOwnAuthorizedDevices_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getownauthorizeddevices_response() CDeviceAuth_GetOwnAuthorizedDevices_Response {
	return CDeviceAuth_GetOwnAuthorizedDevices_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getownauthorizeddevices_response(o CDeviceAuth_GetOwnAuthorizedDevices_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getownauthorizeddevices_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetOwnAuthorizedDevices_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getownauthorizeddevices_response_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_AcceptAuthorizationRequest_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	steamid           u64
	auth_device_token u64
	auth_code         u64
	from_steamid      u64
}

pub fn (o &CDeviceAuth_AcceptAuthorizationRequest_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.auth_device_token != u64(0) {
		res << vproto.pack_64bit_field(o.auth_device_token, 2)
	}
	if o.auth_code != u64(0) {
		res << vproto.pack_64bit_field(o.auth_code, 3)
	}
	if o.from_steamid != u64(0) {
		res << vproto.pack_64bit_field(o.from_steamid, 4)
	}
	return res
}

pub fn cdeviceauth_acceptauthorizationrequest_request_unpack(buf []byte) ?CDeviceAuth_AcceptAuthorizationRequest_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_acceptauthorizationrequest_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.auth_device_token = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.auth_code = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.from_steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_AcceptAuthorizationRequest_Request) eq(b CDeviceAuth_AcceptAuthorizationRequest_Request) bool {
	return true && a.steamid == b.steamid && a.auth_device_token == b.auth_device_token &&
		a.auth_code == b.auth_code && a.from_steamid == b.from_steamid
}

[inline]
pub fn (a CDeviceAuth_AcceptAuthorizationRequest_Request) ne(b CDeviceAuth_AcceptAuthorizationRequest_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_AcceptAuthorizationRequest_Request) eq(b []CDeviceAuth_AcceptAuthorizationRequest_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_AcceptAuthorizationRequest_Request) ne(b []CDeviceAuth_AcceptAuthorizationRequest_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_acceptauthorizationrequest_request() CDeviceAuth_AcceptAuthorizationRequest_Request {
	return CDeviceAuth_AcceptAuthorizationRequest_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_acceptauthorizationrequest_request(o CDeviceAuth_AcceptAuthorizationRequest_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_acceptauthorizationrequest_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AcceptAuthorizationRequest_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_acceptauthorizationrequest_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_AcceptAuthorizationRequest_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuth_AcceptAuthorizationRequest_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauth_acceptauthorizationrequest_response_unpack(buf []byte) ?CDeviceAuth_AcceptAuthorizationRequest_Response {
	res := zzz_vproto_internal_new_cdeviceauth_acceptauthorizationrequest_response()
	return res
}

[inline]
pub fn (a CDeviceAuth_AcceptAuthorizationRequest_Response) eq(b CDeviceAuth_AcceptAuthorizationRequest_Response) bool {
	return true
}

[inline]
pub fn (a CDeviceAuth_AcceptAuthorizationRequest_Response) ne(b CDeviceAuth_AcceptAuthorizationRequest_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_AcceptAuthorizationRequest_Response) eq(b []CDeviceAuth_AcceptAuthorizationRequest_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_AcceptAuthorizationRequest_Response) ne(b []CDeviceAuth_AcceptAuthorizationRequest_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_acceptauthorizationrequest_response() CDeviceAuth_AcceptAuthorizationRequest_Response {
	return CDeviceAuth_AcceptAuthorizationRequest_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_acceptauthorizationrequest_response(o CDeviceAuth_AcceptAuthorizationRequest_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_acceptauthorizationrequest_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AcceptAuthorizationRequest_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_acceptauthorizationrequest_response_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_AuthorizeRemoteDevice_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	steamid           u64
	auth_device_token u64
}

pub fn (o &CDeviceAuth_AuthorizeRemoteDevice_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.auth_device_token != u64(0) {
		res << vproto.pack_64bit_field(o.auth_device_token, 2)
	}
	return res
}

pub fn cdeviceauth_authorizeremotedevice_request_unpack(buf []byte) ?CDeviceAuth_AuthorizeRemoteDevice_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_authorizeremotedevice_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.auth_device_token = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_AuthorizeRemoteDevice_Request) eq(b CDeviceAuth_AuthorizeRemoteDevice_Request) bool {
	return true && a.steamid == b.steamid && a.auth_device_token == b.auth_device_token
}

[inline]
pub fn (a CDeviceAuth_AuthorizeRemoteDevice_Request) ne(b CDeviceAuth_AuthorizeRemoteDevice_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_AuthorizeRemoteDevice_Request) eq(b []CDeviceAuth_AuthorizeRemoteDevice_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_AuthorizeRemoteDevice_Request) ne(b []CDeviceAuth_AuthorizeRemoteDevice_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_authorizeremotedevice_request() CDeviceAuth_AuthorizeRemoteDevice_Request {
	return CDeviceAuth_AuthorizeRemoteDevice_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_authorizeremotedevice_request(o CDeviceAuth_AuthorizeRemoteDevice_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_authorizeremotedevice_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AuthorizeRemoteDevice_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_authorizeremotedevice_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_AuthorizeRemoteDevice_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuth_AuthorizeRemoteDevice_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauth_authorizeremotedevice_response_unpack(buf []byte) ?CDeviceAuth_AuthorizeRemoteDevice_Response {
	res := zzz_vproto_internal_new_cdeviceauth_authorizeremotedevice_response()
	return res
}

[inline]
pub fn (a CDeviceAuth_AuthorizeRemoteDevice_Response) eq(b CDeviceAuth_AuthorizeRemoteDevice_Response) bool {
	return true
}

[inline]
pub fn (a CDeviceAuth_AuthorizeRemoteDevice_Response) ne(b CDeviceAuth_AuthorizeRemoteDevice_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_AuthorizeRemoteDevice_Response) eq(b []CDeviceAuth_AuthorizeRemoteDevice_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_AuthorizeRemoteDevice_Response) ne(b []CDeviceAuth_AuthorizeRemoteDevice_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_authorizeremotedevice_response() CDeviceAuth_AuthorizeRemoteDevice_Response {
	return CDeviceAuth_AuthorizeRemoteDevice_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_authorizeremotedevice_response(o CDeviceAuth_AuthorizeRemoteDevice_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_authorizeremotedevice_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AuthorizeRemoteDevice_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_authorizeremotedevice_response_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_DeauthorizeRemoteDevice_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	steamid           u64
	auth_device_token u64
}

pub fn (o &CDeviceAuth_DeauthorizeRemoteDevice_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.auth_device_token != u64(0) {
		res << vproto.pack_64bit_field(o.auth_device_token, 2)
	}
	return res
}

pub fn cdeviceauth_deauthorizeremotedevice_request_unpack(buf []byte) ?CDeviceAuth_DeauthorizeRemoteDevice_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_deauthorizeremotedevice_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.auth_device_token = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_DeauthorizeRemoteDevice_Request) eq(b CDeviceAuth_DeauthorizeRemoteDevice_Request) bool {
	return true && a.steamid == b.steamid && a.auth_device_token == b.auth_device_token
}

[inline]
pub fn (a CDeviceAuth_DeauthorizeRemoteDevice_Request) ne(b CDeviceAuth_DeauthorizeRemoteDevice_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_DeauthorizeRemoteDevice_Request) eq(b []CDeviceAuth_DeauthorizeRemoteDevice_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_DeauthorizeRemoteDevice_Request) ne(b []CDeviceAuth_DeauthorizeRemoteDevice_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_deauthorizeremotedevice_request() CDeviceAuth_DeauthorizeRemoteDevice_Request {
	return CDeviceAuth_DeauthorizeRemoteDevice_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_deauthorizeremotedevice_request(o CDeviceAuth_DeauthorizeRemoteDevice_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_deauthorizeremotedevice_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_DeauthorizeRemoteDevice_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_deauthorizeremotedevice_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_DeauthorizeRemoteDevice_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuth_DeauthorizeRemoteDevice_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauth_deauthorizeremotedevice_response_unpack(buf []byte) ?CDeviceAuth_DeauthorizeRemoteDevice_Response {
	res := zzz_vproto_internal_new_cdeviceauth_deauthorizeremotedevice_response()
	return res
}

[inline]
pub fn (a CDeviceAuth_DeauthorizeRemoteDevice_Response) eq(b CDeviceAuth_DeauthorizeRemoteDevice_Response) bool {
	return true
}

[inline]
pub fn (a CDeviceAuth_DeauthorizeRemoteDevice_Response) ne(b CDeviceAuth_DeauthorizeRemoteDevice_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_DeauthorizeRemoteDevice_Response) eq(b []CDeviceAuth_DeauthorizeRemoteDevice_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_DeauthorizeRemoteDevice_Response) ne(b []CDeviceAuth_DeauthorizeRemoteDevice_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_deauthorizeremotedevice_response() CDeviceAuth_DeauthorizeRemoteDevice_Response {
	return CDeviceAuth_DeauthorizeRemoteDevice_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_deauthorizeremotedevice_response(o CDeviceAuth_DeauthorizeRemoteDevice_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_deauthorizeremotedevice_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_DeauthorizeRemoteDevice_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_deauthorizeremotedevice_response_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetUsedAuthorizedDevices_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
}

pub fn (o &CDeviceAuth_GetUsedAuthorizedDevices_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cdeviceauth_getusedauthorizeddevices_request_unpack(buf []byte) ?CDeviceAuth_GetUsedAuthorizedDevices_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_getusedauthorizeddevices_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetUsedAuthorizedDevices_Request) eq(b CDeviceAuth_GetUsedAuthorizedDevices_Request) bool {
	return true && a.steamid == b.steamid
}

[inline]
pub fn (a CDeviceAuth_GetUsedAuthorizedDevices_Request) ne(b CDeviceAuth_GetUsedAuthorizedDevices_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetUsedAuthorizedDevices_Request) eq(b []CDeviceAuth_GetUsedAuthorizedDevices_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetUsedAuthorizedDevices_Request) ne(b []CDeviceAuth_GetUsedAuthorizedDevices_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getusedauthorizeddevices_request() CDeviceAuth_GetUsedAuthorizedDevices_Request {
	return CDeviceAuth_GetUsedAuthorizedDevices_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getusedauthorizeddevices_request(o CDeviceAuth_GetUsedAuthorizedDevices_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getusedauthorizeddevices_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetUsedAuthorizedDevices_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getusedauthorizeddevices_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetUsedAuthorizedDevices_Response_Device {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	auth_device_token u64
	device_name       string
	owner_steamid     u64
	last_time_used    u32
	last_app_played   u32
}

pub fn (o &CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) pack() []byte {
	mut res := []byte{}
	if o.auth_device_token != u64(0) {
		res << vproto.pack_64bit_field(o.auth_device_token, 1)
	}
	if o.device_name != '' {
		res << vproto.pack_string_field(o.device_name, 2)
	}
	if o.owner_steamid != u64(0) {
		res << vproto.pack_64bit_field(o.owner_steamid, 3)
	}
	if o.last_time_used != u32(0) {
		res << vproto.pack_uint32_field(o.last_time_used, 4)
	}
	if o.last_app_played != u32(0) {
		res << vproto.pack_uint32_field(o.last_app_played, 5)
	}
	return res
}

pub fn cdeviceauth_getusedauthorizeddevices_response_device_unpack(buf []byte) ?CDeviceAuth_GetUsedAuthorizedDevices_Response_Device {
	mut res := zzz_vproto_internal_new_cdeviceauth_getusedauthorizeddevices_response_device()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.auth_device_token = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.device_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.owner_steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.last_time_used = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.last_app_played = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) eq(b CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) bool {
	return true && a.auth_device_token == b.auth_device_token && a.device_name == b.device_name &&
		a.owner_steamid == b.owner_steamid && a.last_time_used == b.last_time_used && a.last_app_played ==
		b.last_app_played
}

[inline]
pub fn (a CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) ne(b CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) eq(b []CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) ne(b []CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getusedauthorizeddevices_response_device() CDeviceAuth_GetUsedAuthorizedDevices_Response_Device {
	return CDeviceAuth_GetUsedAuthorizedDevices_Response_Device{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getusedauthorizeddevices_response_device(o CDeviceAuth_GetUsedAuthorizedDevices_Response_Device, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getusedauthorizeddevices_response_device(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getusedauthorizeddevices_response_device_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetUsedAuthorizedDevices_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	devices        []CDeviceAuth_GetUsedAuthorizedDevices_Response_Device
}

pub fn (o &CDeviceAuth_GetUsedAuthorizedDevices_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.devices {
		res <<
			zzz_vproto_internal_pack_cdeviceauth_getusedauthorizeddevices_response_device(x, 1)
	}
	return res
}

pub fn cdeviceauth_getusedauthorizeddevices_response_unpack(buf []byte) ?CDeviceAuth_GetUsedAuthorizedDevices_Response {
	mut res := zzz_vproto_internal_new_cdeviceauth_getusedauthorizeddevices_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getusedauthorizeddevices_response_device(cur_buf,
					tag_wiretype.wire_type) ?
				res.devices << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetUsedAuthorizedDevices_Response) eq(b CDeviceAuth_GetUsedAuthorizedDevices_Response) bool {
	return true && a.devices.eq(b.devices)
}

[inline]
pub fn (a CDeviceAuth_GetUsedAuthorizedDevices_Response) ne(b CDeviceAuth_GetUsedAuthorizedDevices_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetUsedAuthorizedDevices_Response) eq(b []CDeviceAuth_GetUsedAuthorizedDevices_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetUsedAuthorizedDevices_Response) ne(b []CDeviceAuth_GetUsedAuthorizedDevices_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getusedauthorizeddevices_response() CDeviceAuth_GetUsedAuthorizedDevices_Response {
	return CDeviceAuth_GetUsedAuthorizedDevices_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getusedauthorizeddevices_response(o CDeviceAuth_GetUsedAuthorizedDevices_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getusedauthorizeddevices_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetUsedAuthorizedDevices_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getusedauthorizeddevices_response_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedBorrowers_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	include_canceled bool
	include_pending  bool
}

pub fn (o &CDeviceAuth_GetAuthorizedBorrowers_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.include_canceled != false {
		res << vproto.pack_bool_field(o.include_canceled, 2)
	}
	if o.include_pending != false {
		res << vproto.pack_bool_field(o.include_pending, 3)
	}
	return res
}

pub fn cdeviceauth_getauthorizedborrowers_request_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedBorrowers_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_getauthorizedborrowers_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.include_canceled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.include_pending = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedBorrowers_Request) eq(b CDeviceAuth_GetAuthorizedBorrowers_Request) bool {
	return true && a.steamid == b.steamid && a.include_canceled == b.include_canceled &&
		a.include_pending == b.include_pending
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedBorrowers_Request) ne(b CDeviceAuth_GetAuthorizedBorrowers_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedBorrowers_Request) eq(b []CDeviceAuth_GetAuthorizedBorrowers_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedBorrowers_Request) ne(b []CDeviceAuth_GetAuthorizedBorrowers_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedborrowers_request() CDeviceAuth_GetAuthorizedBorrowers_Request {
	return CDeviceAuth_GetAuthorizedBorrowers_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedborrowers_request(o CDeviceAuth_GetAuthorizedBorrowers_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedborrowers_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedBorrowers_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getauthorizedborrowers_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	is_pending     bool
	is_canceled    bool
	time_created   u32
}

pub fn (o &CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.is_pending != false {
		res << vproto.pack_bool_field(o.is_pending, 2)
	}
	if o.is_canceled != false {
		res << vproto.pack_bool_field(o.is_canceled, 3)
	}
	if o.time_created != u32(0) {
		res << vproto.pack_uint32_field(o.time_created, 4)
	}
	return res
}

pub fn cdeviceauth_getauthorizedborrowers_response_borrower_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower {
	mut res := zzz_vproto_internal_new_cdeviceauth_getauthorizedborrowers_response_borrower()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.is_pending = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.is_canceled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.time_created = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) eq(b CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) bool {
	return true && a.steamid == b.steamid && a.is_pending == b.is_pending && a.is_canceled ==
		b.is_canceled && a.time_created == b.time_created
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) ne(b CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) eq(b []CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) ne(b []CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedborrowers_response_borrower() CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower {
	return CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedborrowers_response_borrower(o CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedborrowers_response_borrower(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getauthorizedborrowers_response_borrower_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedBorrowers_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	borrowers      []CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower
}

pub fn (o &CDeviceAuth_GetAuthorizedBorrowers_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.borrowers {
		res <<
			zzz_vproto_internal_pack_cdeviceauth_getauthorizedborrowers_response_borrower(x, 1)
	}
	return res
}

pub fn cdeviceauth_getauthorizedborrowers_response_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedBorrowers_Response {
	mut res := zzz_vproto_internal_new_cdeviceauth_getauthorizedborrowers_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getauthorizedborrowers_response_borrower(cur_buf,
					tag_wiretype.wire_type) ?
				res.borrowers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedBorrowers_Response) eq(b CDeviceAuth_GetAuthorizedBorrowers_Response) bool {
	return true && a.borrowers.eq(b.borrowers)
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedBorrowers_Response) ne(b CDeviceAuth_GetAuthorizedBorrowers_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedBorrowers_Response) eq(b []CDeviceAuth_GetAuthorizedBorrowers_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedBorrowers_Response) ne(b []CDeviceAuth_GetAuthorizedBorrowers_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedborrowers_response() CDeviceAuth_GetAuthorizedBorrowers_Response {
	return CDeviceAuth_GetAuthorizedBorrowers_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedborrowers_response(o CDeviceAuth_GetAuthorizedBorrowers_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedborrowers_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedBorrowers_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getauthorizedborrowers_response_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_AddAuthorizedBorrowers_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	steamid_borrower []u64
}

pub fn (o &CDeviceAuth_AddAuthorizedBorrowers_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	// [packed=false]
	for _, x in o.steamid_borrower {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cdeviceauth_addauthorizedborrowers_request_unpack(buf []byte) ?CDeviceAuth_AddAuthorizedBorrowers_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_addauthorizedborrowers_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid_borrower << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_AddAuthorizedBorrowers_Request) eq(b CDeviceAuth_AddAuthorizedBorrowers_Request) bool {
	return true && a.steamid == b.steamid && a.steamid_borrower == b.steamid_borrower
}

[inline]
pub fn (a CDeviceAuth_AddAuthorizedBorrowers_Request) ne(b CDeviceAuth_AddAuthorizedBorrowers_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_AddAuthorizedBorrowers_Request) eq(b []CDeviceAuth_AddAuthorizedBorrowers_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_AddAuthorizedBorrowers_Request) ne(b []CDeviceAuth_AddAuthorizedBorrowers_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_addauthorizedborrowers_request() CDeviceAuth_AddAuthorizedBorrowers_Request {
	return CDeviceAuth_AddAuthorizedBorrowers_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_addauthorizedborrowers_request(o CDeviceAuth_AddAuthorizedBorrowers_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_addauthorizedborrowers_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AddAuthorizedBorrowers_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_addauthorizedborrowers_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_AddAuthorizedBorrowers_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	seconds_to_wait int
}

pub fn (o &CDeviceAuth_AddAuthorizedBorrowers_Response) pack() []byte {
	mut res := []byte{}
	if o.seconds_to_wait != int(0) {
		res << vproto.pack_int32_field(o.seconds_to_wait, 1)
	}
	return res
}

pub fn cdeviceauth_addauthorizedborrowers_response_unpack(buf []byte) ?CDeviceAuth_AddAuthorizedBorrowers_Response {
	mut res := zzz_vproto_internal_new_cdeviceauth_addauthorizedborrowers_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.seconds_to_wait = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_AddAuthorizedBorrowers_Response) eq(b CDeviceAuth_AddAuthorizedBorrowers_Response) bool {
	return true && a.seconds_to_wait == b.seconds_to_wait
}

[inline]
pub fn (a CDeviceAuth_AddAuthorizedBorrowers_Response) ne(b CDeviceAuth_AddAuthorizedBorrowers_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_AddAuthorizedBorrowers_Response) eq(b []CDeviceAuth_AddAuthorizedBorrowers_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_AddAuthorizedBorrowers_Response) ne(b []CDeviceAuth_AddAuthorizedBorrowers_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_addauthorizedborrowers_response() CDeviceAuth_AddAuthorizedBorrowers_Response {
	return CDeviceAuth_AddAuthorizedBorrowers_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_addauthorizedborrowers_response(o CDeviceAuth_AddAuthorizedBorrowers_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_addauthorizedborrowers_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AddAuthorizedBorrowers_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_addauthorizedborrowers_response_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_RemoveAuthorizedBorrowers_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	steamid_borrower []u64
}

pub fn (o &CDeviceAuth_RemoveAuthorizedBorrowers_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	// [packed=false]
	for _, x in o.steamid_borrower {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cdeviceauth_removeauthorizedborrowers_request_unpack(buf []byte) ?CDeviceAuth_RemoveAuthorizedBorrowers_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_removeauthorizedborrowers_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid_borrower << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_RemoveAuthorizedBorrowers_Request) eq(b CDeviceAuth_RemoveAuthorizedBorrowers_Request) bool {
	return true && a.steamid == b.steamid && a.steamid_borrower == b.steamid_borrower
}

[inline]
pub fn (a CDeviceAuth_RemoveAuthorizedBorrowers_Request) ne(b CDeviceAuth_RemoveAuthorizedBorrowers_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_RemoveAuthorizedBorrowers_Request) eq(b []CDeviceAuth_RemoveAuthorizedBorrowers_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_RemoveAuthorizedBorrowers_Request) ne(b []CDeviceAuth_RemoveAuthorizedBorrowers_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_removeauthorizedborrowers_request() CDeviceAuth_RemoveAuthorizedBorrowers_Request {
	return CDeviceAuth_RemoveAuthorizedBorrowers_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_removeauthorizedborrowers_request(o CDeviceAuth_RemoveAuthorizedBorrowers_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_removeauthorizedborrowers_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_RemoveAuthorizedBorrowers_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_removeauthorizedborrowers_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_RemoveAuthorizedBorrowers_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuth_RemoveAuthorizedBorrowers_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauth_removeauthorizedborrowers_response_unpack(buf []byte) ?CDeviceAuth_RemoveAuthorizedBorrowers_Response {
	res := zzz_vproto_internal_new_cdeviceauth_removeauthorizedborrowers_response()
	return res
}

[inline]
pub fn (a CDeviceAuth_RemoveAuthorizedBorrowers_Response) eq(b CDeviceAuth_RemoveAuthorizedBorrowers_Response) bool {
	return true
}

[inline]
pub fn (a CDeviceAuth_RemoveAuthorizedBorrowers_Response) ne(b CDeviceAuth_RemoveAuthorizedBorrowers_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_RemoveAuthorizedBorrowers_Response) eq(b []CDeviceAuth_RemoveAuthorizedBorrowers_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_RemoveAuthorizedBorrowers_Response) ne(b []CDeviceAuth_RemoveAuthorizedBorrowers_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_removeauthorizedborrowers_response() CDeviceAuth_RemoveAuthorizedBorrowers_Response {
	return CDeviceAuth_RemoveAuthorizedBorrowers_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_removeauthorizedborrowers_response(o CDeviceAuth_RemoveAuthorizedBorrowers_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_removeauthorizedborrowers_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_RemoveAuthorizedBorrowers_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_removeauthorizedborrowers_response_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedAsBorrower_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	include_canceled bool
	include_pending  bool
}

pub fn (o &CDeviceAuth_GetAuthorizedAsBorrower_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.include_canceled != false {
		res << vproto.pack_bool_field(o.include_canceled, 2)
	}
	if o.include_pending != false {
		res << vproto.pack_bool_field(o.include_pending, 3)
	}
	return res
}

pub fn cdeviceauth_getauthorizedasborrower_request_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedAsBorrower_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_getauthorizedasborrower_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.include_canceled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.include_pending = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedAsBorrower_Request) eq(b CDeviceAuth_GetAuthorizedAsBorrower_Request) bool {
	return true && a.steamid == b.steamid && a.include_canceled == b.include_canceled &&
		a.include_pending == b.include_pending
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedAsBorrower_Request) ne(b CDeviceAuth_GetAuthorizedAsBorrower_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedAsBorrower_Request) eq(b []CDeviceAuth_GetAuthorizedAsBorrower_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedAsBorrower_Request) ne(b []CDeviceAuth_GetAuthorizedAsBorrower_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedasborrower_request() CDeviceAuth_GetAuthorizedAsBorrower_Request {
	return CDeviceAuth_GetAuthorizedAsBorrower_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedasborrower_request(o CDeviceAuth_GetAuthorizedAsBorrower_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedasborrower_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedAsBorrower_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getauthorizedasborrower_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	time_created   u32
	is_pending     bool
	is_canceled    bool
	is_used        bool
}

pub fn (o &CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.time_created != u32(0) {
		res << vproto.pack_uint32_field(o.time_created, 2)
	}
	if o.is_pending != false {
		res << vproto.pack_bool_field(o.is_pending, 3)
	}
	if o.is_canceled != false {
		res << vproto.pack_bool_field(o.is_canceled, 4)
	}
	if o.is_used != false {
		res << vproto.pack_bool_field(o.is_used, 5)
	}
	return res
}

pub fn cdeviceauth_getauthorizedasborrower_response_lender_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender {
	mut res := zzz_vproto_internal_new_cdeviceauth_getauthorizedasborrower_response_lender()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.time_created = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.is_pending = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.is_canceled = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.is_used = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) eq(b CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) bool {
	return true && a.steamid == b.steamid && a.time_created == b.time_created && a.is_pending ==
		b.is_pending && a.is_canceled == b.is_canceled && a.is_used == b.is_used
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) ne(b CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) eq(b []CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) ne(b []CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedasborrower_response_lender() CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender {
	return CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedasborrower_response_lender(o CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedasborrower_response_lender(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getauthorizedasborrower_response_lender_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedAsBorrower_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	lenders        []CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender
}

pub fn (o &CDeviceAuth_GetAuthorizedAsBorrower_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.lenders {
		res <<
			zzz_vproto_internal_pack_cdeviceauth_getauthorizedasborrower_response_lender(x, 1)
	}
	return res
}

pub fn cdeviceauth_getauthorizedasborrower_response_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedAsBorrower_Response {
	mut res := zzz_vproto_internal_new_cdeviceauth_getauthorizedasborrower_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getauthorizedasborrower_response_lender(cur_buf,
					tag_wiretype.wire_type) ?
				res.lenders << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedAsBorrower_Response) eq(b CDeviceAuth_GetAuthorizedAsBorrower_Response) bool {
	return true && a.lenders.eq(b.lenders)
}

[inline]
pub fn (a CDeviceAuth_GetAuthorizedAsBorrower_Response) ne(b CDeviceAuth_GetAuthorizedAsBorrower_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedAsBorrower_Response) eq(b []CDeviceAuth_GetAuthorizedAsBorrower_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetAuthorizedAsBorrower_Response) ne(b []CDeviceAuth_GetAuthorizedAsBorrower_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedasborrower_response() CDeviceAuth_GetAuthorizedAsBorrower_Response {
	return CDeviceAuth_GetAuthorizedAsBorrower_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedasborrower_response(o CDeviceAuth_GetAuthorizedAsBorrower_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedasborrower_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedAsBorrower_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getauthorizedasborrower_response_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetExcludedGamesInLibrary_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
}

pub fn (o &CDeviceAuth_GetExcludedGamesInLibrary_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cdeviceauth_getexcludedgamesinlibrary_request_unpack(buf []byte) ?CDeviceAuth_GetExcludedGamesInLibrary_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_getexcludedgamesinlibrary_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetExcludedGamesInLibrary_Request) eq(b CDeviceAuth_GetExcludedGamesInLibrary_Request) bool {
	return true && a.steamid == b.steamid
}

[inline]
pub fn (a CDeviceAuth_GetExcludedGamesInLibrary_Request) ne(b CDeviceAuth_GetExcludedGamesInLibrary_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetExcludedGamesInLibrary_Request) eq(b []CDeviceAuth_GetExcludedGamesInLibrary_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetExcludedGamesInLibrary_Request) ne(b []CDeviceAuth_GetExcludedGamesInLibrary_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getexcludedgamesinlibrary_request() CDeviceAuth_GetExcludedGamesInLibrary_Request {
	return CDeviceAuth_GetExcludedGamesInLibrary_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getexcludedgamesinlibrary_request(o CDeviceAuth_GetExcludedGamesInLibrary_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getexcludedgamesinlibrary_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetExcludedGamesInLibrary_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getexcludedgamesinlibrary_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	game_name        string
	vac_banned       bool
	package_excluded bool
}

pub fn (o &CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.game_name != '' {
		res << vproto.pack_string_field(o.game_name, 2)
	}
	if o.vac_banned != false {
		res << vproto.pack_bool_field(o.vac_banned, 3)
	}
	if o.package_excluded != false {
		res << vproto.pack_bool_field(o.package_excluded, 4)
	}
	return res
}

pub fn cdeviceauth_getexcludedgamesinlibrary_response_excludedgame_unpack(buf []byte) ?CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame {
	mut res := zzz_vproto_internal_new_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.game_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.vac_banned = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.package_excluded = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) eq(b CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) bool {
	return true && a.appid == b.appid && a.game_name == b.game_name && a.vac_banned == b.vac_banned &&
		a.package_excluded == b.package_excluded
}

[inline]
pub fn (a CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) ne(b CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) eq(b []CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) ne(b []CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame() CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame {
	return CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame(o CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getexcludedgamesinlibrary_response_excludedgame_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetExcludedGamesInLibrary_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	excluded_games []CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame
}

pub fn (o &CDeviceAuth_GetExcludedGamesInLibrary_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.excluded_games {
		res <<
			zzz_vproto_internal_pack_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame(x, 1)
	}
	return res
}

pub fn cdeviceauth_getexcludedgamesinlibrary_response_unpack(buf []byte) ?CDeviceAuth_GetExcludedGamesInLibrary_Response {
	mut res := zzz_vproto_internal_new_cdeviceauth_getexcludedgamesinlibrary_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame(cur_buf,
					tag_wiretype.wire_type) ?
				res.excluded_games << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetExcludedGamesInLibrary_Response) eq(b CDeviceAuth_GetExcludedGamesInLibrary_Response) bool {
	return true && a.excluded_games.eq(b.excluded_games)
}

[inline]
pub fn (a CDeviceAuth_GetExcludedGamesInLibrary_Response) ne(b CDeviceAuth_GetExcludedGamesInLibrary_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetExcludedGamesInLibrary_Response) eq(b []CDeviceAuth_GetExcludedGamesInLibrary_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetExcludedGamesInLibrary_Response) ne(b []CDeviceAuth_GetExcludedGamesInLibrary_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getexcludedgamesinlibrary_response() CDeviceAuth_GetExcludedGamesInLibrary_Response {
	return CDeviceAuth_GetExcludedGamesInLibrary_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getexcludedgamesinlibrary_response(o CDeviceAuth_GetExcludedGamesInLibrary_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getexcludedgamesinlibrary_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetExcludedGamesInLibrary_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getexcludedgamesinlibrary_response_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetBorrowerPlayHistory_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
}

pub fn (o &CDeviceAuth_GetBorrowerPlayHistory_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cdeviceauth_getborrowerplayhistory_request_unpack(buf []byte) ?CDeviceAuth_GetBorrowerPlayHistory_Request {
	mut res := zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetBorrowerPlayHistory_Request) eq(b CDeviceAuth_GetBorrowerPlayHistory_Request) bool {
	return true && a.steamid == b.steamid
}

[inline]
pub fn (a CDeviceAuth_GetBorrowerPlayHistory_Request) ne(b CDeviceAuth_GetBorrowerPlayHistory_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetBorrowerPlayHistory_Request) eq(b []CDeviceAuth_GetBorrowerPlayHistory_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetBorrowerPlayHistory_Request) ne(b []CDeviceAuth_GetBorrowerPlayHistory_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_request() CDeviceAuth_GetBorrowerPlayHistory_Request {
	return CDeviceAuth_GetBorrowerPlayHistory_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_request(o CDeviceAuth_GetBorrowerPlayHistory_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetBorrowerPlayHistory_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getborrowerplayhistory_request_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	time_last      u32
	time_total     u32
}

pub fn (o &CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.time_last != u32(0) {
		res << vproto.pack_uint32_field(o.time_last, 2)
	}
	if o.time_total != u32(0) {
		res << vproto.pack_uint32_field(o.time_total, 3)
	}
	return res
}

pub fn cdeviceauth_getborrowerplayhistory_response_gamehistory_unpack(buf []byte) ?CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory {
	mut res := zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_response_gamehistory()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.time_last = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.time_total = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) eq(b CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) bool {
	return true && a.appid == b.appid && a.time_last == b.time_last && a.time_total == b.time_total
}

[inline]
pub fn (a CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) ne(b CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) eq(b []CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) ne(b []CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_response_gamehistory() CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory {
	return CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_response_gamehistory(o CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_response_gamehistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getborrowerplayhistory_response_gamehistory_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	game_history   []CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory
}

pub fn (o &CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	// [packed=false]
	for _, x in o.game_history {
		res <<
			zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_response_gamehistory(x, 2)
	}
	return res
}

pub fn cdeviceauth_getborrowerplayhistory_response_lenderhistory_unpack(buf []byte) ?CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory {
	mut res := zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_response_lenderhistory()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_response_gamehistory(cur_buf,
					tag_wiretype.wire_type) ?
				res.game_history << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) eq(b CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) bool {
	return true && a.steamid == b.steamid && a.game_history.eq(b.game_history)
}

[inline]
pub fn (a CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) ne(b CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) eq(b []CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) ne(b []CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_response_lenderhistory() CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory {
	return CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_response_lenderhistory(o CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_response_lenderhistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getborrowerplayhistory_response_lenderhistory_unpack(v) ?
	return i, unpacked
}

pub struct CDeviceAuth_GetBorrowerPlayHistory_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	lender_history []CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory
}

pub fn (o &CDeviceAuth_GetBorrowerPlayHistory_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.lender_history {
		res <<
			zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_response_lenderhistory(x, 1)
	}
	return res
}

pub fn cdeviceauth_getborrowerplayhistory_response_unpack(buf []byte) ?CDeviceAuth_GetBorrowerPlayHistory_Response {
	mut res := zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_response_lenderhistory(cur_buf,
					tag_wiretype.wire_type) ?
				res.lender_history << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CDeviceAuth_GetBorrowerPlayHistory_Response) eq(b CDeviceAuth_GetBorrowerPlayHistory_Response) bool {
	return true && a.lender_history.eq(b.lender_history)
}

[inline]
pub fn (a CDeviceAuth_GetBorrowerPlayHistory_Response) ne(b CDeviceAuth_GetBorrowerPlayHistory_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CDeviceAuth_GetBorrowerPlayHistory_Response) eq(b []CDeviceAuth_GetBorrowerPlayHistory_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CDeviceAuth_GetBorrowerPlayHistory_Response) ne(b []CDeviceAuth_GetBorrowerPlayHistory_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_response() CDeviceAuth_GetBorrowerPlayHistory_Response {
	return CDeviceAuth_GetBorrowerPlayHistory_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_response(o CDeviceAuth_GetBorrowerPlayHistory_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetBorrowerPlayHistory_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cdeviceauth_getborrowerplayhistory_response_unpack(v) ?
	return i, unpacked
}
