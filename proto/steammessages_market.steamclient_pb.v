// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CEconMarket_IsMarketplaceAllowed_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	webcookie      string
}

pub fn (o &CEconMarket_IsMarketplaceAllowed_Request) pack() []byte {
	mut res := []byte{}
	if o.webcookie != '' {
		res << vproto.pack_string_field(o.webcookie, 1)
	}
	return res
}

pub fn ceconmarket_ismarketplaceallowed_request_unpack(buf []byte) ?CEconMarket_IsMarketplaceAllowed_Request {
	mut res := zzz_vproto_internal_new_ceconmarket_ismarketplaceallowed_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.webcookie = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CEconMarket_IsMarketplaceAllowed_Request) eq(b CEconMarket_IsMarketplaceAllowed_Request) bool {
	return true && a.webcookie == b.webcookie
}

[inline]
pub fn (a CEconMarket_IsMarketplaceAllowed_Request) ne(b CEconMarket_IsMarketplaceAllowed_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CEconMarket_IsMarketplaceAllowed_Request) eq(b []CEconMarket_IsMarketplaceAllowed_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CEconMarket_IsMarketplaceAllowed_Request) ne(b []CEconMarket_IsMarketplaceAllowed_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ceconmarket_ismarketplaceallowed_request() CEconMarket_IsMarketplaceAllowed_Request {
	return CEconMarket_IsMarketplaceAllowed_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ceconmarket_ismarketplaceallowed_request(o CEconMarket_IsMarketplaceAllowed_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ceconmarket_ismarketplaceallowed_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconMarket_IsMarketplaceAllowed_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ceconmarket_ismarketplaceallowed_request_unpack(v) ?
	return i, unpacked
}

pub struct CEconMarket_IsMarketplaceAllowed_Response {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	allowed                    bool
	reason                     u32
	allowed_at_time            u32
	steamguard_required_days   u32
	forms_requested            bool
	forms_require_verification bool
	new_device_cooldown_days   u32
}

pub fn (o &CEconMarket_IsMarketplaceAllowed_Response) pack() []byte {
	mut res := []byte{}
	if o.allowed != false {
		res << vproto.pack_bool_field(o.allowed, 1)
	}
	if o.reason != u32(0) {
		res << vproto.pack_uint32_field(o.reason, 2)
	}
	if o.allowed_at_time != u32(0) {
		res << vproto.pack_uint32_field(o.allowed_at_time, 3)
	}
	if o.steamguard_required_days != u32(0) {
		res << vproto.pack_uint32_field(o.steamguard_required_days, 4)
	}
	if o.forms_requested != false {
		res << vproto.pack_bool_field(o.forms_requested, 7)
	}
	if o.forms_require_verification != false {
		res << vproto.pack_bool_field(o.forms_require_verification, 8)
	}
	if o.new_device_cooldown_days != u32(0) {
		res << vproto.pack_uint32_field(o.new_device_cooldown_days, 9)
	}
	return res
}

pub fn ceconmarket_ismarketplaceallowed_response_unpack(buf []byte) ?CEconMarket_IsMarketplaceAllowed_Response {
	mut res := zzz_vproto_internal_new_ceconmarket_ismarketplaceallowed_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.allowed = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.reason = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.allowed_at_time = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.steamguard_required_days = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			7 {
				i, res.forms_requested = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.forms_require_verification = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			9 {
				i, res.new_device_cooldown_days = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CEconMarket_IsMarketplaceAllowed_Response) eq(b CEconMarket_IsMarketplaceAllowed_Response) bool {
	return true && a.allowed == b.allowed && a.reason == b.reason && a.allowed_at_time == b.allowed_at_time &&
		a.steamguard_required_days == b.steamguard_required_days && a.forms_requested == b.forms_requested &&
		a.forms_require_verification == b.forms_require_verification && a.new_device_cooldown_days ==
		b.new_device_cooldown_days
}

[inline]
pub fn (a CEconMarket_IsMarketplaceAllowed_Response) ne(b CEconMarket_IsMarketplaceAllowed_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CEconMarket_IsMarketplaceAllowed_Response) eq(b []CEconMarket_IsMarketplaceAllowed_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CEconMarket_IsMarketplaceAllowed_Response) ne(b []CEconMarket_IsMarketplaceAllowed_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ceconmarket_ismarketplaceallowed_response() CEconMarket_IsMarketplaceAllowed_Response {
	return CEconMarket_IsMarketplaceAllowed_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ceconmarket_ismarketplaceallowed_response(o CEconMarket_IsMarketplaceAllowed_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ceconmarket_ismarketplaceallowed_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconMarket_IsMarketplaceAllowed_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := ceconmarket_ismarketplaceallowed_response_unpack(v) ?
	return i, unpacked
}
