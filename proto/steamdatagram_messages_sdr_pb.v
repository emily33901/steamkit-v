// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum ESteamDatagramMsgID {
	k_esteamdatagrammsg_invalid = 0
	k_esteamdatagrammsg_routerpingrequest = 1
	k_esteamdatagrammsg_routerpingreply = 2
	k_esteamdatagrammsg_gameserverpingrequest = 3
	k_esteamdatagrammsg_legacygameserverpingreply = 4
	k_esteamdatagrammsg_gameserversessionrequest = 5
	k_esteamdatagrammsg_gameserversessionestablished = 6
	k_esteamdatagrammsg_nosession = 7
	k_esteamdatagrammsg_diagnostic = 8
	k_esteamdatagrammsg_dataclienttorouter = 9
	k_esteamdatagrammsg_dataroutertoserver = 10
	k_esteamdatagrammsg_dataservertorouter = 11
	k_esteamdatagrammsg_dataroutertoclient = 12
	k_esteamdatagrammsg_stats = 13
	k_esteamdatagrammsg_clientpingsamplerequest = 14
	k_esteamdatagrammsg_clientpingsamplereply = 15
	k_esteamdatagrammsg_clienttorouterswitchedprimary = 16
	k_esteamdatagrammsg_relayhealth = 17
	k_esteamdatagrammsg_connectrequest = 18
	k_esteamdatagrammsg_connectok = 19
	k_esteamdatagrammsg_connectionclosed = 20
	k_esteamdatagrammsg_noconnection = 21
	k_esteamdatagrammsg_relaytorelaypingrequest = 22
	k_esteamdatagrammsg_relaytorelaypingreply = 23
	k_esteamdatagrammsg_p2psessionrequest = 24
	k_esteamdatagrammsg_p2psessionestablished = 25
	k_esteamdatagrammsg_p2pstatsclient = 26
	k_esteamdatagrammsg_p2pstatsrelay = 27
	k_esteamdatagrammsg_p2pbadroute = 28
	k_esteamdatagrammsg_gameserverpingreply = 29
	k_esteamdatagrammsg_gameserverregistration = 30
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_esteamdatagrammsgid() ESteamDatagramMsgID {
	return .k_esteamdatagrammsg_invalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_esteamdatagrammsgid(e ESteamDatagramMsgID, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_esteamdatagrammsgid_packed(e []ESteamDatagramMsgID, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_esteamdatagrammsgid(buf []byte, tag_wiretype vproto.WireType) ?(int, ESteamDatagramMsgID) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, ESteamDatagramMsgID(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_esteamdatagrammsgid_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ESteamDatagramMsgID) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramRouterPingReply_RouteException {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	data_center_id u32
	flags          u32
	penalty        u32
}

pub fn (o &CMsgSteamDatagramRouterPingReply_RouteException) pack() []byte {
	mut res := []byte{}
	if o.data_center_id != u32(0) {
		res << vproto.pack_32bit_field(o.data_center_id, 1)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 2)
	}
	if o.penalty != u32(0) {
		res << vproto.pack_uint32_field(o.penalty, 3)
	}
	return res
}

pub fn cmsgsteamdatagramrouterpingreply_routeexception_unpack(buf []byte) ?CMsgSteamDatagramRouterPingReply_RouteException {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramrouterpingreply_routeexception()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.data_center_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.flags = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.penalty = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramRouterPingReply_RouteException) eq(b CMsgSteamDatagramRouterPingReply_RouteException) bool {
	return true && a.data_center_id == b.data_center_id && a.flags == b.flags && a.penalty ==
		b.penalty
}

[inline]
pub fn (a CMsgSteamDatagramRouterPingReply_RouteException) ne(b CMsgSteamDatagramRouterPingReply_RouteException) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramRouterPingReply_RouteException) eq(b []CMsgSteamDatagramRouterPingReply_RouteException) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramRouterPingReply_RouteException) ne(b []CMsgSteamDatagramRouterPingReply_RouteException) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterpingreply_routeexception() CMsgSteamDatagramRouterPingReply_RouteException {
	return CMsgSteamDatagramRouterPingReply_RouteException{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterpingreply_routeexception(o CMsgSteamDatagramRouterPingReply_RouteException, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterpingreply_routeexception(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterPingReply_RouteException) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramrouterpingreply_routeexception_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramRouterPingReply {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	client_timestamp              u32
	latency_datacenter_ids        []u32
	latency_ping_ms               []u32
	your_public_ip                u32
	server_time                   u32
	challenge                     u64
	seconds_until_shutdown        u32
	client_cookie                 u32
	scoring_penalty_relay_cluster u32
	route_exceptions              []CMsgSteamDatagramRouterPingReply_RouteException
}

pub fn (o &CMsgSteamDatagramRouterPingReply) pack() []byte {
	mut res := []byte{}
	if o.client_timestamp != u32(0) {
		res << vproto.pack_32bit_field(o.client_timestamp, 1)
	}
	// [packed=true]
	res << vproto.pack_32bit_field_packed(o.latency_datacenter_ids, 2)
	// [packed=true]
	res << vproto.pack_uint32_field_packed(o.latency_ping_ms, 3)
	if o.your_public_ip != u32(0) {
		res << vproto.pack_32bit_field(o.your_public_ip, 4)
	}
	if o.server_time != u32(0) {
		res << vproto.pack_32bit_field(o.server_time, 5)
	}
	if o.challenge != u64(0) {
		res << vproto.pack_64bit_field(o.challenge, 6)
	}
	if o.seconds_until_shutdown != u32(0) {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 7)
	}
	if o.client_cookie != u32(0) {
		res << vproto.pack_32bit_field(o.client_cookie, 8)
	}
	if o.scoring_penalty_relay_cluster != u32(0) {
		res << vproto.pack_uint32_field(o.scoring_penalty_relay_cluster, 9)
	}
	// [packed=false]
	for _, x in o.route_exceptions {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramrouterpingreply_routeexception(x, 10)
	}
	return res
}

pub fn cmsgsteamdatagramrouterpingreply_unpack(buf []byte) ?CMsgSteamDatagramRouterPingReply {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramrouterpingreply()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.client_timestamp = v
				i = ii
			}
			2 {
				// [packed=true]
				ii, v := vproto.unpack_32bit_field_packed(cur_buf, tag_wiretype.wire_type) ?
				res.latency_datacenter_ids << v
				i = ii
			}
			3 {
				// [packed=true]
				ii, v := vproto.unpack_uint32_field_packed(cur_buf, tag_wiretype.wire_type) ?
				res.latency_ping_ms << v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.your_public_ip = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.server_time = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.challenge = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seconds_until_shutdown = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.client_cookie = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.scoring_penalty_relay_cluster = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramrouterpingreply_routeexception(cur_buf,
					tag_wiretype.wire_type) ?
				res.route_exceptions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramRouterPingReply) eq(b CMsgSteamDatagramRouterPingReply) bool {
	return true && a.client_timestamp == b.client_timestamp && a.latency_datacenter_ids == b.latency_datacenter_ids &&
		a.latency_ping_ms == b.latency_ping_ms && a.your_public_ip == b.your_public_ip && a.server_time ==
		b.server_time && a.challenge == b.challenge && a.seconds_until_shutdown == b.seconds_until_shutdown &&
		a.client_cookie == b.client_cookie && a.scoring_penalty_relay_cluster == b.scoring_penalty_relay_cluster &&
		a.route_exceptions.eq(b.route_exceptions)
}

[inline]
pub fn (a CMsgSteamDatagramRouterPingReply) ne(b CMsgSteamDatagramRouterPingReply) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramRouterPingReply) eq(b []CMsgSteamDatagramRouterPingReply) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramRouterPingReply) ne(b []CMsgSteamDatagramRouterPingReply) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterpingreply() CMsgSteamDatagramRouterPingReply {
	return CMsgSteamDatagramRouterPingReply{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterpingreply(o CMsgSteamDatagramRouterPingReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterpingreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterPingReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramrouterpingreply_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameserverPingRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	your_public_ip   u32
	server_time      u32
	challenge        u64
	router_timestamp u32
}

pub fn (o &CMsgSteamDatagramGameserverPingRequest) pack() []byte {
	mut res := []byte{}
	if o.your_public_ip != u32(0) {
		res << vproto.pack_32bit_field(o.your_public_ip, 1)
	}
	if o.server_time != u32(0) {
		res << vproto.pack_32bit_field(o.server_time, 2)
	}
	if o.challenge != u64(0) {
		res << vproto.pack_64bit_field(o.challenge, 3)
	}
	if o.router_timestamp != u32(0) {
		res << vproto.pack_32bit_field(o.router_timestamp, 4)
	}
	return res
}

pub fn cmsgsteamdatagramgameserverpingrequest_unpack(buf []byte) ?CMsgSteamDatagramGameserverPingRequest {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.your_public_ip = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.server_time = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.challenge = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.router_timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramGameserverPingRequest) eq(b CMsgSteamDatagramGameserverPingRequest) bool {
	return true && a.your_public_ip == b.your_public_ip && a.server_time == b.server_time &&
		a.challenge == b.challenge && a.router_timestamp == b.router_timestamp
}

[inline]
pub fn (a CMsgSteamDatagramGameserverPingRequest) ne(b CMsgSteamDatagramGameserverPingRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramGameserverPingRequest) eq(b []CMsgSteamDatagramGameserverPingRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramGameserverPingRequest) ne(b []CMsgSteamDatagramGameserverPingRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingrequest() CMsgSteamDatagramGameserverPingRequest {
	return CMsgSteamDatagramGameserverPingRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserverpingrequest(o CMsgSteamDatagramGameserverPingRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserverpingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverPingRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramgameserverpingrequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramLegacyGameserverPingReply {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	router_timestamp u32
	dummy_pad        u64
}

pub fn (o &CMsgSteamDatagramLegacyGameserverPingReply) pack() []byte {
	mut res := []byte{}
	if o.router_timestamp != u32(0) {
		res << vproto.pack_32bit_field(o.router_timestamp, 4)
	}
	if o.dummy_pad != u64(0) {
		res << vproto.pack_64bit_field(o.dummy_pad, 99)
	}
	return res
}

pub fn cmsgsteamdatagramlegacygameserverpingreply_unpack(buf []byte) ?CMsgSteamDatagramLegacyGameserverPingReply {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramlegacygameserverpingreply()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			4 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.router_timestamp = v
				i = ii
			}
			99 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.dummy_pad = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramLegacyGameserverPingReply) eq(b CMsgSteamDatagramLegacyGameserverPingReply) bool {
	return true && a.router_timestamp == b.router_timestamp && a.dummy_pad == b.dummy_pad
}

[inline]
pub fn (a CMsgSteamDatagramLegacyGameserverPingReply) ne(b CMsgSteamDatagramLegacyGameserverPingReply) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramLegacyGameserverPingReply) eq(b []CMsgSteamDatagramLegacyGameserverPingReply) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramLegacyGameserverPingReply) ne(b []CMsgSteamDatagramLegacyGameserverPingReply) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramlegacygameserverpingreply() CMsgSteamDatagramLegacyGameserverPingReply {
	return CMsgSteamDatagramLegacyGameserverPingReply{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramlegacygameserverpingreply(o CMsgSteamDatagramLegacyGameserverPingReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramlegacygameserverpingreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramLegacyGameserverPingReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramlegacygameserverpingreply_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameserverPingReply_SignedData {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	challenge_time   u32
	challenge        u64
	router_timestamp u32
	data_center_id   u32
	appid            u32
}

pub fn (o &CMsgSteamDatagramGameserverPingReply_SignedData) pack() []byte {
	mut res := []byte{}
	if o.challenge_time != u32(0) {
		res << vproto.pack_32bit_field(o.challenge_time, 2)
	}
	if o.challenge != u64(0) {
		res << vproto.pack_64bit_field(o.challenge, 3)
	}
	if o.router_timestamp != u32(0) {
		res << vproto.pack_32bit_field(o.router_timestamp, 4)
	}
	if o.data_center_id != u32(0) {
		res << vproto.pack_32bit_field(o.data_center_id, 5)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 6)
	}
	return res
}

pub fn cmsgsteamdatagramgameserverpingreply_signeddata_unpack(buf []byte) ?CMsgSteamDatagramGameserverPingReply_SignedData {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingreply_signeddata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.challenge_time = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.challenge = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.router_timestamp = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.data_center_id = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramGameserverPingReply_SignedData) eq(b CMsgSteamDatagramGameserverPingReply_SignedData) bool {
	return true && a.challenge_time == b.challenge_time && a.challenge == b.challenge &&
		a.router_timestamp == b.router_timestamp && a.data_center_id == b.data_center_id && a.appid ==
		b.appid
}

[inline]
pub fn (a CMsgSteamDatagramGameserverPingReply_SignedData) ne(b CMsgSteamDatagramGameserverPingReply_SignedData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramGameserverPingReply_SignedData) eq(b []CMsgSteamDatagramGameserverPingReply_SignedData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramGameserverPingReply_SignedData) ne(b []CMsgSteamDatagramGameserverPingReply_SignedData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingreply_signeddata() CMsgSteamDatagramGameserverPingReply_SignedData {
	return CMsgSteamDatagramGameserverPingReply_SignedData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserverpingreply_signeddata(o CMsgSteamDatagramGameserverPingReply_SignedData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserverpingreply_signeddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverPingReply_SignedData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramgameserverpingreply_signeddata_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameserverPingReply {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cert           CMsgSteamDatagramCertificateSigned
	signed_data    []byte
	signature      []byte
}

pub fn (o &CMsgSteamDatagramGameserverPingReply) pack() []byte {
	mut res := []byte{}
	if o.cert.ne(zzz_vproto_internal_new_cmsgsteamdatagramcertificatesigned()) {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 1)
	}
	if o.signed_data != []byte{} {
		res << vproto.pack_bytes_field(o.signed_data, 2)
	}
	if o.signature != []byte{} {
		res << vproto.pack_bytes_field(o.signature, 3)
	}
	return res
}

pub fn cmsgsteamdatagramgameserverpingreply_unpack(buf []byte) ?CMsgSteamDatagramGameserverPingReply {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingreply()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type) ?
				res.cert = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.signed_data = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.signature = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramGameserverPingReply) eq(b CMsgSteamDatagramGameserverPingReply) bool {
	return true && a.cert.eq(b.cert) && a.signed_data == b.signed_data && a.signature == b.signature
}

[inline]
pub fn (a CMsgSteamDatagramGameserverPingReply) ne(b CMsgSteamDatagramGameserverPingReply) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramGameserverPingReply) eq(b []CMsgSteamDatagramGameserverPingReply) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramGameserverPingReply) ne(b []CMsgSteamDatagramGameserverPingReply) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingreply() CMsgSteamDatagramGameserverPingReply {
	return CMsgSteamDatagramGameserverPingReply{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserverpingreply(o CMsgSteamDatagramGameserverPingReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserverpingreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverPingReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramgameserverpingreply_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramNoSessionRelayToClient {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	connection_id          u32
	your_public_ip         u32
	server_time            u32
	challenge              u64
	seconds_until_shutdown u32
}

pub fn (o &CMsgSteamDatagramNoSessionRelayToClient) pack() []byte {
	mut res := []byte{}
	if o.connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.connection_id, 7)
	}
	if o.your_public_ip != u32(0) {
		res << vproto.pack_32bit_field(o.your_public_ip, 2)
	}
	if o.server_time != u32(0) {
		res << vproto.pack_32bit_field(o.server_time, 3)
	}
	if o.challenge != u64(0) {
		res << vproto.pack_64bit_field(o.challenge, 4)
	}
	if o.seconds_until_shutdown != u32(0) {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 5)
	}
	return res
}

pub fn cmsgsteamdatagramnosessionrelaytoclient_unpack(buf []byte) ?CMsgSteamDatagramNoSessionRelayToClient {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramnosessionrelaytoclient()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			7 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.your_public_ip = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.server_time = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.challenge = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seconds_until_shutdown = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramNoSessionRelayToClient) eq(b CMsgSteamDatagramNoSessionRelayToClient) bool {
	return true && a.connection_id == b.connection_id && a.your_public_ip == b.your_public_ip &&
		a.server_time == b.server_time && a.challenge == b.challenge && a.seconds_until_shutdown == b.seconds_until_shutdown
}

[inline]
pub fn (a CMsgSteamDatagramNoSessionRelayToClient) ne(b CMsgSteamDatagramNoSessionRelayToClient) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramNoSessionRelayToClient) eq(b []CMsgSteamDatagramNoSessionRelayToClient) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramNoSessionRelayToClient) ne(b []CMsgSteamDatagramNoSessionRelayToClient) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramnosessionrelaytoclient() CMsgSteamDatagramNoSessionRelayToClient {
	return CMsgSteamDatagramNoSessionRelayToClient{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramnosessionrelaytoclient(o CMsgSteamDatagramNoSessionRelayToClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramnosessionrelaytoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramNoSessionRelayToClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramnosessionrelaytoclient_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramNoSessionRelayToPeer {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	legacy_relay_session_id u32
	from_relay_session_id   u32
	from_connection_id      u32
	kludge_pad              u64
}

pub fn (o &CMsgSteamDatagramNoSessionRelayToPeer) pack() []byte {
	mut res := []byte{}
	if o.legacy_relay_session_id != u32(0) {
		res << vproto.pack_uint32_field(o.legacy_relay_session_id, 1)
	}
	if o.from_relay_session_id != u32(0) {
		res << vproto.pack_32bit_field(o.from_relay_session_id, 2)
	}
	if o.from_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.from_connection_id, 7)
	}
	if o.kludge_pad != u64(0) {
		res << vproto.pack_64bit_field(o.kludge_pad, 99)
	}
	return res
}

pub fn cmsgsteamdatagramnosessionrelaytopeer_unpack(buf []byte) ?CMsgSteamDatagramNoSessionRelayToPeer {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramnosessionrelaytopeer()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_relay_session_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_relay_session_id = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_connection_id = v
				i = ii
			}
			99 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.kludge_pad = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramNoSessionRelayToPeer) eq(b CMsgSteamDatagramNoSessionRelayToPeer) bool {
	return true && a.legacy_relay_session_id == b.legacy_relay_session_id && a.from_relay_session_id ==
		b.from_relay_session_id && a.from_connection_id == b.from_connection_id && a.kludge_pad == b.kludge_pad
}

[inline]
pub fn (a CMsgSteamDatagramNoSessionRelayToPeer) ne(b CMsgSteamDatagramNoSessionRelayToPeer) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramNoSessionRelayToPeer) eq(b []CMsgSteamDatagramNoSessionRelayToPeer) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramNoSessionRelayToPeer) ne(b []CMsgSteamDatagramNoSessionRelayToPeer) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramnosessionrelaytopeer() CMsgSteamDatagramNoSessionRelayToPeer {
	return CMsgSteamDatagramNoSessionRelayToPeer{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramnosessionrelaytopeer(o CMsgSteamDatagramNoSessionRelayToPeer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramnosessionrelaytopeer(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramNoSessionRelayToPeer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramnosessionrelaytopeer_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientPingSampleRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	connection_id  u32
}

pub fn (o &CMsgSteamDatagramClientPingSampleRequest) pack() []byte {
	mut res := []byte{}
	if o.connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	return res
}

pub fn cmsgsteamdatagramclientpingsamplerequest_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleRequest {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplerequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramClientPingSampleRequest) eq(b CMsgSteamDatagramClientPingSampleRequest) bool {
	return true && a.connection_id == b.connection_id
}

[inline]
pub fn (a CMsgSteamDatagramClientPingSampleRequest) ne(b CMsgSteamDatagramClientPingSampleRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramClientPingSampleRequest) eq(b []CMsgSteamDatagramClientPingSampleRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramClientPingSampleRequest) ne(b []CMsgSteamDatagramClientPingSampleRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplerequest() CMsgSteamDatagramClientPingSampleRequest {
	return CMsgSteamDatagramClientPingSampleRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplerequest(o CMsgSteamDatagramClientPingSampleRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramclientpingsamplerequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	id             u32
	front_ping_ms  u32
	e2e_ping_ms    u32
}

pub fn (o &CMsgSteamDatagramClientPingSampleReply_RoutingCluster) pack() []byte {
	mut res := []byte{}
	if o.id != u32(0) {
		res << vproto.pack_32bit_field(o.id, 1)
	}
	if o.front_ping_ms != u32(0) {
		res << vproto.pack_uint32_field(o.front_ping_ms, 2)
	}
	if o.e2e_ping_ms != u32(0) {
		res << vproto.pack_uint32_field(o.e2e_ping_ms, 3)
	}
	return res
}

pub fn cmsgsteamdatagramclientpingsamplereply_routingcluster_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereply_routingcluster()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.front_ping_ms = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.e2e_ping_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramClientPingSampleReply_RoutingCluster) eq(b CMsgSteamDatagramClientPingSampleReply_RoutingCluster) bool {
	return true && a.id == b.id && a.front_ping_ms == b.front_ping_ms && a.e2e_ping_ms == b.e2e_ping_ms
}

[inline]
pub fn (a CMsgSteamDatagramClientPingSampleReply_RoutingCluster) ne(b CMsgSteamDatagramClientPingSampleReply_RoutingCluster) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramClientPingSampleReply_RoutingCluster) eq(b []CMsgSteamDatagramClientPingSampleReply_RoutingCluster) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramClientPingSampleReply_RoutingCluster) ne(b []CMsgSteamDatagramClientPingSampleReply_RoutingCluster) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereply_routingcluster() CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
	return CMsgSteamDatagramClientPingSampleReply_RoutingCluster{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply_routingcluster(o CMsgSteamDatagramClientPingSampleReply_RoutingCluster, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply_routingcluster(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleReply_RoutingCluster) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramclientpingsamplereply_routingcluster_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientPingSampleReply_DataCenter {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	data_center_id u32
	via_relay_id   u32
	e2e_ping_ms    u32
}

pub fn (o &CMsgSteamDatagramClientPingSampleReply_DataCenter) pack() []byte {
	mut res := []byte{}
	if o.data_center_id != u32(0) {
		res << vproto.pack_32bit_field(o.data_center_id, 1)
	}
	if o.via_relay_id != u32(0) {
		res << vproto.pack_32bit_field(o.via_relay_id, 2)
	}
	if o.e2e_ping_ms != u32(0) {
		res << vproto.pack_uint32_field(o.e2e_ping_ms, 3)
	}
	return res
}

pub fn cmsgsteamdatagramclientpingsamplereply_datacenter_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleReply_DataCenter {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereply_datacenter()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.data_center_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.via_relay_id = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.e2e_ping_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramClientPingSampleReply_DataCenter) eq(b CMsgSteamDatagramClientPingSampleReply_DataCenter) bool {
	return true && a.data_center_id == b.data_center_id && a.via_relay_id == b.via_relay_id &&
		a.e2e_ping_ms == b.e2e_ping_ms
}

[inline]
pub fn (a CMsgSteamDatagramClientPingSampleReply_DataCenter) ne(b CMsgSteamDatagramClientPingSampleReply_DataCenter) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramClientPingSampleReply_DataCenter) eq(b []CMsgSteamDatagramClientPingSampleReply_DataCenter) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramClientPingSampleReply_DataCenter) ne(b []CMsgSteamDatagramClientPingSampleReply_DataCenter) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereply_datacenter() CMsgSteamDatagramClientPingSampleReply_DataCenter {
	return CMsgSteamDatagramClientPingSampleReply_DataCenter{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply_datacenter(o CMsgSteamDatagramClientPingSampleReply_DataCenter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply_datacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleReply_DataCenter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramclientpingsamplereply_datacenter_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientPingSampleReply {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	connection_id    u32
	routing_clusters []CMsgSteamDatagramClientPingSampleReply_RoutingCluster
	data_centers     []CMsgSteamDatagramClientPingSampleReply_DataCenter
}

pub fn (o &CMsgSteamDatagramClientPingSampleReply) pack() []byte {
	mut res := []byte{}
	if o.connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	// [packed=false]
	for _, x in o.routing_clusters {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply_routingcluster(x, 2)
	}
	// [packed=false]
	for _, x in o.data_centers {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply_datacenter(x, 3)
	}
	return res
}

pub fn cmsgsteamdatagramclientpingsamplereply_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleReply {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereply()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply_routingcluster(cur_buf,
					tag_wiretype.wire_type) ?
				res.routing_clusters << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply_datacenter(cur_buf,
					tag_wiretype.wire_type) ?
				res.data_centers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramClientPingSampleReply) eq(b CMsgSteamDatagramClientPingSampleReply) bool {
	return true && a.connection_id == b.connection_id && a.routing_clusters.eq(b.routing_clusters) &&
		a.data_centers.eq(b.data_centers)
}

[inline]
pub fn (a CMsgSteamDatagramClientPingSampleReply) ne(b CMsgSteamDatagramClientPingSampleReply) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramClientPingSampleReply) eq(b []CMsgSteamDatagramClientPingSampleReply) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramClientPingSampleReply) ne(b []CMsgSteamDatagramClientPingSampleReply) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereply() CMsgSteamDatagramClientPingSampleReply {
	return CMsgSteamDatagramClientPingSampleReply{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply(o CMsgSteamDatagramClientPingSampleReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramclientpingsamplereply_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	score              u32
	front_ping         u32
	back_ping          u32
	seconds_until_down u32
}

pub fn (o &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) pack() []byte {
	mut res := []byte{}
	if o.score != u32(0) {
		res << vproto.pack_uint32_field(o.score, 1)
	}
	if o.front_ping != u32(0) {
		res << vproto.pack_uint32_field(o.front_ping, 2)
	}
	if o.back_ping != u32(0) {
		res << vproto.pack_uint32_field(o.back_ping, 3)
	}
	if o.seconds_until_down != u32(0) {
		res << vproto.pack_uint32_field(o.seconds_until_down, 4)
	}
	return res
}

pub fn cmsgsteamdatagramclientswitchedprimary_routerquality_unpack(buf []byte) ?CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary_routerquality()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.score = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.front_ping = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.back_ping = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seconds_until_down = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) eq(b CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) bool {
	return true && a.score == b.score && a.front_ping == b.front_ping && a.back_ping == b.back_ping &&
		a.seconds_until_down == b.seconds_until_down
}

[inline]
pub fn (a CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) ne(b CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) eq(b []CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) ne(b []CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary_routerquality() CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
	return CMsgSteamDatagramClientSwitchedPrimary_RouterQuality{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary_routerquality(o CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary_routerquality(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramclientswitchedprimary_routerquality_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientSwitchedPrimary {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	connection_id            u32
	from_ip                  u32
	from_port                u32
	from_router_cluster      u32
	from_active_time         u32
	from_active_packets_recv u32
	from_dropped_reason      string
	gap_ms                   u32
	from_quality_now         CMsgSteamDatagramClientSwitchedPrimary_RouterQuality
	to_quality_now           CMsgSteamDatagramClientSwitchedPrimary_RouterQuality
	from_quality_then        CMsgSteamDatagramClientSwitchedPrimary_RouterQuality
	to_quality_then          CMsgSteamDatagramClientSwitchedPrimary_RouterQuality
}

pub fn (o &CMsgSteamDatagramClientSwitchedPrimary) pack() []byte {
	mut res := []byte{}
	if o.connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	if o.from_ip != u32(0) {
		res << vproto.pack_32bit_field(o.from_ip, 2)
	}
	if o.from_port != u32(0) {
		res << vproto.pack_uint32_field(o.from_port, 3)
	}
	if o.from_router_cluster != u32(0) {
		res << vproto.pack_32bit_field(o.from_router_cluster, 4)
	}
	if o.from_active_time != u32(0) {
		res << vproto.pack_uint32_field(o.from_active_time, 5)
	}
	if o.from_active_packets_recv != u32(0) {
		res << vproto.pack_uint32_field(o.from_active_packets_recv, 6)
	}
	if o.from_dropped_reason != '' {
		res << vproto.pack_string_field(o.from_dropped_reason, 7)
	}
	if o.gap_ms != u32(0) {
		res << vproto.pack_uint32_field(o.gap_ms, 8)
	}
	if o.from_quality_now.ne(zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary_routerquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary_routerquality(o.from_quality_now, 9)
	}
	if o.to_quality_now.ne(zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary_routerquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary_routerquality(o.to_quality_now, 10)
	}
	if o.from_quality_then.ne(zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary_routerquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary_routerquality(o.from_quality_then, 11)
	}
	if o.to_quality_then.ne(zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary_routerquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary_routerquality(o.to_quality_then, 12)
	}
	return res
}

pub fn cmsgsteamdatagramclientswitchedprimary_unpack(buf []byte) ?CMsgSteamDatagramClientSwitchedPrimary {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_ip = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_port = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_router_cluster = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_active_time = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_active_packets_recv = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_dropped_reason = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.gap_ms = v
				i = ii
			}
			9 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary_routerquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.from_quality_now = v
				i = ii
			}
			10 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary_routerquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.to_quality_now = v
				i = ii
			}
			11 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary_routerquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.from_quality_then = v
				i = ii
			}
			12 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary_routerquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.to_quality_then = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramClientSwitchedPrimary) eq(b CMsgSteamDatagramClientSwitchedPrimary) bool {
	return true && a.connection_id == b.connection_id && a.from_ip == b.from_ip && a.from_port ==
		b.from_port && a.from_router_cluster == b.from_router_cluster && a.from_active_time == b.from_active_time &&
		a.from_active_packets_recv == b.from_active_packets_recv && a.from_dropped_reason == b.from_dropped_reason &&
		a.gap_ms == b.gap_ms && a.from_quality_now.eq(b.from_quality_now) && a.to_quality_now.eq(b.to_quality_now) &&
		a.from_quality_then.eq(b.from_quality_then) && a.to_quality_then.eq(b.to_quality_then)
}

[inline]
pub fn (a CMsgSteamDatagramClientSwitchedPrimary) ne(b CMsgSteamDatagramClientSwitchedPrimary) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramClientSwitchedPrimary) eq(b []CMsgSteamDatagramClientSwitchedPrimary) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramClientSwitchedPrimary) ne(b []CMsgSteamDatagramClientSwitchedPrimary) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary() CMsgSteamDatagramClientSwitchedPrimary {
	return CMsgSteamDatagramClientSwitchedPrimary{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary(o CMsgSteamDatagramClientSwitchedPrimary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientSwitchedPrimary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramclientswitchedprimary_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramConnectRequest {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	connection_id               u32
	my_timestamp                u64
	ping_est_ms                 u32
	virtual_port                u32
	gameserver_relay_session_id u32
	crypt                       CMsgSteamDatagramSessionCryptInfoSigned
	cert                        CMsgSteamDatagramCertificateSigned
	routing_secret              u64
	legacy_client_steam_id      u64
}

pub fn (o &CMsgSteamDatagramConnectRequest) pack() []byte {
	mut res := []byte{}
	if o.connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	if o.my_timestamp != u64(0) {
		res << vproto.pack_64bit_field(o.my_timestamp, 4)
	}
	if o.ping_est_ms != u32(0) {
		res << vproto.pack_uint32_field(o.ping_est_ms, 5)
	}
	if o.virtual_port != u32(0) {
		res << vproto.pack_uint32_field(o.virtual_port, 9)
	}
	if o.gameserver_relay_session_id != u32(0) {
		res << vproto.pack_uint32_field(o.gameserver_relay_session_id, 2)
	}
	if o.crypt.ne(zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfosigned()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o.crypt, 6)
	}
	if o.cert.ne(zzz_vproto_internal_new_cmsgsteamdatagramcertificatesigned()) {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 7)
	}
	if o.routing_secret != u64(0) {
		res << vproto.pack_64bit_field(o.routing_secret, 10)
	}
	if o.legacy_client_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.legacy_client_steam_id, 3)
	}
	return res
}

pub fn cmsgsteamdatagramconnectrequest_unpack(buf []byte) ?CMsgSteamDatagramConnectRequest {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_id = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.my_timestamp = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ping_est_ms = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.virtual_port = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.gameserver_relay_session_id = v
				i = ii
			}
			6 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(cur_buf,
					tag_wiretype.wire_type) ?
				res.crypt = v
				i = ii
			}
			7 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type) ?
				res.cert = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.routing_secret = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_client_steam_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectRequest) eq(b CMsgSteamDatagramConnectRequest) bool {
	return true && a.connection_id == b.connection_id && a.my_timestamp == b.my_timestamp &&
		a.ping_est_ms == b.ping_est_ms && a.virtual_port == b.virtual_port && a.gameserver_relay_session_id ==
		b.gameserver_relay_session_id && a.crypt.eq(b.crypt) && a.cert.eq(b.cert) && a.routing_secret ==
		b.routing_secret && a.legacy_client_steam_id == b.legacy_client_steam_id
}

[inline]
pub fn (a CMsgSteamDatagramConnectRequest) ne(b CMsgSteamDatagramConnectRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectRequest) eq(b []CMsgSteamDatagramConnectRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectRequest) ne(b []CMsgSteamDatagramConnectRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectrequest() CMsgSteamDatagramConnectRequest {
	return CMsgSteamDatagramConnectRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectrequest(o CMsgSteamDatagramConnectRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectrequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramConnectOK {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	client_connection_id        u32
	server_connection_id        u32
	your_timestamp              u64
	delay_time_usec             u32
	gameserver_relay_session_id u32
	crypt                       CMsgSteamDatagramSessionCryptInfoSigned
	cert                        CMsgSteamDatagramCertificateSigned
}

pub fn (o &CMsgSteamDatagramConnectOK) pack() []byte {
	mut res := []byte{}
	if o.client_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.client_connection_id, 1)
	}
	if o.server_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.server_connection_id, 7)
	}
	if o.your_timestamp != u64(0) {
		res << vproto.pack_64bit_field(o.your_timestamp, 3)
	}
	if o.delay_time_usec != u32(0) {
		res << vproto.pack_uint32_field(o.delay_time_usec, 4)
	}
	if o.gameserver_relay_session_id != u32(0) {
		res << vproto.pack_uint32_field(o.gameserver_relay_session_id, 2)
	}
	if o.crypt.ne(zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfosigned()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o.crypt, 5)
	}
	if o.cert.ne(zzz_vproto_internal_new_cmsgsteamdatagramcertificatesigned()) {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 6)
	}
	return res
}

pub fn cmsgsteamdatagramconnectok_unpack(buf []byte) ?CMsgSteamDatagramConnectOK {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectok()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.client_connection_id = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.server_connection_id = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.your_timestamp = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.delay_time_usec = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.gameserver_relay_session_id = v
				i = ii
			}
			5 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(cur_buf,
					tag_wiretype.wire_type) ?
				res.crypt = v
				i = ii
			}
			6 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type) ?
				res.cert = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectOK) eq(b CMsgSteamDatagramConnectOK) bool {
	return true && a.client_connection_id == b.client_connection_id && a.server_connection_id ==
		b.server_connection_id && a.your_timestamp == b.your_timestamp && a.delay_time_usec == b.delay_time_usec &&
		a.gameserver_relay_session_id == b.gameserver_relay_session_id && a.crypt.eq(b.crypt) && a.cert.eq(b.cert)
}

[inline]
pub fn (a CMsgSteamDatagramConnectOK) ne(b CMsgSteamDatagramConnectOK) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectOK) eq(b []CMsgSteamDatagramConnectOK) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectOK) ne(b []CMsgSteamDatagramConnectOK) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectok() CMsgSteamDatagramConnectOK {
	return CMsgSteamDatagramConnectOK{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectok(o CMsgSteamDatagramConnectOK, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectok(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectOK) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectok_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PSDRRoutingSummary {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	initial_ping              u32
	initial_ping_front_local  u32
	initial_ping_front_remote u32
	initial_score             u32
	initial_pop_local         u32
	initial_pop_remote        u32
	negotiation_ms            u32
	selected_seconds          u32
}

pub fn (o &CMsgSteamNetworkingP2PSDRRoutingSummary) pack() []byte {
	mut res := []byte{}
	if o.initial_ping != u32(0) {
		res << vproto.pack_uint32_field(o.initial_ping, 1)
	}
	if o.initial_ping_front_local != u32(0) {
		res << vproto.pack_uint32_field(o.initial_ping_front_local, 2)
	}
	if o.initial_ping_front_remote != u32(0) {
		res << vproto.pack_uint32_field(o.initial_ping_front_remote, 3)
	}
	if o.initial_score != u32(0) {
		res << vproto.pack_uint32_field(o.initial_score, 4)
	}
	if o.initial_pop_local != u32(0) {
		res << vproto.pack_32bit_field(o.initial_pop_local, 5)
	}
	if o.initial_pop_remote != u32(0) {
		res << vproto.pack_32bit_field(o.initial_pop_remote, 6)
	}
	if o.negotiation_ms != u32(0) {
		res << vproto.pack_uint32_field(o.negotiation_ms, 7)
	}
	if o.selected_seconds != u32(0) {
		res << vproto.pack_uint32_field(o.selected_seconds, 8)
	}
	return res
}

pub fn cmsgsteamnetworkingp2psdrroutingsummary_unpack(buf []byte) ?CMsgSteamNetworkingP2PSDRRoutingSummary {
	mut res := zzz_vproto_internal_new_cmsgsteamnetworkingp2psdrroutingsummary()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.initial_ping = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.initial_ping_front_local = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.initial_ping_front_remote = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.initial_score = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.initial_pop_local = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.initial_pop_remote = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.negotiation_ms = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.selected_seconds = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamNetworkingP2PSDRRoutingSummary) eq(b CMsgSteamNetworkingP2PSDRRoutingSummary) bool {
	return true && a.initial_ping == b.initial_ping && a.initial_ping_front_local == b.initial_ping_front_local &&
		a.initial_ping_front_remote == b.initial_ping_front_remote && a.initial_score == b.initial_score &&
		a.initial_pop_local == b.initial_pop_local && a.initial_pop_remote == b.initial_pop_remote &&
		a.negotiation_ms == b.negotiation_ms && a.selected_seconds == b.selected_seconds
}

[inline]
pub fn (a CMsgSteamNetworkingP2PSDRRoutingSummary) ne(b CMsgSteamNetworkingP2PSDRRoutingSummary) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PSDRRoutingSummary) eq(b []CMsgSteamNetworkingP2PSDRRoutingSummary) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamNetworkingP2PSDRRoutingSummary) ne(b []CMsgSteamNetworkingP2PSDRRoutingSummary) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2psdrroutingsummary() CMsgSteamNetworkingP2PSDRRoutingSummary {
	return CMsgSteamNetworkingP2PSDRRoutingSummary{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2psdrroutingsummary(o CMsgSteamNetworkingP2PSDRRoutingSummary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2psdrroutingsummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PSDRRoutingSummary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamnetworkingp2psdrroutingsummary_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PRoutingSummary {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ice            CMsgSteamNetworkingICESessionSummary
	sdr            CMsgSteamNetworkingP2PSDRRoutingSummary
}

pub fn (o &CMsgSteamDatagramP2PRoutingSummary) pack() []byte {
	mut res := []byte{}
	if o.ice.ne(zzz_vproto_internal_new_cmsgsteamnetworkingicesessionsummary()) {
		res << zzz_vproto_internal_pack_cmsgsteamnetworkingicesessionsummary(o.ice, 2)
	}
	if o.sdr.ne(zzz_vproto_internal_new_cmsgsteamnetworkingp2psdrroutingsummary()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamnetworkingp2psdrroutingsummary(o.sdr, 3)
	}
	return res
}

pub fn cmsgsteamdatagramp2proutingsummary_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutingSummary {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramp2proutingsummary()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingicesessionsummary(cur_buf,
					tag_wiretype.wire_type) ?
				res.ice = v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingp2psdrroutingsummary(cur_buf,
					tag_wiretype.wire_type) ?
				res.sdr = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramP2PRoutingSummary) eq(b CMsgSteamDatagramP2PRoutingSummary) bool {
	return true && a.ice.eq(b.ice) && a.sdr.eq(b.sdr)
}

[inline]
pub fn (a CMsgSteamDatagramP2PRoutingSummary) ne(b CMsgSteamDatagramP2PRoutingSummary) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramP2PRoutingSummary) eq(b []CMsgSteamDatagramP2PRoutingSummary) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramP2PRoutingSummary) ne(b []CMsgSteamDatagramP2PRoutingSummary) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutingsummary() CMsgSteamDatagramP2PRoutingSummary {
	return CMsgSteamDatagramP2PRoutingSummary{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o CMsgSteamDatagramP2PRoutingSummary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutingSummary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramp2proutingsummary_unpack(v) ?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionClosed_ERelayMode {
	@none = 0
	endtoend = 1
	closedbypeer = 2
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionclosed_erelaymode() CMsgSteamDatagramConnectionClosed_ERelayMode {
	return .@none
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosed_erelaymode(e CMsgSteamDatagramConnectionClosed_ERelayMode, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosed_erelaymode_packed(e []CMsgSteamDatagramConnectionClosed_ERelayMode, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosed_erelaymode(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionClosed_ERelayMode) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, CMsgSteamDatagramConnectionClosed_ERelayMode(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosed_erelaymode_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionClosed_ERelayMode) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionClosed {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	to_connection_id                   u32
	from_connection_id                 u32
	from_identity_string               string
	legacy_from_identity_binary        CMsgSteamNetworkingIdentityLegacyBinary
	legacy_from_steam_id               u64
	legacy_gameserver_relay_session_id u32
	to_relay_session_id                u32
	from_relay_session_id              u32
	forward_target_relay_routing_token []byte
	forward_target_revision            u32
	relay_mode                         CMsgSteamDatagramConnectionClosed_ERelayMode = .@none
	debug                              string
	reason_code                        u32
	routing_secret                     u64
	not_primary_session                bool
	not_primary_transport              bool
	quality_relay                      CMsgSteamDatagramConnectionQuality
	quality_e2e                        CMsgSteamDatagramConnectionQuality
	p2p_routing_summary                CMsgSteamDatagramP2PRoutingSummary
}

pub fn (o &CMsgSteamDatagramConnectionClosed) pack() []byte {
	mut res := []byte{}
	if o.to_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.to_connection_id, 7)
	}
	if o.from_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.from_connection_id, 8)
	}
	if o.from_identity_string != '' {
		res << vproto.pack_string_field(o.from_identity_string, 15)
	}
	if o.legacy_from_identity_binary.ne(zzz_vproto_internal_new_cmsgsteamnetworkingidentitylegacybinary()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamnetworkingidentitylegacybinary(o.legacy_from_identity_binary, 13)
	}
	if o.legacy_from_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.legacy_from_steam_id, 3)
	}
	if o.legacy_gameserver_relay_session_id != u32(0) {
		res << vproto.pack_uint32_field(o.legacy_gameserver_relay_session_id, 2)
	}
	if o.to_relay_session_id != u32(0) {
		res << vproto.pack_32bit_field(o.to_relay_session_id, 9)
	}
	if o.from_relay_session_id != u32(0) {
		res << vproto.pack_32bit_field(o.from_relay_session_id, 10)
	}
	if o.forward_target_relay_routing_token != []byte{} {
		res << vproto.pack_bytes_field(o.forward_target_relay_routing_token, 11)
	}
	if o.forward_target_revision != u32(0) {
		res << vproto.pack_uint32_field(o.forward_target_revision, 12)
	}
	if o.relay_mode != zzz_vproto_internal_new_cmsgsteamdatagramconnectionclosed_erelaymode() {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosed_erelaymode(o.relay_mode, 4)
	}
	if o.debug != '' {
		res << vproto.pack_string_field(o.debug, 5)
	}
	if o.reason_code != u32(0) {
		res << vproto.pack_uint32_field(o.reason_code, 6)
	}
	if o.routing_secret != u64(0) {
		res << vproto.pack_64bit_field(o.routing_secret, 14)
	}
	if o.not_primary_session != false {
		res << vproto.pack_bool_field(o.not_primary_session, 16)
	}
	if o.not_primary_transport != false {
		res << vproto.pack_bool_field(o.not_primary_transport, 19)
	}
	if o.quality_relay.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 17)
	}
	if o.quality_e2e.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 18)
	}
	if o.p2p_routing_summary.ne(zzz_vproto_internal_new_cmsgsteamdatagramp2proutingsummary()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o.p2p_routing_summary, 21)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionclosed_unpack(buf []byte) ?CMsgSteamDatagramConnectionClosed {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectionclosed()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			7 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.to_connection_id = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_connection_id = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_identity_string = v
				i = ii
			}
			13 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingidentitylegacybinary(cur_buf,
					tag_wiretype.wire_type) ?
				res.legacy_from_identity_binary = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_from_steam_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_gameserver_relay_session_id = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.to_relay_session_id = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_relay_session_id = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.forward_target_relay_routing_token = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.forward_target_revision = v
				i = ii
			}
			4 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosed_erelaymode(cur_buf,
					tag_wiretype.wire_type) ?
				res.relay_mode = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.debug = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.reason_code = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.routing_secret = v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.not_primary_session = v
				i = ii
			}
			19 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.not_primary_transport = v
				i = ii
			}
			17 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_relay = v
				i = ii
			}
			18 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_e2e = v
				i = ii
			}
			21 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(cur_buf,
					tag_wiretype.wire_type) ?
				res.p2p_routing_summary = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectionClosed) eq(b CMsgSteamDatagramConnectionClosed) bool {
	return true && a.to_connection_id == b.to_connection_id && a.from_connection_id == b.from_connection_id &&
		a.from_identity_string == b.from_identity_string &&
		a.legacy_from_identity_binary.eq(b.legacy_from_identity_binary) && a.legacy_from_steam_id == b.legacy_from_steam_id &&
		a.legacy_gameserver_relay_session_id == b.legacy_gameserver_relay_session_id && a.to_relay_session_id ==
		b.to_relay_session_id && a.from_relay_session_id == b.from_relay_session_id && a.forward_target_relay_routing_token ==
		b.forward_target_relay_routing_token && a.forward_target_revision == b.forward_target_revision &&
		a.relay_mode == b.relay_mode && a.debug == b.debug && a.reason_code == b.reason_code &&
		a.routing_secret == b.routing_secret && a.not_primary_session == b.not_primary_session &&
		a.not_primary_transport == b.not_primary_transport && a.quality_relay.eq(b.quality_relay) && a.quality_e2e.eq(b.quality_e2e) &&
		a.p2p_routing_summary.eq(b.p2p_routing_summary)
}

[inline]
pub fn (a CMsgSteamDatagramConnectionClosed) ne(b CMsgSteamDatagramConnectionClosed) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionClosed) eq(b []CMsgSteamDatagramConnectionClosed) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionClosed) ne(b []CMsgSteamDatagramConnectionClosed) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionclosed() CMsgSteamDatagramConnectionClosed {
	return CMsgSteamDatagramConnectionClosed{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosed(o CMsgSteamDatagramConnectionClosed, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionClosed) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectionclosed_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramNoConnection {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	to_connection_id                   u32
	from_connection_id                 u32
	legacy_gameserver_relay_session_id u32
	to_relay_session_id                u32
	from_relay_session_id              u32
	from_identity_string               string
	legacy_from_steam_id               u64
	end_to_end                         bool
	not_primary_session                bool
	not_primary_transport              bool
	quality_relay                      CMsgSteamDatagramConnectionQuality
	quality_e2e                        CMsgSteamDatagramConnectionQuality
	p2p_routing_summary                CMsgSteamDatagramP2PRoutingSummary
	routing_secret                     u64
	dummy_pad                          u32
}

pub fn (o &CMsgSteamDatagramNoConnection) pack() []byte {
	mut res := []byte{}
	if o.to_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.to_connection_id, 5)
	}
	if o.from_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.from_connection_id, 6)
	}
	if o.legacy_gameserver_relay_session_id != u32(0) {
		res << vproto.pack_uint32_field(o.legacy_gameserver_relay_session_id, 2)
	}
	if o.to_relay_session_id != u32(0) {
		res << vproto.pack_32bit_field(o.to_relay_session_id, 9)
	}
	if o.from_relay_session_id != u32(0) {
		res << vproto.pack_32bit_field(o.from_relay_session_id, 10)
	}
	if o.from_identity_string != '' {
		res << vproto.pack_string_field(o.from_identity_string, 7)
	}
	if o.legacy_from_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.legacy_from_steam_id, 3)
	}
	if o.end_to_end != false {
		res << vproto.pack_bool_field(o.end_to_end, 4)
	}
	if o.not_primary_session != false {
		res << vproto.pack_bool_field(o.not_primary_session, 12)
	}
	if o.not_primary_transport != false {
		res << vproto.pack_bool_field(o.not_primary_transport, 15)
	}
	if o.quality_relay.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 13)
	}
	if o.quality_e2e.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 14)
	}
	if o.p2p_routing_summary.ne(zzz_vproto_internal_new_cmsgsteamdatagramp2proutingsummary()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o.p2p_routing_summary, 16)
	}
	if o.routing_secret != u64(0) {
		res << vproto.pack_64bit_field(o.routing_secret, 11)
	}
	if o.dummy_pad != u32(0) {
		res << vproto.pack_32bit_field(o.dummy_pad, 1023)
	}
	return res
}

pub fn cmsgsteamdatagramnoconnection_unpack(buf []byte) ?CMsgSteamDatagramNoConnection {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramnoconnection()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			5 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.to_connection_id = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_connection_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_gameserver_relay_session_id = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.to_relay_session_id = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_relay_session_id = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_identity_string = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_from_steam_id = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.end_to_end = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.not_primary_session = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.not_primary_transport = v
				i = ii
			}
			13 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_relay = v
				i = ii
			}
			14 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_e2e = v
				i = ii
			}
			16 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(cur_buf,
					tag_wiretype.wire_type) ?
				res.p2p_routing_summary = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.routing_secret = v
				i = ii
			}
			1023 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.dummy_pad = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramNoConnection) eq(b CMsgSteamDatagramNoConnection) bool {
	return true && a.to_connection_id == b.to_connection_id && a.from_connection_id == b.from_connection_id &&
		a.legacy_gameserver_relay_session_id == b.legacy_gameserver_relay_session_id && a.to_relay_session_id ==
		b.to_relay_session_id && a.from_relay_session_id == b.from_relay_session_id && a.from_identity_string ==
		b.from_identity_string && a.legacy_from_steam_id == b.legacy_from_steam_id && a.end_to_end ==
		b.end_to_end && a.not_primary_session == b.not_primary_session && a.not_primary_transport == b.not_primary_transport &&
		a.quality_relay.eq(b.quality_relay) && a.quality_e2e.eq(b.quality_e2e) && a.p2p_routing_summary.eq(b.p2p_routing_summary) &&
		a.routing_secret == b.routing_secret && a.dummy_pad == b.dummy_pad
}

[inline]
pub fn (a CMsgSteamDatagramNoConnection) ne(b CMsgSteamDatagramNoConnection) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramNoConnection) eq(b []CMsgSteamDatagramNoConnection) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramNoConnection) ne(b []CMsgSteamDatagramNoConnection) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramnoconnection() CMsgSteamDatagramNoConnection {
	return CMsgSteamDatagramNoConnection{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramnoconnection(o CMsgSteamDatagramNoConnection, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramnoconnection(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramNoConnection) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramnoconnection_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameserverSessionRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	ticket                 []byte
	challenge_time         u32
	challenge              u64
	client_connection_id   u32
	server_connection_id   u32
	network_config_version u32
	protocol_version       u32
}

pub fn (o &CMsgSteamDatagramGameserverSessionRequest) pack() []byte {
	mut res := []byte{}
	if o.ticket != []byte{} {
		res << vproto.pack_bytes_field(o.ticket, 1)
	}
	if o.challenge_time != u32(0) {
		res << vproto.pack_32bit_field(o.challenge_time, 3)
	}
	if o.challenge != u64(0) {
		res << vproto.pack_64bit_field(o.challenge, 4)
	}
	if o.client_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.client_connection_id, 5)
	}
	if o.server_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.server_connection_id, 8)
	}
	if o.network_config_version != u32(0) {
		res << vproto.pack_uint32_field(o.network_config_version, 6)
	}
	if o.protocol_version != u32(0) {
		res << vproto.pack_uint32_field(o.protocol_version, 7)
	}
	return res
}

pub fn cmsgsteamdatagramgameserversessionrequest_unpack(buf []byte) ?CMsgSteamDatagramGameserverSessionRequest {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramgameserversessionrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.ticket = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.challenge_time = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.challenge = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.client_connection_id = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.server_connection_id = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.network_config_version = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.protocol_version = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramGameserverSessionRequest) eq(b CMsgSteamDatagramGameserverSessionRequest) bool {
	return true && a.ticket == b.ticket && a.challenge_time == b.challenge_time && a.challenge ==
		b.challenge && a.client_connection_id == b.client_connection_id && a.server_connection_id == b.server_connection_id &&
		a.network_config_version == b.network_config_version && a.protocol_version == b.protocol_version
}

[inline]
pub fn (a CMsgSteamDatagramGameserverSessionRequest) ne(b CMsgSteamDatagramGameserverSessionRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramGameserverSessionRequest) eq(b []CMsgSteamDatagramGameserverSessionRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramGameserverSessionRequest) ne(b []CMsgSteamDatagramGameserverSessionRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversessionrequest() CMsgSteamDatagramGameserverSessionRequest {
	return CMsgSteamDatagramGameserverSessionRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversessionrequest(o CMsgSteamDatagramGameserverSessionRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverSessionRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramgameserversessionrequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameserverSessionEstablished {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	connection_id                u32
	gameserver_identity_string   string
	seconds_until_shutdown       u32
	seq_num_r2c                  u32
	dummy_legacy_identity_binary []byte
	legacy_gameserver_steamid    u64
}

pub fn (o &CMsgSteamDatagramGameserverSessionEstablished) pack() []byte {
	mut res := []byte{}
	if o.connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	if o.gameserver_identity_string != '' {
		res << vproto.pack_string_field(o.gameserver_identity_string, 2)
	}
	if o.seconds_until_shutdown != u32(0) {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 4)
	}
	if o.seq_num_r2c != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_r2c, 6)
	}
	if o.dummy_legacy_identity_binary != []byte{} {
		res << vproto.pack_bytes_field(o.dummy_legacy_identity_binary, 7)
	}
	if o.legacy_gameserver_steamid != u64(0) {
		res << vproto.pack_64bit_field(o.legacy_gameserver_steamid, 3)
	}
	return res
}

pub fn cmsgsteamdatagramgameserversessionestablished_unpack(buf []byte) ?CMsgSteamDatagramGameserverSessionEstablished {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramgameserversessionestablished()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.gameserver_identity_string = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seconds_until_shutdown = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_r2c = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.dummy_legacy_identity_binary = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_gameserver_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramGameserverSessionEstablished) eq(b CMsgSteamDatagramGameserverSessionEstablished) bool {
	return true && a.connection_id == b.connection_id && a.gameserver_identity_string == b.gameserver_identity_string &&
		a.seconds_until_shutdown == b.seconds_until_shutdown && a.seq_num_r2c == b.seq_num_r2c &&
		a.dummy_legacy_identity_binary == b.dummy_legacy_identity_binary && a.legacy_gameserver_steamid ==
		b.legacy_gameserver_steamid
}

[inline]
pub fn (a CMsgSteamDatagramGameserverSessionEstablished) ne(b CMsgSteamDatagramGameserverSessionEstablished) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramGameserverSessionEstablished) eq(b []CMsgSteamDatagramGameserverSessionEstablished) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramGameserverSessionEstablished) ne(b []CMsgSteamDatagramGameserverSessionEstablished) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversessionestablished() CMsgSteamDatagramGameserverSessionEstablished {
	return CMsgSteamDatagramGameserverSessionEstablished{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversessionestablished(o CMsgSteamDatagramGameserverSessionEstablished, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversessionestablished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverSessionEstablished) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramgameserversessionestablished_unpack(v) ?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
	not_primary_session = 8
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsclienttorouter_flags() CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
	return .ack_request_relay
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsclienttorouter_flags(e CMsgSteamDatagramConnectionStatsClientToRouter_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsclienttorouter_flags_packed(e []CMsgSteamDatagramConnectionStatsClientToRouter_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsclienttorouter_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsClientToRouter_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, CMsgSteamDatagramConnectionStatsClientToRouter_Flags(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsclienttorouter_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsClientToRouter_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsClientToRouter {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	quality_relay        CMsgSteamDatagramConnectionQuality
	quality_e2e          CMsgSteamDatagramConnectionQuality
	ack_relay            []u32
	legacy_ack_e2e       []u32
	flags                u32
	client_connection_id u32
	seq_num_c2r          u32
	seq_num_e2e          u32
}

pub fn (o &CMsgSteamDatagramConnectionStatsClientToRouter) pack() []byte {
	mut res := []byte{}
	if o.quality_relay.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.quality_e2e.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 4)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 5)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 6)
	}
	if o.client_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.client_connection_id, 8)
	}
	if o.seq_num_c2r != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_c2r, 9)
	}
	if o.seq_num_e2e != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 10)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsclienttorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsClientToRouter {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsclienttorouter()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_relay = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_e2e = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_relay << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_ack_e2e << v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.flags = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.client_connection_id = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_c2r = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_e2e = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsClientToRouter) eq(b CMsgSteamDatagramConnectionStatsClientToRouter) bool {
	return true && a.quality_relay.eq(b.quality_relay) && a.quality_e2e.eq(b.quality_e2e) &&
		a.ack_relay == b.ack_relay && a.legacy_ack_e2e == b.legacy_ack_e2e && a.flags == b.flags &&
		a.client_connection_id == b.client_connection_id && a.seq_num_c2r == b.seq_num_c2r &&
		a.seq_num_e2e == b.seq_num_e2e
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsClientToRouter) ne(b CMsgSteamDatagramConnectionStatsClientToRouter) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsClientToRouter) eq(b []CMsgSteamDatagramConnectionStatsClientToRouter) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsClientToRouter) ne(b []CMsgSteamDatagramConnectionStatsClientToRouter) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsclienttorouter() CMsgSteamDatagramConnectionStatsClientToRouter {
	return CMsgSteamDatagramConnectionStatsClientToRouter{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsclienttorouter(o CMsgSteamDatagramConnectionStatsClientToRouter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsclienttorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsClientToRouter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectionstatsclienttorouter_unpack(v) ?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsroutertoclient_flags() CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
	return .ack_request_relay
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoclient_flags(e CMsgSteamDatagramConnectionStatsRouterToClient_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoclient_flags_packed(e []CMsgSteamDatagramConnectionStatsRouterToClient_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoclient_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToClient_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, CMsgSteamDatagramConnectionStatsRouterToClient_Flags(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoclient_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsRouterToClient_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsRouterToClient {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	quality_relay                 CMsgSteamDatagramConnectionQuality
	quality_e2e                   CMsgSteamDatagramConnectionQuality
	seconds_until_shutdown        u32
	migrate_request_ip            u32
	migrate_request_port          u32
	scoring_penalty_relay_cluster u32
	ack_relay                     []u32
	legacy_ack_e2e                []u32
	flags                         u32
	client_connection_id          u32
	seq_num_r2c                   u32
	seq_num_e2e                   u32
}

pub fn (o &CMsgSteamDatagramConnectionStatsRouterToClient) pack() []byte {
	mut res := []byte{}
	if o.quality_relay.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.quality_e2e.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	if o.seconds_until_shutdown != u32(0) {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 6)
	}
	if o.migrate_request_ip != u32(0) {
		res << vproto.pack_32bit_field(o.migrate_request_ip, 10)
	}
	if o.migrate_request_port != u32(0) {
		res << vproto.pack_uint32_field(o.migrate_request_port, 11)
	}
	if o.scoring_penalty_relay_cluster != u32(0) {
		res << vproto.pack_uint32_field(o.scoring_penalty_relay_cluster, 12)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 13)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 14)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 15)
	}
	if o.client_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.client_connection_id, 7)
	}
	if o.seq_num_r2c != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_r2c, 8)
	}
	if o.seq_num_e2e != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 9)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsroutertoclient_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsRouterToClient {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsroutertoclient()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_relay = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_e2e = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seconds_until_shutdown = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.migrate_request_ip = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.migrate_request_port = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.scoring_penalty_relay_cluster = v
				i = ii
			}
			13 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_relay << v
				i = ii
			}
			14 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_ack_e2e << v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.flags = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.client_connection_id = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_r2c = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_e2e = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsRouterToClient) eq(b CMsgSteamDatagramConnectionStatsRouterToClient) bool {
	return true && a.quality_relay.eq(b.quality_relay) && a.quality_e2e.eq(b.quality_e2e) &&
		a.seconds_until_shutdown == b.seconds_until_shutdown && a.migrate_request_ip == b.migrate_request_ip &&
		a.migrate_request_port == b.migrate_request_port && a.scoring_penalty_relay_cluster == b.scoring_penalty_relay_cluster &&
		a.ack_relay == b.ack_relay && a.legacy_ack_e2e == b.legacy_ack_e2e && a.flags == b.flags &&
		a.client_connection_id == b.client_connection_id && a.seq_num_r2c == b.seq_num_r2c &&
		a.seq_num_e2e == b.seq_num_e2e
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsRouterToClient) ne(b CMsgSteamDatagramConnectionStatsRouterToClient) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsRouterToClient) eq(b []CMsgSteamDatagramConnectionStatsRouterToClient) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsRouterToClient) ne(b []CMsgSteamDatagramConnectionStatsRouterToClient) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsroutertoclient() CMsgSteamDatagramConnectionStatsRouterToClient {
	return CMsgSteamDatagramConnectionStatsRouterToClient{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoclient(o CMsgSteamDatagramConnectionStatsRouterToClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectionstatsroutertoclient_unpack(v) ?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsroutertoserver_flags() CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
	return .ack_request_relay
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoserver_flags(e CMsgSteamDatagramConnectionStatsRouterToServer_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoserver_flags_packed(e []CMsgSteamDatagramConnectionStatsRouterToServer_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoserver_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToServer_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, CMsgSteamDatagramConnectionStatsRouterToServer_Flags(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoserver_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsRouterToServer_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsRouterToServer {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	quality_relay          CMsgSteamDatagramConnectionQuality
	quality_e2e            CMsgSteamDatagramConnectionQuality
	ack_relay              []u32
	legacy_ack_e2e         []u32
	flags                  u32
	seq_num_r2s            u32
	seq_num_e2e            u32
	client_identity_string string
	legacy_client_steam_id u64
	relay_session_id       u32
	client_connection_id   u32
	server_connection_id   u32
	routing_secret         u64
}

pub fn (o &CMsgSteamDatagramConnectionStatsRouterToServer) pack() []byte {
	mut res := []byte{}
	if o.quality_relay.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.quality_e2e.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 10)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 11)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 12)
	}
	if o.seq_num_r2s != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_r2s, 5)
	}
	if o.seq_num_e2e != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 6)
	}
	if o.client_identity_string != '' {
		res << vproto.pack_string_field(o.client_identity_string, 15)
	}
	if o.legacy_client_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.legacy_client_steam_id, 7)
	}
	if o.relay_session_id != u32(0) {
		res << vproto.pack_uint32_field(o.relay_session_id, 8)
	}
	if o.client_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.client_connection_id, 9)
	}
	if o.server_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.server_connection_id, 13)
	}
	if o.routing_secret != u64(0) {
		res << vproto.pack_64bit_field(o.routing_secret, 14)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsroutertoserver_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsRouterToServer {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsroutertoserver()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_relay = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_e2e = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_relay << v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_ack_e2e << v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.flags = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_r2s = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_e2e = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.client_identity_string = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_client_steam_id = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.relay_session_id = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.client_connection_id = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.server_connection_id = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.routing_secret = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsRouterToServer) eq(b CMsgSteamDatagramConnectionStatsRouterToServer) bool {
	return true && a.quality_relay.eq(b.quality_relay) && a.quality_e2e.eq(b.quality_e2e) &&
		a.ack_relay == b.ack_relay && a.legacy_ack_e2e == b.legacy_ack_e2e && a.flags == b.flags &&
		a.seq_num_r2s == b.seq_num_r2s && a.seq_num_e2e == b.seq_num_e2e && a.client_identity_string ==
		b.client_identity_string && a.legacy_client_steam_id == b.legacy_client_steam_id && a.relay_session_id ==
		b.relay_session_id && a.client_connection_id == b.client_connection_id && a.server_connection_id ==
		b.server_connection_id && a.routing_secret == b.routing_secret
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsRouterToServer) ne(b CMsgSteamDatagramConnectionStatsRouterToServer) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsRouterToServer) eq(b []CMsgSteamDatagramConnectionStatsRouterToServer) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsRouterToServer) ne(b []CMsgSteamDatagramConnectionStatsRouterToServer) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsroutertoserver() CMsgSteamDatagramConnectionStatsRouterToServer {
	return CMsgSteamDatagramConnectionStatsRouterToServer{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoserver(o CMsgSteamDatagramConnectionStatsRouterToServer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToServer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectionstatsroutertoserver_unpack(v) ?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsservertorouter_flags() CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
	return .ack_request_relay
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsservertorouter_flags(e CMsgSteamDatagramConnectionStatsServerToRouter_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsservertorouter_flags_packed(e []CMsgSteamDatagramConnectionStatsServerToRouter_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsservertorouter_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsServerToRouter_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, CMsgSteamDatagramConnectionStatsServerToRouter_Flags(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsservertorouter_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsServerToRouter_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsServerToRouter {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	quality_relay        CMsgSteamDatagramConnectionQuality
	quality_e2e          CMsgSteamDatagramConnectionQuality
	ack_relay            []u32
	legacy_ack_e2e       []u32
	flags                u32
	seq_num_s2r          u32
	seq_num_e2e          u32
	relay_session_id     u32
	client_connection_id u32
	server_connection_id u32
}

pub fn (o &CMsgSteamDatagramConnectionStatsServerToRouter) pack() []byte {
	mut res := []byte{}
	if o.quality_relay.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.quality_e2e.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 8)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 9)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 10)
	}
	if o.seq_num_s2r != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_s2r, 3)
	}
	if o.seq_num_e2e != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 4)
	}
	if o.relay_session_id != u32(0) {
		res << vproto.pack_uint32_field(o.relay_session_id, 6)
	}
	if o.client_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.client_connection_id, 7)
	}
	if o.server_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.server_connection_id, 11)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsservertorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsServerToRouter {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsservertorouter()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_relay = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_e2e = v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_relay << v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_ack_e2e << v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.flags = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_s2r = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_e2e = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.relay_session_id = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.client_connection_id = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.server_connection_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsServerToRouter) eq(b CMsgSteamDatagramConnectionStatsServerToRouter) bool {
	return true && a.quality_relay.eq(b.quality_relay) && a.quality_e2e.eq(b.quality_e2e) &&
		a.ack_relay == b.ack_relay && a.legacy_ack_e2e == b.legacy_ack_e2e && a.flags == b.flags &&
		a.seq_num_s2r == b.seq_num_s2r && a.seq_num_e2e == b.seq_num_e2e && a.relay_session_id == b.relay_session_id &&
		a.client_connection_id == b.client_connection_id && a.server_connection_id == b.server_connection_id
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsServerToRouter) ne(b CMsgSteamDatagramConnectionStatsServerToRouter) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsServerToRouter) eq(b []CMsgSteamDatagramConnectionStatsServerToRouter) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsServerToRouter) ne(b []CMsgSteamDatagramConnectionStatsServerToRouter) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsservertorouter() CMsgSteamDatagramConnectionStatsServerToRouter {
	return CMsgSteamDatagramConnectionStatsServerToRouter{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsservertorouter(o CMsgSteamDatagramConnectionStatsServerToRouter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsservertorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsServerToRouter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectionstatsservertorouter_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PSessionRequestBody {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	challenge_time         u32
	challenge              u64
	client_connection_id   u32
	legacy_peer_steam_id   u64
	peer_identity_string   string
	peer_connection_id     u32
	protocol_version       u32
	network_config_version u32
	public_ip              u32
}

pub fn (o &CMsgSteamDatagramP2PSessionRequestBody) pack() []byte {
	mut res := []byte{}
	if o.challenge_time != u32(0) {
		res << vproto.pack_32bit_field(o.challenge_time, 1)
	}
	if o.challenge != u64(0) {
		res << vproto.pack_64bit_field(o.challenge, 2)
	}
	if o.client_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.client_connection_id, 3)
	}
	if o.legacy_peer_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.legacy_peer_steam_id, 4)
	}
	if o.peer_identity_string != '' {
		res << vproto.pack_string_field(o.peer_identity_string, 11)
	}
	if o.peer_connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.peer_connection_id, 5)
	}
	if o.protocol_version != u32(0) {
		res << vproto.pack_uint32_field(o.protocol_version, 8)
	}
	if o.network_config_version != u32(0) {
		res << vproto.pack_uint32_field(o.network_config_version, 9)
	}
	if o.public_ip != u32(0) {
		res << vproto.pack_32bit_field(o.public_ip, 10)
	}
	return res
}

pub fn cmsgsteamdatagramp2psessionrequestbody_unpack(buf []byte) ?CMsgSteamDatagramP2PSessionRequestBody {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramp2psessionrequestbody()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.challenge_time = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.challenge = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.client_connection_id = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_peer_steam_id = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.peer_identity_string = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.peer_connection_id = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.protocol_version = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.network_config_version = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.public_ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramP2PSessionRequestBody) eq(b CMsgSteamDatagramP2PSessionRequestBody) bool {
	return true && a.challenge_time == b.challenge_time && a.challenge == b.challenge &&
		a.client_connection_id == b.client_connection_id && a.legacy_peer_steam_id == b.legacy_peer_steam_id &&
		a.peer_identity_string == b.peer_identity_string && a.peer_connection_id == b.peer_connection_id &&
		a.protocol_version == b.protocol_version && a.network_config_version == b.network_config_version &&
		a.public_ip == b.public_ip
}

[inline]
pub fn (a CMsgSteamDatagramP2PSessionRequestBody) ne(b CMsgSteamDatagramP2PSessionRequestBody) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramP2PSessionRequestBody) eq(b []CMsgSteamDatagramP2PSessionRequestBody) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramP2PSessionRequestBody) ne(b []CMsgSteamDatagramP2PSessionRequestBody) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2psessionrequestbody() CMsgSteamDatagramP2PSessionRequestBody {
	return CMsgSteamDatagramP2PSessionRequestBody{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2psessionrequestbody(o CMsgSteamDatagramP2PSessionRequestBody, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2psessionrequestbody(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PSessionRequestBody) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramp2psessionrequestbody_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PSessionRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cert           CMsgSteamDatagramCertificateSigned
	body           []byte
	signature      []byte
}

pub fn (o &CMsgSteamDatagramP2PSessionRequest) pack() []byte {
	mut res := []byte{}
	if o.cert.ne(zzz_vproto_internal_new_cmsgsteamdatagramcertificatesigned()) {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 1)
	}
	if o.body != []byte{} {
		res << vproto.pack_bytes_field(o.body, 2)
	}
	if o.signature != []byte{} {
		res << vproto.pack_bytes_field(o.signature, 3)
	}
	return res
}

pub fn cmsgsteamdatagramp2psessionrequest_unpack(buf []byte) ?CMsgSteamDatagramP2PSessionRequest {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramp2psessionrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type) ?
				res.cert = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.body = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.signature = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramP2PSessionRequest) eq(b CMsgSteamDatagramP2PSessionRequest) bool {
	return true && a.cert.eq(b.cert) && a.body == b.body && a.signature == b.signature
}

[inline]
pub fn (a CMsgSteamDatagramP2PSessionRequest) ne(b CMsgSteamDatagramP2PSessionRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramP2PSessionRequest) eq(b []CMsgSteamDatagramP2PSessionRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramP2PSessionRequest) ne(b []CMsgSteamDatagramP2PSessionRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2psessionrequest() CMsgSteamDatagramP2PSessionRequest {
	return CMsgSteamDatagramP2PSessionRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2psessionrequest(o CMsgSteamDatagramP2PSessionRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2psessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PSessionRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramp2psessionrequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PSessionEstablished {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	connection_id          u32
	seconds_until_shutdown u32
	relay_routing_token    []byte
	seq_num_r2c            u32
}

pub fn (o &CMsgSteamDatagramP2PSessionEstablished) pack() []byte {
	mut res := []byte{}
	if o.connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	if o.seconds_until_shutdown != u32(0) {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 3)
	}
	if o.relay_routing_token != []byte{} {
		res << vproto.pack_bytes_field(o.relay_routing_token, 4)
	}
	if o.seq_num_r2c != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_r2c, 5)
	}
	return res
}

pub fn cmsgsteamdatagramp2psessionestablished_unpack(buf []byte) ?CMsgSteamDatagramP2PSessionEstablished {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramp2psessionestablished()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_id = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seconds_until_shutdown = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.relay_routing_token = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_r2c = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramP2PSessionEstablished) eq(b CMsgSteamDatagramP2PSessionEstablished) bool {
	return true && a.connection_id == b.connection_id && a.seconds_until_shutdown == b.seconds_until_shutdown &&
		a.relay_routing_token == b.relay_routing_token && a.seq_num_r2c == b.seq_num_r2c
}

[inline]
pub fn (a CMsgSteamDatagramP2PSessionEstablished) ne(b CMsgSteamDatagramP2PSessionEstablished) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramP2PSessionEstablished) eq(b []CMsgSteamDatagramP2PSessionEstablished) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramP2PSessionEstablished) ne(b []CMsgSteamDatagramP2PSessionEstablished) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2psessionestablished() CMsgSteamDatagramP2PSessionEstablished {
	return CMsgSteamDatagramP2PSessionEstablished{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2psessionestablished(o CMsgSteamDatagramP2PSessionEstablished, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2psessionestablished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PSessionEstablished) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramp2psessionestablished_unpack(v) ?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
	not_primary_session = 8
	not_primary_transport_e2e = 16
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2pclienttorouter_flags() CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
	return .ack_request_relay
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2pclienttorouter_flags(e CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2pclienttorouter_flags_packed(e []CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2pclienttorouter_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2pclienttorouter_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsP2PClientToRouter {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	quality_relay                      CMsgSteamDatagramConnectionQuality
	quality_e2e                        CMsgSteamDatagramConnectionQuality
	p2p_routing_summary                CMsgSteamDatagramP2PRoutingSummary
	ack_relay                          []u32
	legacy_ack_e2e                     []u32
	flags                              u32
	forward_target_relay_routing_token []byte
	forward_target_revision            u32
	routes                             []byte
	ack_peer_routes_revision           u32
	connection_id                      u32
	seq_num_c2r                        u32
	seq_num_e2e                        u32
}

pub fn (o &CMsgSteamDatagramConnectionStatsP2PClientToRouter) pack() []byte {
	mut res := []byte{}
	if o.quality_relay.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.quality_e2e.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	if o.p2p_routing_summary.ne(zzz_vproto_internal_new_cmsgsteamdatagramp2proutingsummary()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o.p2p_routing_summary, 14)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 3)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 4)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 5)
	}
	if o.forward_target_relay_routing_token != []byte{} {
		res << vproto.pack_bytes_field(o.forward_target_relay_routing_token, 6)
	}
	if o.forward_target_revision != u32(0) {
		res << vproto.pack_uint32_field(o.forward_target_revision, 7)
	}
	if o.routes != []byte{} {
		res << vproto.pack_bytes_field(o.routes, 8)
	}
	if o.ack_peer_routes_revision != u32(0) {
		res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 9)
	}
	if o.connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.connection_id, 10)
	}
	if o.seq_num_c2r != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_c2r, 11)
	}
	if o.seq_num_e2e != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 12)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsp2pclienttorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsP2PClientToRouter {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2pclienttorouter()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_relay = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_e2e = v
				i = ii
			}
			14 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(cur_buf,
					tag_wiretype.wire_type) ?
				res.p2p_routing_summary = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_relay << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_ack_e2e << v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.flags = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.forward_target_relay_routing_token = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.forward_target_revision = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.routes = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_peer_routes_revision = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_id = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_c2r = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_e2e = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsP2PClientToRouter) eq(b CMsgSteamDatagramConnectionStatsP2PClientToRouter) bool {
	return true && a.quality_relay.eq(b.quality_relay) && a.quality_e2e.eq(b.quality_e2e) && a.p2p_routing_summary.eq(b.p2p_routing_summary) &&
		a.ack_relay == b.ack_relay && a.legacy_ack_e2e == b.legacy_ack_e2e && a.flags == b.flags &&
		a.forward_target_relay_routing_token == b.forward_target_relay_routing_token && a.forward_target_revision ==
		b.forward_target_revision && a.routes == b.routes && a.ack_peer_routes_revision == b.ack_peer_routes_revision &&
		a.connection_id == b.connection_id && a.seq_num_c2r == b.seq_num_c2r && a.seq_num_e2e == b.seq_num_e2e
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsP2PClientToRouter) ne(b CMsgSteamDatagramConnectionStatsP2PClientToRouter) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsP2PClientToRouter) eq(b []CMsgSteamDatagramConnectionStatsP2PClientToRouter) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsP2PClientToRouter) ne(b []CMsgSteamDatagramConnectionStatsP2PClientToRouter) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2pclienttorouter() CMsgSteamDatagramConnectionStatsP2PClientToRouter {
	return CMsgSteamDatagramConnectionStatsP2PClientToRouter{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2pclienttorouter(o CMsgSteamDatagramConnectionStatsP2PClientToRouter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2pclienttorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PClientToRouter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectionstatsp2pclienttorouter_unpack(v) ?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
	not_primary_transport_e2e = 16
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2proutertoclient_flags() CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
	return .ack_request_relay
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertoclient_flags(e CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertoclient_flags_packed(e []CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertoclient_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertoclient_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsP2PRouterToClient {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	quality_relay                 CMsgSteamDatagramConnectionQuality
	quality_e2e                   CMsgSteamDatagramConnectionQuality
	seconds_until_shutdown        u32
	migrate_request_ip            u32
	migrate_request_port          u32
	scoring_penalty_relay_cluster u32
	ack_relay                     []u32
	legacy_ack_e2e                []u32
	flags                         u32
	ack_forward_target_revision   u32
	routes                        []byte
	ack_peer_routes_revision      u32
	connection_id                 u32
	seq_num_r2c                   u32
	seq_num_e2e                   u32
}

pub fn (o &CMsgSteamDatagramConnectionStatsP2PRouterToClient) pack() []byte {
	mut res := []byte{}
	if o.quality_relay.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.quality_e2e.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	if o.seconds_until_shutdown != u32(0) {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 3)
	}
	if o.migrate_request_ip != u32(0) {
		res << vproto.pack_32bit_field(o.migrate_request_ip, 4)
	}
	if o.migrate_request_port != u32(0) {
		res << vproto.pack_uint32_field(o.migrate_request_port, 5)
	}
	if o.scoring_penalty_relay_cluster != u32(0) {
		res << vproto.pack_uint32_field(o.scoring_penalty_relay_cluster, 6)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 7)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 8)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 9)
	}
	if o.ack_forward_target_revision != u32(0) {
		res << vproto.pack_uint32_field(o.ack_forward_target_revision, 10)
	}
	if o.routes != []byte{} {
		res << vproto.pack_bytes_field(o.routes, 11)
	}
	if o.ack_peer_routes_revision != u32(0) {
		res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 12)
	}
	if o.connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.connection_id, 13)
	}
	if o.seq_num_r2c != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_r2c, 14)
	}
	if o.seq_num_e2e != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 15)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsp2proutertoclient_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsP2PRouterToClient {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2proutertoclient()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_relay = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_e2e = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seconds_until_shutdown = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.migrate_request_ip = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.migrate_request_port = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.scoring_penalty_relay_cluster = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_relay << v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_ack_e2e << v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.flags = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_forward_target_revision = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.routes = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_peer_routes_revision = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_id = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_r2c = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_e2e = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsP2PRouterToClient) eq(b CMsgSteamDatagramConnectionStatsP2PRouterToClient) bool {
	return true && a.quality_relay.eq(b.quality_relay) && a.quality_e2e.eq(b.quality_e2e) &&
		a.seconds_until_shutdown == b.seconds_until_shutdown && a.migrate_request_ip == b.migrate_request_ip &&
		a.migrate_request_port == b.migrate_request_port && a.scoring_penalty_relay_cluster == b.scoring_penalty_relay_cluster &&
		a.ack_relay == b.ack_relay && a.legacy_ack_e2e == b.legacy_ack_e2e && a.flags == b.flags &&
		a.ack_forward_target_revision == b.ack_forward_target_revision && a.routes == b.routes &&
		a.ack_peer_routes_revision == b.ack_peer_routes_revision && a.connection_id == b.connection_id &&
		a.seq_num_r2c == b.seq_num_r2c && a.seq_num_e2e == b.seq_num_e2e
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsP2PRouterToClient) ne(b CMsgSteamDatagramConnectionStatsP2PRouterToClient) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsP2PRouterToClient) eq(b []CMsgSteamDatagramConnectionStatsP2PRouterToClient) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsP2PRouterToClient) ne(b []CMsgSteamDatagramConnectionStatsP2PRouterToClient) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2proutertoclient() CMsgSteamDatagramConnectionStatsP2PRouterToClient {
	return CMsgSteamDatagramConnectionStatsP2PRouterToClient{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertoclient(o CMsgSteamDatagramConnectionStatsP2PRouterToClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectionstatsp2proutertoclient_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PBadRouteRouterToClient {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	connection_id               u32
	failed_relay_routing_token  []byte
	ack_forward_target_revision u32
	kludge_pad                  u64
}

pub fn (o &CMsgSteamDatagramP2PBadRouteRouterToClient) pack() []byte {
	mut res := []byte{}
	if o.connection_id != u32(0) {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	if o.failed_relay_routing_token != []byte{} {
		res << vproto.pack_bytes_field(o.failed_relay_routing_token, 2)
	}
	if o.ack_forward_target_revision != u32(0) {
		res << vproto.pack_uint32_field(o.ack_forward_target_revision, 3)
	}
	if o.kludge_pad != u64(0) {
		res << vproto.pack_64bit_field(o.kludge_pad, 99)
	}
	return res
}

pub fn cmsgsteamdatagramp2pbadrouteroutertoclient_unpack(buf []byte) ?CMsgSteamDatagramP2PBadRouteRouterToClient {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramp2pbadrouteroutertoclient()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.connection_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.failed_relay_routing_token = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_forward_target_revision = v
				i = ii
			}
			99 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.kludge_pad = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramP2PBadRouteRouterToClient) eq(b CMsgSteamDatagramP2PBadRouteRouterToClient) bool {
	return true && a.connection_id == b.connection_id && a.failed_relay_routing_token == b.failed_relay_routing_token &&
		a.ack_forward_target_revision == b.ack_forward_target_revision && a.kludge_pad == b.kludge_pad
}

[inline]
pub fn (a CMsgSteamDatagramP2PBadRouteRouterToClient) ne(b CMsgSteamDatagramP2PBadRouteRouterToClient) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramP2PBadRouteRouterToClient) eq(b []CMsgSteamDatagramP2PBadRouteRouterToClient) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramP2PBadRouteRouterToClient) ne(b []CMsgSteamDatagramP2PBadRouteRouterToClient) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2pbadrouteroutertoclient() CMsgSteamDatagramP2PBadRouteRouterToClient {
	return CMsgSteamDatagramP2PBadRouteRouterToClient{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2pbadrouteroutertoclient(o CMsgSteamDatagramP2PBadRouteRouterToClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2pbadrouteroutertoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PBadRouteRouterToClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramp2pbadrouteroutertoclient_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PRoutes_RelayCluster {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	pop_id                      u32
	ping_ms                     u32
	score_penalty               u32
	session_relay_routing_token []byte
}

pub fn (o &CMsgSteamDatagramP2PRoutes_RelayCluster) pack() []byte {
	mut res := []byte{}
	if o.pop_id != u32(0) {
		res << vproto.pack_32bit_field(o.pop_id, 1)
	}
	if o.ping_ms != u32(0) {
		res << vproto.pack_uint32_field(o.ping_ms, 2)
	}
	if o.score_penalty != u32(0) {
		res << vproto.pack_uint32_field(o.score_penalty, 3)
	}
	if o.session_relay_routing_token != []byte{} {
		res << vproto.pack_bytes_field(o.session_relay_routing_token, 4)
	}
	return res
}

pub fn cmsgsteamdatagramp2proutes_relaycluster_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutes_RelayCluster {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramp2proutes_relaycluster()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.pop_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ping_ms = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.score_penalty = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.session_relay_routing_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramP2PRoutes_RelayCluster) eq(b CMsgSteamDatagramP2PRoutes_RelayCluster) bool {
	return true && a.pop_id == b.pop_id && a.ping_ms == b.ping_ms && a.score_penalty == b.score_penalty &&
		a.session_relay_routing_token == b.session_relay_routing_token
}

[inline]
pub fn (a CMsgSteamDatagramP2PRoutes_RelayCluster) ne(b CMsgSteamDatagramP2PRoutes_RelayCluster) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramP2PRoutes_RelayCluster) eq(b []CMsgSteamDatagramP2PRoutes_RelayCluster) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramP2PRoutes_RelayCluster) ne(b []CMsgSteamDatagramP2PRoutes_RelayCluster) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutes_relaycluster() CMsgSteamDatagramP2PRoutes_RelayCluster {
	return CMsgSteamDatagramP2PRoutes_RelayCluster{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes_relaycluster(o CMsgSteamDatagramP2PRoutes_RelayCluster, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes_relaycluster(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutes_RelayCluster) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramp2proutes_relaycluster_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PRoutes_Route {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	my_pop_id      u32
	your_pop_id    u32
	score          u32
}

pub fn (o &CMsgSteamDatagramP2PRoutes_Route) pack() []byte {
	mut res := []byte{}
	if o.my_pop_id != u32(0) {
		res << vproto.pack_32bit_field(o.my_pop_id, 1)
	}
	if o.your_pop_id != u32(0) {
		res << vproto.pack_32bit_field(o.your_pop_id, 2)
	}
	if o.score != u32(0) {
		res << vproto.pack_uint32_field(o.score, 3)
	}
	return res
}

pub fn cmsgsteamdatagramp2proutes_route_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutes_Route {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramp2proutes_route()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.my_pop_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.your_pop_id = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.score = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramP2PRoutes_Route) eq(b CMsgSteamDatagramP2PRoutes_Route) bool {
	return true && a.my_pop_id == b.my_pop_id && a.your_pop_id == b.your_pop_id && a.score ==
		b.score
}

[inline]
pub fn (a CMsgSteamDatagramP2PRoutes_Route) ne(b CMsgSteamDatagramP2PRoutes_Route) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramP2PRoutes_Route) eq(b []CMsgSteamDatagramP2PRoutes_Route) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramP2PRoutes_Route) ne(b []CMsgSteamDatagramP2PRoutes_Route) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutes_route() CMsgSteamDatagramP2PRoutes_Route {
	return CMsgSteamDatagramP2PRoutes_Route{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes_route(o CMsgSteamDatagramP2PRoutes_Route, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes_route(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutes_Route) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramp2proutes_route_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PRoutes {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	relay_clusters []CMsgSteamDatagramP2PRoutes_RelayCluster
	routes         []CMsgSteamDatagramP2PRoutes_Route
	revision       u32
}

pub fn (o &CMsgSteamDatagramP2PRoutes) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.relay_clusters {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes_relaycluster(x, 1)
	}
	// [packed=false]
	for _, x in o.routes {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes_route(x, 2)
	}
	if o.revision != u32(0) {
		res << vproto.pack_uint32_field(o.revision, 3)
	}
	return res
}

pub fn cmsgsteamdatagramp2proutes_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutes {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramp2proutes()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes_relaycluster(cur_buf,
					tag_wiretype.wire_type) ?
				res.relay_clusters << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes_route(cur_buf,
					tag_wiretype.wire_type) ?
				res.routes << v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.revision = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramP2PRoutes) eq(b CMsgSteamDatagramP2PRoutes) bool {
	return true && a.relay_clusters.eq(b.relay_clusters) && a.routes.eq(b.routes) && a.revision ==
		b.revision
}

[inline]
pub fn (a CMsgSteamDatagramP2PRoutes) ne(b CMsgSteamDatagramP2PRoutes) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramP2PRoutes) eq(b []CMsgSteamDatagramP2PRoutes) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramP2PRoutes) ne(b []CMsgSteamDatagramP2PRoutes) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutes() CMsgSteamDatagramP2PRoutes {
	return CMsgSteamDatagramP2PRoutes{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes(o CMsgSteamDatagramP2PRoutes, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutes) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramp2proutes_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameServerSample {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ipv4           u32
	port           u32
}

pub fn (o &CMsgSteamDatagramGameServerSample) pack() []byte {
	mut res := []byte{}
	if o.ipv4 != u32(0) {
		res << vproto.pack_32bit_field(o.ipv4, 1)
	}
	if o.port != u32(0) {
		res << vproto.pack_uint32_field(o.port, 2)
	}
	return res
}

pub fn cmsgsteamdatagramgameserversample_unpack(buf []byte) ?CMsgSteamDatagramGameServerSample {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramgameserversample()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.ipv4 = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.port = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramGameServerSample) eq(b CMsgSteamDatagramGameServerSample) bool {
	return true && a.ipv4 == b.ipv4 && a.port == b.port
}

[inline]
pub fn (a CMsgSteamDatagramGameServerSample) ne(b CMsgSteamDatagramGameServerSample) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramGameServerSample) eq(b []CMsgSteamDatagramGameServerSample) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramGameServerSample) ne(b []CMsgSteamDatagramGameServerSample) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversample() CMsgSteamDatagramGameServerSample {
	return CMsgSteamDatagramGameServerSample{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversample(o CMsgSteamDatagramGameServerSample, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversample(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameServerSample) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramgameserversample_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameServerSampleDataCenter {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	datacenter_id  u32
	servers        []CMsgSteamDatagramGameServerSample
}

pub fn (o &CMsgSteamDatagramGameServerSampleDataCenter) pack() []byte {
	mut res := []byte{}
	if o.datacenter_id != u32(0) {
		res << vproto.pack_32bit_field(o.datacenter_id, 1)
	}
	// [packed=false]
	for _, x in o.servers {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramgameserversample(x, 3)
	}
	return res
}

pub fn cmsgsteamdatagramgameserversampledatacenter_unpack(buf []byte) ?CMsgSteamDatagramGameServerSampleDataCenter {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramgameserversampledatacenter()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.datacenter_id = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversample(cur_buf,
					tag_wiretype.wire_type) ?
				res.servers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramGameServerSampleDataCenter) eq(b CMsgSteamDatagramGameServerSampleDataCenter) bool {
	return true && a.datacenter_id == b.datacenter_id && a.servers.eq(b.servers)
}

[inline]
pub fn (a CMsgSteamDatagramGameServerSampleDataCenter) ne(b CMsgSteamDatagramGameServerSampleDataCenter) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramGameServerSampleDataCenter) eq(b []CMsgSteamDatagramGameServerSampleDataCenter) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramGameServerSampleDataCenter) ne(b []CMsgSteamDatagramGameServerSampleDataCenter) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversampledatacenter() CMsgSteamDatagramGameServerSampleDataCenter {
	return CMsgSteamDatagramGameServerSampleDataCenter{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversampledatacenter(o CMsgSteamDatagramGameServerSampleDataCenter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversampledatacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameServerSampleDataCenter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramgameserversampledatacenter_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramRelayToRelayPing {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	request_timestamp u32
	request_date      u32
	my_pop_id         u32
	your_pop_id       u32
	checksum          u32
	data_centers      []CMsgSteamDatagramGameServerSampleDataCenter
}

pub fn (o &CMsgSteamDatagramRelayToRelayPing) pack() []byte {
	mut res := []byte{}
	if o.request_timestamp != u32(0) {
		res << vproto.pack_32bit_field(o.request_timestamp, 1)
	}
	if o.request_date != u32(0) {
		res << vproto.pack_32bit_field(o.request_date, 2)
	}
	if o.my_pop_id != u32(0) {
		res << vproto.pack_32bit_field(o.my_pop_id, 3)
	}
	if o.your_pop_id != u32(0) {
		res << vproto.pack_32bit_field(o.your_pop_id, 4)
	}
	if o.checksum != u32(0) {
		res << vproto.pack_32bit_field(o.checksum, 5)
	}
	// [packed=false]
	for _, x in o.data_centers {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramgameserversampledatacenter(x, 6)
	}
	return res
}

pub fn cmsgsteamdatagramrelaytorelayping_unpack(buf []byte) ?CMsgSteamDatagramRelayToRelayPing {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramrelaytorelayping()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.request_timestamp = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.request_date = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.my_pop_id = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.your_pop_id = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.checksum = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversampledatacenter(cur_buf,
					tag_wiretype.wire_type) ?
				res.data_centers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramRelayToRelayPing) eq(b CMsgSteamDatagramRelayToRelayPing) bool {
	return true && a.request_timestamp == b.request_timestamp && a.request_date == b.request_date &&
		a.my_pop_id == b.my_pop_id && a.your_pop_id == b.your_pop_id && a.checksum == b.checksum && a.data_centers.eq(b.data_centers)
}

[inline]
pub fn (a CMsgSteamDatagramRelayToRelayPing) ne(b CMsgSteamDatagramRelayToRelayPing) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramRelayToRelayPing) eq(b []CMsgSteamDatagramRelayToRelayPing) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramRelayToRelayPing) ne(b []CMsgSteamDatagramRelayToRelayPing) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrelaytorelayping() CMsgSteamDatagramRelayToRelayPing {
	return CMsgSteamDatagramRelayToRelayPing{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrelaytorelayping(o CMsgSteamDatagramRelayToRelayPing, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrelaytorelayping(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRelayToRelayPing) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramrelaytorelayping_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramDataCenterState_Server {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	address        string
	ping_ms        u32
}

pub fn (o &CMsgSteamDatagramDataCenterState_Server) pack() []byte {
	mut res := []byte{}
	if o.address != '' {
		res << vproto.pack_string_field(o.address, 1)
	}
	if o.ping_ms != u32(0) {
		res << vproto.pack_uint32_field(o.ping_ms, 2)
	}
	return res
}

pub fn cmsgsteamdatagramdatacenterstate_server_unpack(buf []byte) ?CMsgSteamDatagramDataCenterState_Server {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstate_server()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.address = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ping_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramDataCenterState_Server) eq(b CMsgSteamDatagramDataCenterState_Server) bool {
	return true && a.address == b.address && a.ping_ms == b.ping_ms
}

[inline]
pub fn (a CMsgSteamDatagramDataCenterState_Server) ne(b CMsgSteamDatagramDataCenterState_Server) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramDataCenterState_Server) eq(b []CMsgSteamDatagramDataCenterState_Server) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramDataCenterState_Server) ne(b []CMsgSteamDatagramDataCenterState_Server) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstate_server() CMsgSteamDatagramDataCenterState_Server {
	return CMsgSteamDatagramDataCenterState_Server{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate_server(o CMsgSteamDatagramDataCenterState_Server, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate_server(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDataCenterState_Server) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramdatacenterstate_server_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramDataCenterState_DataCenter {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	code           string
	server_sample  []CMsgSteamDatagramDataCenterState_Server
	relay_sample   []CMsgSteamDatagramDataCenterState_Server
}

pub fn (o &CMsgSteamDatagramDataCenterState_DataCenter) pack() []byte {
	mut res := []byte{}
	if o.code != '' {
		res << vproto.pack_string_field(o.code, 1)
	}
	// [packed=false]
	for _, x in o.server_sample {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate_server(x, 2)
	}
	// [packed=false]
	for _, x in o.relay_sample {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate_server(x, 3)
	}
	return res
}

pub fn cmsgsteamdatagramdatacenterstate_datacenter_unpack(buf []byte) ?CMsgSteamDatagramDataCenterState_DataCenter {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstate_datacenter()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.code = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate_server(cur_buf,
					tag_wiretype.wire_type) ?
				res.server_sample << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate_server(cur_buf,
					tag_wiretype.wire_type) ?
				res.relay_sample << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramDataCenterState_DataCenter) eq(b CMsgSteamDatagramDataCenterState_DataCenter) bool {
	return true && a.code == b.code && a.server_sample.eq(b.server_sample) && a.relay_sample.eq(b.relay_sample)
}

[inline]
pub fn (a CMsgSteamDatagramDataCenterState_DataCenter) ne(b CMsgSteamDatagramDataCenterState_DataCenter) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramDataCenterState_DataCenter) eq(b []CMsgSteamDatagramDataCenterState_DataCenter) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramDataCenterState_DataCenter) ne(b []CMsgSteamDatagramDataCenterState_DataCenter) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstate_datacenter() CMsgSteamDatagramDataCenterState_DataCenter {
	return CMsgSteamDatagramDataCenterState_DataCenter{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate_datacenter(o CMsgSteamDatagramDataCenterState_DataCenter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate_datacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDataCenterState_DataCenter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramdatacenterstate_datacenter_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramDataCenterState {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	data_centers   []CMsgSteamDatagramDataCenterState_DataCenter
}

pub fn (o &CMsgSteamDatagramDataCenterState) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.data_centers {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate_datacenter(x, 1)
	}
	return res
}

pub fn cmsgsteamdatagramdatacenterstate_unpack(buf []byte) ?CMsgSteamDatagramDataCenterState {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate_datacenter(cur_buf,
					tag_wiretype.wire_type) ?
				res.data_centers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramDataCenterState) eq(b CMsgSteamDatagramDataCenterState) bool {
	return true && a.data_centers.eq(b.data_centers)
}

[inline]
pub fn (a CMsgSteamDatagramDataCenterState) ne(b CMsgSteamDatagramDataCenterState) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramDataCenterState) eq(b []CMsgSteamDatagramDataCenterState) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramDataCenterState) ne(b []CMsgSteamDatagramDataCenterState) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstate() CMsgSteamDatagramDataCenterState {
	return CMsgSteamDatagramDataCenterState{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate(o CMsgSteamDatagramDataCenterState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDataCenterState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramdatacenterstate_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramRouterHealth_DataCenter {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	datacenter_id  u32
	state          u32
	servers        []CMsgSteamDatagramGameServerSample
}

pub fn (o &CMsgSteamDatagramRouterHealth_DataCenter) pack() []byte {
	mut res := []byte{}
	if o.datacenter_id != u32(0) {
		res << vproto.pack_32bit_field(o.datacenter_id, 1)
	}
	if o.state != u32(0) {
		res << vproto.pack_uint32_field(o.state, 2)
	}
	// [packed=false]
	for _, x in o.servers {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramgameserversample(x, 3)
	}
	return res
}

pub fn cmsgsteamdatagramrouterhealth_datacenter_unpack(buf []byte) ?CMsgSteamDatagramRouterHealth_DataCenter {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramrouterhealth_datacenter()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.datacenter_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.state = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversample(cur_buf,
					tag_wiretype.wire_type) ?
				res.servers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramRouterHealth_DataCenter) eq(b CMsgSteamDatagramRouterHealth_DataCenter) bool {
	return true && a.datacenter_id == b.datacenter_id && a.state == b.state && a.servers.eq(b.servers)
}

[inline]
pub fn (a CMsgSteamDatagramRouterHealth_DataCenter) ne(b CMsgSteamDatagramRouterHealth_DataCenter) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramRouterHealth_DataCenter) eq(b []CMsgSteamDatagramRouterHealth_DataCenter) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramRouterHealth_DataCenter) ne(b []CMsgSteamDatagramRouterHealth_DataCenter) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterhealth_datacenter() CMsgSteamDatagramRouterHealth_DataCenter {
	return CMsgSteamDatagramRouterHealth_DataCenter{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterhealth_datacenter(o CMsgSteamDatagramRouterHealth_DataCenter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterhealth_datacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterHealth_DataCenter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramrouterhealth_datacenter_unpack(v) ?
	return i, unpacked
}

pub struct CMsgSteamDatagramRouterHealth {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	cpu_load               f32
	cpu_load_raw           f32
	active_sessions        u32
	data_pkts_sec          u32
	other_pkts_sec         u32
	seconds_until_shutdown u32
	cpu_cost_per_user      f32
	cpu_cost_per_packet    f32
	data_centers           []CMsgSteamDatagramRouterHealth_DataCenter
	magic                  u64
}

pub fn (o &CMsgSteamDatagramRouterHealth) pack() []byte {
	mut res := []byte{}
	if o.cpu_load != f32(0) {
		res << vproto.pack_float_field(o.cpu_load, 1)
	}
	if o.cpu_load_raw != f32(0) {
		res << vproto.pack_float_field(o.cpu_load_raw, 10)
	}
	if o.active_sessions != u32(0) {
		res << vproto.pack_uint32_field(o.active_sessions, 2)
	}
	if o.data_pkts_sec != u32(0) {
		res << vproto.pack_uint32_field(o.data_pkts_sec, 3)
	}
	if o.other_pkts_sec != u32(0) {
		res << vproto.pack_uint32_field(o.other_pkts_sec, 4)
	}
	if o.seconds_until_shutdown != u32(0) {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 5)
	}
	if o.cpu_cost_per_user != f32(0) {
		res << vproto.pack_float_field(o.cpu_cost_per_user, 8)
	}
	if o.cpu_cost_per_packet != f32(0) {
		res << vproto.pack_float_field(o.cpu_cost_per_packet, 9)
	}
	// [packed=false]
	for _, x in o.data_centers {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramrouterhealth_datacenter(x, 6)
	}
	if o.magic != u64(0) {
		res << vproto.pack_64bit_field(o.magic, 7)
	}
	return res
}

pub fn cmsgsteamdatagramrouterhealth_unpack(buf []byte) ?CMsgSteamDatagramRouterHealth {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramrouterhealth()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type) ?
				res.cpu_load = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type) ?
				res.cpu_load_raw = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.active_sessions = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.data_pkts_sec = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.other_pkts_sec = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seconds_until_shutdown = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type) ?
				res.cpu_cost_per_user = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type) ?
				res.cpu_cost_per_packet = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramrouterhealth_datacenter(cur_buf,
					tag_wiretype.wire_type) ?
				res.data_centers << v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.magic = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramRouterHealth) eq(b CMsgSteamDatagramRouterHealth) bool {
	return true && a.cpu_load == b.cpu_load && a.cpu_load_raw == b.cpu_load_raw && a.active_sessions ==
		b.active_sessions && a.data_pkts_sec == b.data_pkts_sec && a.other_pkts_sec == b.other_pkts_sec &&
		a.seconds_until_shutdown == b.seconds_until_shutdown && a.cpu_cost_per_user == b.cpu_cost_per_user &&
		a.cpu_cost_per_packet == b.cpu_cost_per_packet && a.data_centers.eq(b.data_centers) &&
		a.magic == b.magic
}

[inline]
pub fn (a CMsgSteamDatagramRouterHealth) ne(b CMsgSteamDatagramRouterHealth) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramRouterHealth) eq(b []CMsgSteamDatagramRouterHealth) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramRouterHealth) ne(b []CMsgSteamDatagramRouterHealth) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterhealth() CMsgSteamDatagramRouterHealth {
	return CMsgSteamDatagramRouterHealth{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterhealth(o CMsgSteamDatagramRouterHealth, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterhealth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterHealth) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramrouterhealth_unpack(v) ?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
	not_primary_transport_e2e = 16
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2proutertorouter_flags() CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags {
	return .ack_request_relay
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertorouter_flags(e CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertorouter_flags_packed(e []CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertorouter_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertorouter_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	quality_relay               CMsgSteamDatagramConnectionQuality
	quality_e2e                 CMsgSteamDatagramConnectionQuality
	ack_relay                   []u32
	legacy_ack_e2e              []u32
	flags                       u32
	ack_forward_target_revision u32
	routes                      []byte
	ack_peer_routes_revision    u32
	seq_num_r2r                 u32
	seq_num_e2e                 u32
	from_relay_session_id       u32
	to_relay_session_id         u32
}

pub fn (o &CMsgSteamDatagramConnectionStatsP2PRouterToRouter) pack() []byte {
	mut res := []byte{}
	if o.quality_relay.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.quality_e2e.ne(zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality()) {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 3)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 4)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 5)
	}
	if o.ack_forward_target_revision != u32(0) {
		res << vproto.pack_uint32_field(o.ack_forward_target_revision, 6)
	}
	if o.routes != []byte{} {
		res << vproto.pack_bytes_field(o.routes, 7)
	}
	if o.ack_peer_routes_revision != u32(0) {
		res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 8)
	}
	if o.seq_num_r2r != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_r2r, 26)
	}
	if o.seq_num_e2e != u32(0) {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 27)
	}
	if o.from_relay_session_id != u32(0) {
		res << vproto.pack_32bit_field(o.from_relay_session_id, 22)
	}
	if o.to_relay_session_id != u32(0) {
		res << vproto.pack_32bit_field(o.to_relay_session_id, 25)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsp2proutertorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
	mut res := zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2proutertorouter()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_relay = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type) ?
				res.quality_e2e = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_relay << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.legacy_ack_e2e << v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.flags = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_forward_target_revision = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.routes = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ack_peer_routes_revision = v
				i = ii
			}
			26 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_r2r = v
				i = ii
			}
			27 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.seq_num_e2e = v
				i = ii
			}
			22 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.from_relay_session_id = v
				i = ii
			}
			25 {
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.to_relay_session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsP2PRouterToRouter) eq(b CMsgSteamDatagramConnectionStatsP2PRouterToRouter) bool {
	return true && a.quality_relay.eq(b.quality_relay) && a.quality_e2e.eq(b.quality_e2e) &&
		a.ack_relay == b.ack_relay && a.legacy_ack_e2e == b.legacy_ack_e2e && a.flags == b.flags &&
		a.ack_forward_target_revision == b.ack_forward_target_revision && a.routes == b.routes &&
		a.ack_peer_routes_revision == b.ack_peer_routes_revision && a.seq_num_r2r == b.seq_num_r2r &&
		a.seq_num_e2e == b.seq_num_e2e && a.from_relay_session_id == b.from_relay_session_id &&
		a.to_relay_session_id == b.to_relay_session_id
}

[inline]
pub fn (a CMsgSteamDatagramConnectionStatsP2PRouterToRouter) ne(b CMsgSteamDatagramConnectionStatsP2PRouterToRouter) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsP2PRouterToRouter) eq(b []CMsgSteamDatagramConnectionStatsP2PRouterToRouter) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamDatagramConnectionStatsP2PRouterToRouter) ne(b []CMsgSteamDatagramConnectionStatsP2PRouterToRouter) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2proutertorouter() CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
	return CMsgSteamDatagramConnectionStatsP2PRouterToRouter{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertorouter(o CMsgSteamDatagramConnectionStatsP2PRouterToRouter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToRouter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgsteamdatagramconnectionstatsp2proutertorouter_unpack(v) ?
	return i, unpacked
}
