// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EMMSLobbyStatus {
	k_emmslobbystatusinvalid = 0
	k_emmslobbystatusexists = 1
	k_emmslobbystatusdoesnotexist = 2
	k_emmslobbystatusnotamember = 3
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_emmslobbystatus() EMMSLobbyStatus {
	return .k_emmslobbystatusinvalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_emmslobbystatus(e EMMSLobbyStatus, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_emmslobbystatus_packed(e []EMMSLobbyStatus, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_emmslobbystatus(buf []byte, tag_wiretype vproto.WireType) ?(int, EMMSLobbyStatus) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, EMMSLobbyStatus(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_emmslobbystatus_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EMMSLobbyStatus) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgClientUDSP2PSessionStarted {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid_remote u64
	appid          int
}

pub fn (o &CMsgClientUDSP2PSessionStarted) pack() []byte {
	mut res := []byte{}
	if o.steamid_remote != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_remote, 1)
	}
	if o.appid != int(0) {
		res << vproto.pack_int32_field(o.appid, 2)
	}
	return res
}

pub fn cmsgclientudsp2psessionstarted_unpack(buf []byte) ?CMsgClientUDSP2PSessionStarted {
	mut res := zzz_vproto_internal_new_cmsgclientudsp2psessionstarted()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid_remote = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.appid = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUDSP2PSessionStarted) eq(b CMsgClientUDSP2PSessionStarted) bool {
	return true && a.steamid_remote == b.steamid_remote && a.appid == b.appid
}

[inline]
pub fn (a CMsgClientUDSP2PSessionStarted) ne(b CMsgClientUDSP2PSessionStarted) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUDSP2PSessionStarted) eq(b []CMsgClientUDSP2PSessionStarted) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUDSP2PSessionStarted) ne(b []CMsgClientUDSP2PSessionStarted) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientudsp2psessionstarted() CMsgClientUDSP2PSessionStarted {
	return CMsgClientUDSP2PSessionStarted{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientudsp2psessionstarted(o CMsgClientUDSP2PSessionStarted, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientudsp2psessionstarted(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUDSP2PSessionStarted) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientudsp2psessionstarted_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUDSP2PSessionEnded {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steamid_remote     u64
	appid              int
	session_length_sec int
	session_error      int
	nattype            int
	bytes_recv         int
	bytes_sent         int
	bytes_sent_relay   int
	bytes_recv_relay   int
	time_to_connect_ms int
}

pub fn (o &CMsgClientUDSP2PSessionEnded) pack() []byte {
	mut res := []byte{}
	if o.steamid_remote != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_remote, 1)
	}
	if o.appid != int(0) {
		res << vproto.pack_int32_field(o.appid, 2)
	}
	if o.session_length_sec != int(0) {
		res << vproto.pack_int32_field(o.session_length_sec, 3)
	}
	if o.session_error != int(0) {
		res << vproto.pack_int32_field(o.session_error, 4)
	}
	if o.nattype != int(0) {
		res << vproto.pack_int32_field(o.nattype, 5)
	}
	if o.bytes_recv != int(0) {
		res << vproto.pack_int32_field(o.bytes_recv, 6)
	}
	if o.bytes_sent != int(0) {
		res << vproto.pack_int32_field(o.bytes_sent, 7)
	}
	if o.bytes_sent_relay != int(0) {
		res << vproto.pack_int32_field(o.bytes_sent_relay, 8)
	}
	if o.bytes_recv_relay != int(0) {
		res << vproto.pack_int32_field(o.bytes_recv_relay, 9)
	}
	if o.time_to_connect_ms != int(0) {
		res << vproto.pack_int32_field(o.time_to_connect_ms, 10)
	}
	return res
}

pub fn cmsgclientudsp2psessionended_unpack(buf []byte) ?CMsgClientUDSP2PSessionEnded {
	mut res := zzz_vproto_internal_new_cmsgclientudsp2psessionended()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid_remote = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.appid = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.session_length_sec = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.session_error = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.nattype = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.bytes_recv = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.bytes_sent = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.bytes_sent_relay = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.bytes_recv_relay = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.time_to_connect_ms = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUDSP2PSessionEnded) eq(b CMsgClientUDSP2PSessionEnded) bool {
	return true && a.steamid_remote == b.steamid_remote && a.appid == b.appid && a.session_length_sec ==
		b.session_length_sec && a.session_error == b.session_error && a.nattype == b.nattype &&
		a.bytes_recv == b.bytes_recv && a.bytes_sent == b.bytes_sent && a.bytes_sent_relay == b.bytes_sent_relay &&
		a.bytes_recv_relay == b.bytes_recv_relay && a.time_to_connect_ms == b.time_to_connect_ms
}

[inline]
pub fn (a CMsgClientUDSP2PSessionEnded) ne(b CMsgClientUDSP2PSessionEnded) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUDSP2PSessionEnded) eq(b []CMsgClientUDSP2PSessionEnded) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUDSP2PSessionEnded) ne(b []CMsgClientUDSP2PSessionEnded) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientudsp2psessionended() CMsgClientUDSP2PSessionEnded {
	return CMsgClientUDSP2PSessionEnded{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientudsp2psessionended(o CMsgClientUDSP2PSessionEnded, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientudsp2psessionended(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUDSP2PSessionEnded) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientudsp2psessionended_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRegisterAuthTicketWithCM {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	protocol_version   u32
	ticket             []byte
	client_instance_id u64
}

pub fn (o &CMsgClientRegisterAuthTicketWithCM) pack() []byte {
	mut res := []byte{}
	if o.protocol_version != u32(0) {
		res << vproto.pack_uint32_field(o.protocol_version, 1)
	}
	if o.ticket != []byte{} {
		res << vproto.pack_bytes_field(o.ticket, 3)
	}
	if o.client_instance_id != u64(0) {
		res << vproto.pack_uint64_field(o.client_instance_id, 4)
	}
	return res
}

pub fn cmsgclientregisterauthticketwithcm_unpack(buf []byte) ?CMsgClientRegisterAuthTicketWithCM {
	mut res := zzz_vproto_internal_new_cmsgclientregisterauthticketwithcm()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.protocol_version = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.ticket = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.client_instance_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRegisterAuthTicketWithCM) eq(b CMsgClientRegisterAuthTicketWithCM) bool {
	return true && a.protocol_version == b.protocol_version && a.ticket == b.ticket &&
		a.client_instance_id == b.client_instance_id
}

[inline]
pub fn (a CMsgClientRegisterAuthTicketWithCM) ne(b CMsgClientRegisterAuthTicketWithCM) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRegisterAuthTicketWithCM) eq(b []CMsgClientRegisterAuthTicketWithCM) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRegisterAuthTicketWithCM) ne(b []CMsgClientRegisterAuthTicketWithCM) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientregisterauthticketwithcm() CMsgClientRegisterAuthTicketWithCM {
	return CMsgClientRegisterAuthTicketWithCM{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientregisterauthticketwithcm(o CMsgClientRegisterAuthTicketWithCM, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientregisterauthticketwithcm(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRegisterAuthTicketWithCM) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientregisterauthticketwithcm_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientTicketAuthComplete {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	steam_id               u64
	game_id                u64
	estate                 u32
	eauth_session_response u32
	deprecated_ticket      []byte
	ticket_crc             u32
	ticket_sequence        u32
	owner_steam_id         u64
}

pub fn (o &CMsgClientTicketAuthComplete) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.game_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_id, 2)
	}
	if o.estate != u32(0) {
		res << vproto.pack_uint32_field(o.estate, 3)
	}
	if o.eauth_session_response != u32(0) {
		res << vproto.pack_uint32_field(o.eauth_session_response, 4)
	}
	if o.deprecated_ticket != []byte{} {
		res << vproto.pack_bytes_field(o.deprecated_ticket, 5)
	}
	if o.ticket_crc != u32(0) {
		res << vproto.pack_uint32_field(o.ticket_crc, 6)
	}
	if o.ticket_sequence != u32(0) {
		res << vproto.pack_uint32_field(o.ticket_sequence, 7)
	}
	if o.owner_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.owner_steam_id, 8)
	}
	return res
}

pub fn cmsgclientticketauthcomplete_unpack(buf []byte) ?CMsgClientTicketAuthComplete {
	mut res := zzz_vproto_internal_new_cmsgclientticketauthcomplete()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.game_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.estate = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.eauth_session_response = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.deprecated_ticket = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.ticket_crc = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.ticket_sequence = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.owner_steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientTicketAuthComplete) eq(b CMsgClientTicketAuthComplete) bool {
	return true && a.steam_id == b.steam_id && a.game_id == b.game_id && a.estate == b.estate &&
		a.eauth_session_response == b.eauth_session_response && a.deprecated_ticket == b.deprecated_ticket &&
		a.ticket_crc == b.ticket_crc && a.ticket_sequence == b.ticket_sequence && a.owner_steam_id ==
		b.owner_steam_id
}

[inline]
pub fn (a CMsgClientTicketAuthComplete) ne(b CMsgClientTicketAuthComplete) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientTicketAuthComplete) eq(b []CMsgClientTicketAuthComplete) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientTicketAuthComplete) ne(b []CMsgClientTicketAuthComplete) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientticketauthcomplete() CMsgClientTicketAuthComplete {
	return CMsgClientTicketAuthComplete{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientticketauthcomplete(o CMsgClientTicketAuthComplete, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientticketauthcomplete(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientTicketAuthComplete) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientticketauthcomplete_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientCMList {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	cm_addresses                 []u32
	cm_ports                     []u32
	cm_websocket_addresses       []string
	percent_default_to_websocket u32
}

pub fn (o &CMsgClientCMList) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.cm_addresses {
		res << vproto.pack_uint32_field(x, 1)
	}
	// [packed=false]
	for _, x in o.cm_ports {
		res << vproto.pack_uint32_field(x, 2)
	}
	// [packed=false]
	for _, x in o.cm_websocket_addresses {
		res << vproto.pack_string_field(x, 3)
	}
	if o.percent_default_to_websocket != u32(0) {
		res << vproto.pack_uint32_field(o.percent_default_to_websocket, 4)
	}
	return res
}

pub fn cmsgclientcmlist_unpack(buf []byte) ?CMsgClientCMList {
	mut res := zzz_vproto_internal_new_cmsgclientcmlist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.cm_addresses << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.cm_ports << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.cm_websocket_addresses << v
				i = ii
			}
			4 {
				i, res.percent_default_to_websocket = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientCMList) eq(b CMsgClientCMList) bool {
	return true && a.cm_addresses == b.cm_addresses && a.cm_ports == b.cm_ports && a.cm_websocket_addresses ==
		b.cm_websocket_addresses && a.percent_default_to_websocket == b.percent_default_to_websocket
}

[inline]
pub fn (a CMsgClientCMList) ne(b CMsgClientCMList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientCMList) eq(b []CMsgClientCMList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientCMList) ne(b []CMsgClientCMList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientcmlist() CMsgClientCMList {
	return CMsgClientCMList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientcmlist(o CMsgClientCMList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientcmlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCMList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientcmlist_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientP2PConnectionInfo {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	steam_id_dest     u64
	steam_id_src      u64
	app_id            u32
	candidate         []byte
	connection_id_src u64
	rendezvous        []byte
}

pub fn (o &CMsgClientP2PConnectionInfo) pack() []byte {
	mut res := []byte{}
	if o.steam_id_dest != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_dest, 1)
	}
	if o.steam_id_src != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_src, 2)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 3)
	}
	if o.candidate != []byte{} {
		res << vproto.pack_bytes_field(o.candidate, 4)
	}
	if o.connection_id_src != u64(0) {
		res << vproto.pack_64bit_field(o.connection_id_src, 5)
	}
	if o.rendezvous != []byte{} {
		res << vproto.pack_bytes_field(o.rendezvous, 6)
	}
	return res
}

pub fn cmsgclientp2pconnectioninfo_unpack(buf []byte) ?CMsgClientP2PConnectionInfo {
	mut res := zzz_vproto_internal_new_cmsgclientp2pconnectioninfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id_dest = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_src = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.candidate = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.connection_id_src = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.rendezvous = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientP2PConnectionInfo) eq(b CMsgClientP2PConnectionInfo) bool {
	return true && a.steam_id_dest == b.steam_id_dest && a.steam_id_src == b.steam_id_src &&
		a.app_id == b.app_id && a.candidate == b.candidate && a.connection_id_src == b.connection_id_src &&
		a.rendezvous == b.rendezvous
}

[inline]
pub fn (a CMsgClientP2PConnectionInfo) ne(b CMsgClientP2PConnectionInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientP2PConnectionInfo) eq(b []CMsgClientP2PConnectionInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientP2PConnectionInfo) ne(b []CMsgClientP2PConnectionInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientp2pconnectioninfo() CMsgClientP2PConnectionInfo {
	return CMsgClientP2PConnectionInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientp2pconnectioninfo(o CMsgClientP2PConnectionInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientp2pconnectioninfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientP2PConnectionInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientp2pconnectioninfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientP2PConnectionFailInfo {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steam_id_dest      u64
	steam_id_src       u64
	app_id             u32
	ep2p_session_error u32
	connection_id_dest u64
	close_reason       u32
	close_message      string
}

pub fn (o &CMsgClientP2PConnectionFailInfo) pack() []byte {
	mut res := []byte{}
	if o.steam_id_dest != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_dest, 1)
	}
	if o.steam_id_src != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_src, 2)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 3)
	}
	if o.ep2p_session_error != u32(0) {
		res << vproto.pack_uint32_field(o.ep2p_session_error, 4)
	}
	if o.connection_id_dest != u64(0) {
		res << vproto.pack_64bit_field(o.connection_id_dest, 5)
	}
	if o.close_reason != u32(0) {
		res << vproto.pack_uint32_field(o.close_reason, 7)
	}
	if o.close_message != '' {
		res << vproto.pack_string_field(o.close_message, 8)
	}
	return res
}

pub fn cmsgclientp2pconnectionfailinfo_unpack(buf []byte) ?CMsgClientP2PConnectionFailInfo {
	mut res := zzz_vproto_internal_new_cmsgclientp2pconnectionfailinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id_dest = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_src = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.ep2p_session_error = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.connection_id_dest = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.close_reason = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.close_message = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientP2PConnectionFailInfo) eq(b CMsgClientP2PConnectionFailInfo) bool {
	return true && a.steam_id_dest == b.steam_id_dest && a.steam_id_src == b.steam_id_src &&
		a.app_id == b.app_id && a.ep2p_session_error == b.ep2p_session_error && a.connection_id_dest ==
		b.connection_id_dest && a.close_reason == b.close_reason && a.close_message == b.close_message
}

[inline]
pub fn (a CMsgClientP2PConnectionFailInfo) ne(b CMsgClientP2PConnectionFailInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientP2PConnectionFailInfo) eq(b []CMsgClientP2PConnectionFailInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientP2PConnectionFailInfo) ne(b []CMsgClientP2PConnectionFailInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientp2pconnectionfailinfo() CMsgClientP2PConnectionFailInfo {
	return CMsgClientP2PConnectionFailInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientp2pconnectionfailinfo(o CMsgClientP2PConnectionFailInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientp2pconnectionfailinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientP2PConnectionFailInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientp2pconnectionfailinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientNetworkingCertRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key_data       []byte
	app_id         u32
}

pub fn (o &CMsgClientNetworkingCertRequest) pack() []byte {
	mut res := []byte{}
	if o.key_data != []byte{} {
		res << vproto.pack_bytes_field(o.key_data, 2)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 3)
	}
	return res
}

pub fn cmsgclientnetworkingcertrequest_unpack(buf []byte) ?CMsgClientNetworkingCertRequest {
	mut res := zzz_vproto_internal_new_cmsgclientnetworkingcertrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				i, res.key_data = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientNetworkingCertRequest) eq(b CMsgClientNetworkingCertRequest) bool {
	return true && a.key_data == b.key_data && a.app_id == b.app_id
}

[inline]
pub fn (a CMsgClientNetworkingCertRequest) ne(b CMsgClientNetworkingCertRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientNetworkingCertRequest) eq(b []CMsgClientNetworkingCertRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientNetworkingCertRequest) ne(b []CMsgClientNetworkingCertRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientnetworkingcertrequest() CMsgClientNetworkingCertRequest {
	return CMsgClientNetworkingCertRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingcertrequest(o CMsgClientNetworkingCertRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingcertrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingCertRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientnetworkingcertrequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientNetworkingCertReply {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cert           []byte
	ca_key_id      u64
	ca_signature   []byte
}

pub fn (o &CMsgClientNetworkingCertReply) pack() []byte {
	mut res := []byte{}
	if o.cert != []byte{} {
		res << vproto.pack_bytes_field(o.cert, 4)
	}
	if o.ca_key_id != u64(0) {
		res << vproto.pack_64bit_field(o.ca_key_id, 5)
	}
	if o.ca_signature != []byte{} {
		res << vproto.pack_bytes_field(o.ca_signature, 6)
	}
	return res
}

pub fn cmsgclientnetworkingcertreply_unpack(buf []byte) ?CMsgClientNetworkingCertReply {
	mut res := zzz_vproto_internal_new_cmsgclientnetworkingcertreply()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			4 {
				i, res.cert = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.ca_key_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.ca_signature = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientNetworkingCertReply) eq(b CMsgClientNetworkingCertReply) bool {
	return true && a.cert == b.cert && a.ca_key_id == b.ca_key_id && a.ca_signature == b.ca_signature
}

[inline]
pub fn (a CMsgClientNetworkingCertReply) ne(b CMsgClientNetworkingCertReply) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientNetworkingCertReply) eq(b []CMsgClientNetworkingCertReply) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientNetworkingCertReply) ne(b []CMsgClientNetworkingCertReply) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientnetworkingcertreply() CMsgClientNetworkingCertReply {
	return CMsgClientNetworkingCertReply{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingcertreply(o CMsgClientNetworkingCertReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingcertreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingCertReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientnetworkingcertreply_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientNetworkingMobileCertRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
}

pub fn (o &CMsgClientNetworkingMobileCertRequest) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	return res
}

pub fn cmsgclientnetworkingmobilecertrequest_unpack(buf []byte) ?CMsgClientNetworkingMobileCertRequest {
	mut res := zzz_vproto_internal_new_cmsgclientnetworkingmobilecertrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientNetworkingMobileCertRequest) eq(b CMsgClientNetworkingMobileCertRequest) bool {
	return true && a.app_id == b.app_id
}

[inline]
pub fn (a CMsgClientNetworkingMobileCertRequest) ne(b CMsgClientNetworkingMobileCertRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientNetworkingMobileCertRequest) eq(b []CMsgClientNetworkingMobileCertRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientNetworkingMobileCertRequest) ne(b []CMsgClientNetworkingMobileCertRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientnetworkingmobilecertrequest() CMsgClientNetworkingMobileCertRequest {
	return CMsgClientNetworkingMobileCertRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingmobilecertrequest(o CMsgClientNetworkingMobileCertRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingmobilecertrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingMobileCertRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientnetworkingmobilecertrequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientNetworkingMobileCertReply {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	encoded_cert   string
}

pub fn (o &CMsgClientNetworkingMobileCertReply) pack() []byte {
	mut res := []byte{}
	if o.encoded_cert != '' {
		res << vproto.pack_string_field(o.encoded_cert, 1)
	}
	return res
}

pub fn cmsgclientnetworkingmobilecertreply_unpack(buf []byte) ?CMsgClientNetworkingMobileCertReply {
	mut res := zzz_vproto_internal_new_cmsgclientnetworkingmobilecertreply()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.encoded_cert = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientNetworkingMobileCertReply) eq(b CMsgClientNetworkingMobileCertReply) bool {
	return true && a.encoded_cert == b.encoded_cert
}

[inline]
pub fn (a CMsgClientNetworkingMobileCertReply) ne(b CMsgClientNetworkingMobileCertReply) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientNetworkingMobileCertReply) eq(b []CMsgClientNetworkingMobileCertReply) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientNetworkingMobileCertReply) ne(b []CMsgClientNetworkingMobileCertReply) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientnetworkingmobilecertreply() CMsgClientNetworkingMobileCertReply {
	return CMsgClientNetworkingMobileCertReply{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingmobilecertreply(o CMsgClientNetworkingMobileCertReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingmobilecertreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingMobileCertReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientnetworkingmobilecertreply_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetAppOwnershipTicket {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
}

pub fn (o &CMsgClientGetAppOwnershipTicket) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	return res
}

pub fn cmsgclientgetappownershipticket_unpack(buf []byte) ?CMsgClientGetAppOwnershipTicket {
	mut res := zzz_vproto_internal_new_cmsgclientgetappownershipticket()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetAppOwnershipTicket) eq(b CMsgClientGetAppOwnershipTicket) bool {
	return true && a.app_id == b.app_id
}

[inline]
pub fn (a CMsgClientGetAppOwnershipTicket) ne(b CMsgClientGetAppOwnershipTicket) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetAppOwnershipTicket) eq(b []CMsgClientGetAppOwnershipTicket) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetAppOwnershipTicket) ne(b []CMsgClientGetAppOwnershipTicket) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetappownershipticket() CMsgClientGetAppOwnershipTicket {
	return CMsgClientGetAppOwnershipTicket{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetappownershipticket(o CMsgClientGetAppOwnershipTicket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetappownershipticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAppOwnershipTicket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetappownershipticket_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetAppOwnershipTicketResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32 = 2
	app_id         u32
	ticket         []byte
}

pub fn (o &CMsgClientGetAppOwnershipTicketResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != u32(0) {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.ticket != []byte{} {
		res << vproto.pack_bytes_field(o.ticket, 3)
	}
	return res
}

pub fn cmsgclientgetappownershipticketresponse_unpack(buf []byte) ?CMsgClientGetAppOwnershipTicketResponse {
	mut res := zzz_vproto_internal_new_cmsgclientgetappownershipticketresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.ticket = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetAppOwnershipTicketResponse) eq(b CMsgClientGetAppOwnershipTicketResponse) bool {
	return true && a.eresult == b.eresult && a.app_id == b.app_id && a.ticket == b.ticket
}

[inline]
pub fn (a CMsgClientGetAppOwnershipTicketResponse) ne(b CMsgClientGetAppOwnershipTicketResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetAppOwnershipTicketResponse) eq(b []CMsgClientGetAppOwnershipTicketResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetAppOwnershipTicketResponse) ne(b []CMsgClientGetAppOwnershipTicketResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetappownershipticketresponse() CMsgClientGetAppOwnershipTicketResponse {
	return CMsgClientGetAppOwnershipTicketResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetappownershipticketresponse(o CMsgClientGetAppOwnershipTicketResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetappownershipticketresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAppOwnershipTicketResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetappownershipticketresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSessionToken {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	token          u64
}

pub fn (o &CMsgClientSessionToken) pack() []byte {
	mut res := []byte{}
	if o.token != u64(0) {
		res << vproto.pack_uint64_field(o.token, 1)
	}
	return res
}

pub fn cmsgclientsessiontoken_unpack(buf []byte) ?CMsgClientSessionToken {
	mut res := zzz_vproto_internal_new_cmsgclientsessiontoken()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.token = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSessionToken) eq(b CMsgClientSessionToken) bool {
	return true && a.token == b.token
}

[inline]
pub fn (a CMsgClientSessionToken) ne(b CMsgClientSessionToken) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSessionToken) eq(b []CMsgClientSessionToken) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSessionToken) ne(b []CMsgClientSessionToken) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsessiontoken() CMsgClientSessionToken {
	return CMsgClientSessionToken{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsessiontoken(o CMsgClientSessionToken, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsessiontoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSessionToken) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsessiontoken_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGameConnectTokens {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	max_tokens_to_keep u32 = 10
	tokens             [][]byte
}

pub fn (o &CMsgClientGameConnectTokens) pack() []byte {
	mut res := []byte{}
	if o.max_tokens_to_keep != u32(0) {
		res << vproto.pack_uint32_field(o.max_tokens_to_keep, 1)
	}
	// [packed=false]
	for _, x in o.tokens {
		res << vproto.pack_bytes_field(x, 2)
	}
	return res
}

pub fn cmsgclientgameconnecttokens_unpack(buf []byte) ?CMsgClientGameConnectTokens {
	mut res := zzz_vproto_internal_new_cmsgclientgameconnecttokens()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.max_tokens_to_keep = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.tokens << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGameConnectTokens) eq(b CMsgClientGameConnectTokens) bool {
	return true && a.max_tokens_to_keep == b.max_tokens_to_keep && a.tokens == b.tokens
}

[inline]
pub fn (a CMsgClientGameConnectTokens) ne(b CMsgClientGameConnectTokens) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGameConnectTokens) eq(b []CMsgClientGameConnectTokens) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGameConnectTokens) ne(b []CMsgClientGameConnectTokens) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgameconnecttokens() CMsgClientGameConnectTokens {
	return CMsgClientGameConnectTokens{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgameconnecttokens(o CMsgClientGameConnectTokens, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgameconnecttokens(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGameConnectTokens) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgameconnecttokens_unpack(v) ?
	return i, unpacked
}

pub struct CMsgGSServerType {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	app_id_served              u32
	flags                      u32
	deprecated_game_ip_address u32
	game_port                  u32
	game_dir                   string
	game_version               string
	game_query_port            u32
}

pub fn (o &CMsgGSServerType) pack() []byte {
	mut res := []byte{}
	if o.app_id_served != u32(0) {
		res << vproto.pack_uint32_field(o.app_id_served, 1)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 2)
	}
	if o.deprecated_game_ip_address != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_game_ip_address, 3)
	}
	if o.game_port != u32(0) {
		res << vproto.pack_uint32_field(o.game_port, 4)
	}
	if o.game_dir != '' {
		res << vproto.pack_string_field(o.game_dir, 5)
	}
	if o.game_version != '' {
		res << vproto.pack_string_field(o.game_version, 6)
	}
	if o.game_query_port != u32(0) {
		res << vproto.pack_uint32_field(o.game_query_port, 7)
	}
	return res
}

pub fn cmsggsservertype_unpack(buf []byte) ?CMsgGSServerType {
	mut res := zzz_vproto_internal_new_cmsggsservertype()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id_served = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.deprecated_game_ip_address = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			4 {
				i, res.game_port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.game_dir = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.game_version = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.game_query_port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGSServerType) eq(b CMsgGSServerType) bool {
	return true && a.app_id_served == b.app_id_served && a.flags == b.flags && a.deprecated_game_ip_address ==
		b.deprecated_game_ip_address && a.game_port == b.game_port && a.game_dir == b.game_dir &&
		a.game_version == b.game_version && a.game_query_port == b.game_query_port
}

[inline]
pub fn (a CMsgGSServerType) ne(b CMsgGSServerType) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGSServerType) eq(b []CMsgGSServerType) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGSServerType) ne(b []CMsgGSServerType) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggsservertype() CMsgGSServerType {
	return CMsgGSServerType{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggsservertype(o CMsgGSServerType, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggsservertype(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSServerType) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsggsservertype_unpack(v) ?
	return i, unpacked
}

pub struct CMsgGSStatusReply {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	is_secure      bool
}

pub fn (o &CMsgGSStatusReply) pack() []byte {
	mut res := []byte{}
	if o.is_secure != false {
		res << vproto.pack_bool_field(o.is_secure, 1)
	}
	return res
}

pub fn cmsggsstatusreply_unpack(buf []byte) ?CMsgGSStatusReply {
	mut res := zzz_vproto_internal_new_cmsggsstatusreply()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.is_secure = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGSStatusReply) eq(b CMsgGSStatusReply) bool {
	return true && a.is_secure == b.is_secure
}

[inline]
pub fn (a CMsgGSStatusReply) ne(b CMsgGSStatusReply) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGSStatusReply) eq(b []CMsgGSStatusReply) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGSStatusReply) ne(b []CMsgGSStatusReply) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggsstatusreply() CMsgGSStatusReply {
	return CMsgGSStatusReply{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggsstatusreply(o CMsgGSStatusReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggsstatusreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSStatusReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsggsstatusreply_unpack(v) ?
	return i, unpacked
}

pub struct CMsgGSPlayerList_Player {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steam_id             u64
	deprecated_public_ip u32
	token                []byte
	public_ip            CMsgIPAddress
}

pub fn (o &CMsgGSPlayerList_Player) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_uint64_field(o.steam_id, 1)
	}
	if o.deprecated_public_ip != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 2)
	}
	if o.token != []byte{} {
		res << vproto.pack_bytes_field(o.token, 3)
	}
	if o.public_ip.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 4)
	}
	return res
}

pub fn cmsggsplayerlist_player_unpack(buf []byte) ?CMsgGSPlayerList_Player {
	mut res := zzz_vproto_internal_new_cmsggsplayerlist_player()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.deprecated_public_ip = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.token = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.public_ip = zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGSPlayerList_Player) eq(b CMsgGSPlayerList_Player) bool {
	return true && a.steam_id == b.steam_id && a.deprecated_public_ip == b.deprecated_public_ip &&
		a.token == b.token && a.public_ip.eq(b.public_ip)
}

[inline]
pub fn (a CMsgGSPlayerList_Player) ne(b CMsgGSPlayerList_Player) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGSPlayerList_Player) eq(b []CMsgGSPlayerList_Player) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGSPlayerList_Player) ne(b []CMsgGSPlayerList_Player) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggsplayerlist_player() CMsgGSPlayerList_Player {
	return CMsgGSPlayerList_Player{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggsplayerlist_player(o CMsgGSPlayerList_Player, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggsplayerlist_player(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSPlayerList_Player) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsggsplayerlist_player_unpack(v) ?
	return i, unpacked
}

pub struct CMsgGSPlayerList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	players        []CMsgGSPlayerList_Player
}

pub fn (o &CMsgGSPlayerList) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.players {
		res << zzz_vproto_internal_pack_cmsggsplayerlist_player(x, 1)
	}
	return res
}

pub fn cmsggsplayerlist_unpack(buf []byte) ?CMsgGSPlayerList {
	mut res := zzz_vproto_internal_new_cmsggsplayerlist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsggsplayerlist_player(cur_buf, tag_wiretype.wire_type) ?
				res.players << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGSPlayerList) eq(b CMsgGSPlayerList) bool {
	return true && a.players.eq(b.players)
}

[inline]
pub fn (a CMsgGSPlayerList) ne(b CMsgGSPlayerList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGSPlayerList) eq(b []CMsgGSPlayerList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGSPlayerList) ne(b []CMsgGSPlayerList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggsplayerlist() CMsgGSPlayerList {
	return CMsgGSPlayerList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggsplayerlist(o CMsgGSPlayerList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggsplayerlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSPlayerList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsggsplayerlist_unpack(v) ?
	return i, unpacked
}

pub struct CMsgGSUserPlaying {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steam_id             u64
	deprecated_public_ip u32
	token                []byte
	public_ip            CMsgIPAddress
}

pub fn (o &CMsgGSUserPlaying) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.deprecated_public_ip != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 2)
	}
	if o.token != []byte{} {
		res << vproto.pack_bytes_field(o.token, 3)
	}
	if o.public_ip.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 4)
	}
	return res
}

pub fn cmsggsuserplaying_unpack(buf []byte) ?CMsgGSUserPlaying {
	mut res := zzz_vproto_internal_new_cmsggsuserplaying()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.deprecated_public_ip = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.token = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.public_ip = zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGSUserPlaying) eq(b CMsgGSUserPlaying) bool {
	return true && a.steam_id == b.steam_id && a.deprecated_public_ip == b.deprecated_public_ip &&
		a.token == b.token && a.public_ip.eq(b.public_ip)
}

[inline]
pub fn (a CMsgGSUserPlaying) ne(b CMsgGSUserPlaying) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGSUserPlaying) eq(b []CMsgGSUserPlaying) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGSUserPlaying) ne(b []CMsgGSUserPlaying) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggsuserplaying() CMsgGSUserPlaying {
	return CMsgGSUserPlaying{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggsuserplaying(o CMsgGSUserPlaying, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggsuserplaying(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSUserPlaying) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsggsuserplaying_unpack(v) ?
	return i, unpacked
}

pub struct CMsgGSDisconnectNotice {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
}

pub fn (o &CMsgGSDisconnectNotice) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	return res
}

pub fn cmsggsdisconnectnotice_unpack(buf []byte) ?CMsgGSDisconnectNotice {
	mut res := zzz_vproto_internal_new_cmsggsdisconnectnotice()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGSDisconnectNotice) eq(b CMsgGSDisconnectNotice) bool {
	return true && a.steam_id == b.steam_id
}

[inline]
pub fn (a CMsgGSDisconnectNotice) ne(b CMsgGSDisconnectNotice) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGSDisconnectNotice) eq(b []CMsgGSDisconnectNotice) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGSDisconnectNotice) ne(b []CMsgGSDisconnectNotice) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggsdisconnectnotice() CMsgGSDisconnectNotice {
	return CMsgGSDisconnectNotice{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggsdisconnectnotice(o CMsgGSDisconnectNotice, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggsdisconnectnotice(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSDisconnectNotice) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsggsdisconnectnotice_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGamesPlayed_GamePlayed {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	steam_id_gs                      u64
	game_id                          u64
	deprecated_game_ip_address       u32
	game_port                        u32
	is_secure                        bool
	token                            []byte
	game_extra_info                  string
	game_data_blob                   []byte
	process_id                       u32
	streaming_provider_id            u32
	game_flags                       u32
	owner_id                         u32
	vr_hmd_vendor                    string
	vr_hmd_model                     string
	launch_option_type               u32
	primary_controller_type          int = -1
	primary_steam_controller_serial  string
	total_steam_controller_count     u32
	total_non_steam_controller_count u32
	controller_workshop_file_id      u64
	launch_source                    u32
	vr_hmd_runtime                   u32
	game_ip_address                  CMsgIPAddress
	controller_connection_type       u32
}

pub fn (o &CMsgClientGamesPlayed_GamePlayed) pack() []byte {
	mut res := []byte{}
	if o.steam_id_gs != u64(0) {
		res << vproto.pack_uint64_field(o.steam_id_gs, 1)
	}
	if o.game_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_id, 2)
	}
	if o.deprecated_game_ip_address != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_game_ip_address, 3)
	}
	if o.game_port != u32(0) {
		res << vproto.pack_uint32_field(o.game_port, 4)
	}
	if o.is_secure != false {
		res << vproto.pack_bool_field(o.is_secure, 5)
	}
	if o.token != []byte{} {
		res << vproto.pack_bytes_field(o.token, 6)
	}
	if o.game_extra_info != '' {
		res << vproto.pack_string_field(o.game_extra_info, 7)
	}
	if o.game_data_blob != []byte{} {
		res << vproto.pack_bytes_field(o.game_data_blob, 8)
	}
	if o.process_id != u32(0) {
		res << vproto.pack_uint32_field(o.process_id, 9)
	}
	if o.streaming_provider_id != u32(0) {
		res << vproto.pack_uint32_field(o.streaming_provider_id, 10)
	}
	if o.game_flags != u32(0) {
		res << vproto.pack_uint32_field(o.game_flags, 11)
	}
	if o.owner_id != u32(0) {
		res << vproto.pack_uint32_field(o.owner_id, 12)
	}
	if o.vr_hmd_vendor != '' {
		res << vproto.pack_string_field(o.vr_hmd_vendor, 13)
	}
	if o.vr_hmd_model != '' {
		res << vproto.pack_string_field(o.vr_hmd_model, 14)
	}
	if o.launch_option_type != u32(0) {
		res << vproto.pack_uint32_field(o.launch_option_type, 15)
	}
	if o.primary_controller_type != int(0) {
		res << vproto.pack_int32_field(o.primary_controller_type, 16)
	}
	if o.primary_steam_controller_serial != '' {
		res << vproto.pack_string_field(o.primary_steam_controller_serial, 17)
	}
	if o.total_steam_controller_count != u32(0) {
		res << vproto.pack_uint32_field(o.total_steam_controller_count, 18)
	}
	if o.total_non_steam_controller_count != u32(0) {
		res << vproto.pack_uint32_field(o.total_non_steam_controller_count, 19)
	}
	if o.controller_workshop_file_id != u64(0) {
		res << vproto.pack_uint64_field(o.controller_workshop_file_id, 20)
	}
	if o.launch_source != u32(0) {
		res << vproto.pack_uint32_field(o.launch_source, 21)
	}
	if o.vr_hmd_runtime != u32(0) {
		res << vproto.pack_uint32_field(o.vr_hmd_runtime, 22)
	}
	if o.game_ip_address.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.game_ip_address, 23)
	}
	if o.controller_connection_type != u32(0) {
		res << vproto.pack_uint32_field(o.controller_connection_type, 24)
	}
	return res
}

pub fn cmsgclientgamesplayed_gameplayed_unpack(buf []byte) ?CMsgClientGamesPlayed_GamePlayed {
	mut res := zzz_vproto_internal_new_cmsgclientgamesplayed_gameplayed()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id_gs = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.game_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.deprecated_game_ip_address = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			4 {
				i, res.game_port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.is_secure = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.token = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.game_extra_info = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.game_data_blob = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.process_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.streaming_provider_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				i, res.game_flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			12 {
				i, res.owner_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			13 {
				i, res.vr_hmd_vendor = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			14 {
				i, res.vr_hmd_model = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			15 {
				i, res.launch_option_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			16 {
				i, res.primary_controller_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			17 {
				i, res.primary_steam_controller_serial = vproto.unpack_string_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			18 {
				i, res.total_steam_controller_count = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			19 {
				i, res.total_non_steam_controller_count = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			20 {
				i, res.controller_workshop_file_id = vproto.unpack_uint64_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			21 {
				i, res.launch_source = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			22 {
				i, res.vr_hmd_runtime = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			23 {
				i, res.game_ip_address = zzz_vproto_internal_unpack_cmsgipaddress(cur_buf,
					tag_wiretype.wire_type) ?
			}
			24 {
				i, res.controller_connection_type = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGamesPlayed_GamePlayed) eq(b CMsgClientGamesPlayed_GamePlayed) bool {
	return true && a.steam_id_gs == b.steam_id_gs && a.game_id == b.game_id && a.deprecated_game_ip_address ==
		b.deprecated_game_ip_address && a.game_port == b.game_port && a.is_secure == b.is_secure &&
		a.token == b.token && a.game_extra_info == b.game_extra_info && a.game_data_blob == b.game_data_blob &&
		a.process_id == b.process_id && a.streaming_provider_id == b.streaming_provider_id &&
		a.game_flags == b.game_flags && a.owner_id == b.owner_id && a.vr_hmd_vendor == b.vr_hmd_vendor &&
		a.vr_hmd_model == b.vr_hmd_model && a.launch_option_type == b.launch_option_type && a.primary_controller_type ==
		b.primary_controller_type && a.primary_steam_controller_serial == b.primary_steam_controller_serial &&
		a.total_steam_controller_count == b.total_steam_controller_count && a.total_non_steam_controller_count ==
		b.total_non_steam_controller_count && a.controller_workshop_file_id == b.controller_workshop_file_id &&
		a.launch_source == b.launch_source && a.vr_hmd_runtime == b.vr_hmd_runtime && a.game_ip_address.eq(b.game_ip_address) &&
		a.controller_connection_type == b.controller_connection_type
}

[inline]
pub fn (a CMsgClientGamesPlayed_GamePlayed) ne(b CMsgClientGamesPlayed_GamePlayed) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGamesPlayed_GamePlayed) eq(b []CMsgClientGamesPlayed_GamePlayed) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGamesPlayed_GamePlayed) ne(b []CMsgClientGamesPlayed_GamePlayed) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgamesplayed_gameplayed() CMsgClientGamesPlayed_GamePlayed {
	return CMsgClientGamesPlayed_GamePlayed{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgamesplayed_gameplayed(o CMsgClientGamesPlayed_GamePlayed, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgamesplayed_gameplayed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGamesPlayed_GamePlayed) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgamesplayed_gameplayed_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGamesPlayed {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	games_played          []CMsgClientGamesPlayed_GamePlayed
	client_os_type        u32
	cloud_gaming_platform u32
}

pub fn (o &CMsgClientGamesPlayed) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.games_played {
		res << zzz_vproto_internal_pack_cmsgclientgamesplayed_gameplayed(x, 1)
	}
	if o.client_os_type != u32(0) {
		res << vproto.pack_uint32_field(o.client_os_type, 2)
	}
	if o.cloud_gaming_platform != u32(0) {
		res << vproto.pack_uint32_field(o.cloud_gaming_platform, 3)
	}
	return res
}

pub fn cmsgclientgamesplayed_unpack(buf []byte) ?CMsgClientGamesPlayed {
	mut res := zzz_vproto_internal_new_cmsgclientgamesplayed()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgamesplayed_gameplayed(cur_buf,
					tag_wiretype.wire_type) ?
				res.games_played << v
				i = ii
			}
			2 {
				i, res.client_os_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.cloud_gaming_platform = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGamesPlayed) eq(b CMsgClientGamesPlayed) bool {
	return true && a.games_played.eq(b.games_played) && a.client_os_type == b.client_os_type &&
		a.cloud_gaming_platform == b.cloud_gaming_platform
}

[inline]
pub fn (a CMsgClientGamesPlayed) ne(b CMsgClientGamesPlayed) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGamesPlayed) eq(b []CMsgClientGamesPlayed) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGamesPlayed) ne(b []CMsgClientGamesPlayed) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgamesplayed() CMsgClientGamesPlayed {
	return CMsgClientGamesPlayed{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgamesplayed(o CMsgClientGamesPlayed, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgamesplayed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGamesPlayed) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgamesplayed_unpack(v) ?
	return i, unpacked
}

pub struct CMsgGSApprove {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	owner_steam_id u64
}

pub fn (o &CMsgGSApprove) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.owner_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.owner_steam_id, 2)
	}
	return res
}

pub fn cmsggsapprove_unpack(buf []byte) ?CMsgGSApprove {
	mut res := zzz_vproto_internal_new_cmsggsapprove()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.owner_steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGSApprove) eq(b CMsgGSApprove) bool {
	return true && a.steam_id == b.steam_id && a.owner_steam_id == b.owner_steam_id
}

[inline]
pub fn (a CMsgGSApprove) ne(b CMsgGSApprove) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGSApprove) eq(b []CMsgGSApprove) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGSApprove) ne(b []CMsgGSApprove) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggsapprove() CMsgGSApprove {
	return CMsgGSApprove{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggsapprove(o CMsgGSApprove, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggsapprove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSApprove) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsggsapprove_unpack(v) ?
	return i, unpacked
}

pub struct CMsgGSDeny {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	edeny_reason   int
	deny_string    string
}

pub fn (o &CMsgGSDeny) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.edeny_reason != int(0) {
		res << vproto.pack_int32_field(o.edeny_reason, 2)
	}
	if o.deny_string != '' {
		res << vproto.pack_string_field(o.deny_string, 3)
	}
	return res
}

pub fn cmsggsdeny_unpack(buf []byte) ?CMsgGSDeny {
	mut res := zzz_vproto_internal_new_cmsggsdeny()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.edeny_reason = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.deny_string = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGSDeny) eq(b CMsgGSDeny) bool {
	return true && a.steam_id == b.steam_id && a.edeny_reason == b.edeny_reason && a.deny_string ==
		b.deny_string
}

[inline]
pub fn (a CMsgGSDeny) ne(b CMsgGSDeny) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGSDeny) eq(b []CMsgGSDeny) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGSDeny) ne(b []CMsgGSDeny) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggsdeny() CMsgGSDeny {
	return CMsgGSDeny{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggsdeny(o CMsgGSDeny, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggsdeny(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSDeny) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsggsdeny_unpack(v) ?
	return i, unpacked
}

pub struct CMsgGSKick {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	edeny_reason   int
}

pub fn (o &CMsgGSKick) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.edeny_reason != int(0) {
		res << vproto.pack_int32_field(o.edeny_reason, 2)
	}
	return res
}

pub fn cmsggskick_unpack(buf []byte) ?CMsgGSKick {
	mut res := zzz_vproto_internal_new_cmsggskick()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.edeny_reason = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGSKick) eq(b CMsgGSKick) bool {
	return true && a.steam_id == b.steam_id && a.edeny_reason == b.edeny_reason
}

[inline]
pub fn (a CMsgGSKick) ne(b CMsgGSKick) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGSKick) eq(b []CMsgGSKick) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGSKick) ne(b []CMsgGSKick) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggskick() CMsgGSKick {
	return CMsgGSKick{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggskick(o CMsgGSKick, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggskick(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSKick) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsggskick_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAuthList {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	tokens_left                  u32
	last_request_seq             u32
	last_request_seq_from_server u32
	tickets                      []CMsgAuthTicket
	app_ids                      []u32
	message_sequence             u32
}

pub fn (o &CMsgClientAuthList) pack() []byte {
	mut res := []byte{}
	if o.tokens_left != u32(0) {
		res << vproto.pack_uint32_field(o.tokens_left, 1)
	}
	if o.last_request_seq != u32(0) {
		res << vproto.pack_uint32_field(o.last_request_seq, 2)
	}
	if o.last_request_seq_from_server != u32(0) {
		res << vproto.pack_uint32_field(o.last_request_seq_from_server, 3)
	}
	// [packed=false]
	for _, x in o.tickets {
		res << zzz_vproto_internal_pack_cmsgauthticket(x, 4)
	}
	// [packed=false]
	for _, x in o.app_ids {
		res << vproto.pack_uint32_field(x, 5)
	}
	if o.message_sequence != u32(0) {
		res << vproto.pack_uint32_field(o.message_sequence, 6)
	}
	return res
}

pub fn cmsgclientauthlist_unpack(buf []byte) ?CMsgClientAuthList {
	mut res := zzz_vproto_internal_new_cmsgclientauthlist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.tokens_left = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.last_request_seq = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.last_request_seq_from_server = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgauthticket(cur_buf, tag_wiretype.wire_type) ?
				res.tickets << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.app_ids << v
				i = ii
			}
			6 {
				i, res.message_sequence = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAuthList) eq(b CMsgClientAuthList) bool {
	return true && a.tokens_left == b.tokens_left && a.last_request_seq == b.last_request_seq &&
		a.last_request_seq_from_server == b.last_request_seq_from_server && a.tickets.eq(b.tickets) &&
		a.app_ids == b.app_ids && a.message_sequence == b.message_sequence
}

[inline]
pub fn (a CMsgClientAuthList) ne(b CMsgClientAuthList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAuthList) eq(b []CMsgClientAuthList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAuthList) ne(b []CMsgClientAuthList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientauthlist() CMsgClientAuthList {
	return CMsgClientAuthList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientauthlist(o CMsgClientAuthList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientauthlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientauthlist_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAuthListAck {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	ticket_crc       []u32
	app_ids          []u32
	message_sequence u32
}

pub fn (o &CMsgClientAuthListAck) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.ticket_crc {
		res << vproto.pack_uint32_field(x, 1)
	}
	// [packed=false]
	for _, x in o.app_ids {
		res << vproto.pack_uint32_field(x, 2)
	}
	if o.message_sequence != u32(0) {
		res << vproto.pack_uint32_field(o.message_sequence, 3)
	}
	return res
}

pub fn cmsgclientauthlistack_unpack(buf []byte) ?CMsgClientAuthListAck {
	mut res := zzz_vproto_internal_new_cmsgclientauthlistack()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.ticket_crc << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.app_ids << v
				i = ii
			}
			3 {
				i, res.message_sequence = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAuthListAck) eq(b CMsgClientAuthListAck) bool {
	return true && a.ticket_crc == b.ticket_crc && a.app_ids == b.app_ids && a.message_sequence ==
		b.message_sequence
}

[inline]
pub fn (a CMsgClientAuthListAck) ne(b CMsgClientAuthListAck) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAuthListAck) eq(b []CMsgClientAuthListAck) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAuthListAck) ne(b []CMsgClientAuthListAck) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientauthlistack() CMsgClientAuthListAck {
	return CMsgClientAuthListAck{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientauthlistack(o CMsgClientAuthListAck, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientauthlistack(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthListAck) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientauthlistack_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLicenseList_License {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	package_id            u32
	time_created          u32
	time_next_process     u32
	minute_limit          int
	minutes_used          int
	payment_method        u32
	flags                 u32
	purchase_country_code string
	license_type          u32
	territory_code        int
	change_number         int
	owner_id              u32
	initial_period        u32
	initial_time_unit     u32
	renewal_period        u32
	renewal_time_unit     u32
	access_token          u64
	master_package_id     u32
}

pub fn (o &CMsgClientLicenseList_License) pack() []byte {
	mut res := []byte{}
	if o.package_id != u32(0) {
		res << vproto.pack_uint32_field(o.package_id, 1)
	}
	if o.time_created != u32(0) {
		res << vproto.pack_32bit_field(o.time_created, 2)
	}
	if o.time_next_process != u32(0) {
		res << vproto.pack_32bit_field(o.time_next_process, 3)
	}
	if o.minute_limit != int(0) {
		res << vproto.pack_int32_field(o.minute_limit, 4)
	}
	if o.minutes_used != int(0) {
		res << vproto.pack_int32_field(o.minutes_used, 5)
	}
	if o.payment_method != u32(0) {
		res << vproto.pack_uint32_field(o.payment_method, 6)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 7)
	}
	if o.purchase_country_code != '' {
		res << vproto.pack_string_field(o.purchase_country_code, 8)
	}
	if o.license_type != u32(0) {
		res << vproto.pack_uint32_field(o.license_type, 9)
	}
	if o.territory_code != int(0) {
		res << vproto.pack_int32_field(o.territory_code, 10)
	}
	if o.change_number != int(0) {
		res << vproto.pack_int32_field(o.change_number, 11)
	}
	if o.owner_id != u32(0) {
		res << vproto.pack_uint32_field(o.owner_id, 12)
	}
	if o.initial_period != u32(0) {
		res << vproto.pack_uint32_field(o.initial_period, 13)
	}
	if o.initial_time_unit != u32(0) {
		res << vproto.pack_uint32_field(o.initial_time_unit, 14)
	}
	if o.renewal_period != u32(0) {
		res << vproto.pack_uint32_field(o.renewal_period, 15)
	}
	if o.renewal_time_unit != u32(0) {
		res << vproto.pack_uint32_field(o.renewal_time_unit, 16)
	}
	if o.access_token != u64(0) {
		res << vproto.pack_uint64_field(o.access_token, 17)
	}
	if o.master_package_id != u32(0) {
		res << vproto.pack_uint32_field(o.master_package_id, 18)
	}
	return res
}

pub fn cmsgclientlicenselist_license_unpack(buf []byte) ?CMsgClientLicenseList_License {
	mut res := zzz_vproto_internal_new_cmsgclientlicenselist_license()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.package_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.time_created = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.time_next_process = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.minute_limit = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.minutes_used = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.payment_method = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.purchase_country_code = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.license_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.territory_code = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				i, res.change_number = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			12 {
				i, res.owner_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			13 {
				i, res.initial_period = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			14 {
				i, res.initial_time_unit = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			15 {
				i, res.renewal_period = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			16 {
				i, res.renewal_time_unit = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			17 {
				i, res.access_token = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			18 {
				i, res.master_package_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLicenseList_License) eq(b CMsgClientLicenseList_License) bool {
	return true && a.package_id == b.package_id && a.time_created == b.time_created &&
		a.time_next_process == b.time_next_process && a.minute_limit == b.minute_limit && a.minutes_used ==
		b.minutes_used && a.payment_method == b.payment_method && a.flags == b.flags && a.purchase_country_code ==
		b.purchase_country_code && a.license_type == b.license_type && a.territory_code == b.territory_code &&
		a.change_number == b.change_number && a.owner_id == b.owner_id && a.initial_period == b.initial_period &&
		a.initial_time_unit == b.initial_time_unit && a.renewal_period == b.renewal_period &&
		a.renewal_time_unit == b.renewal_time_unit && a.access_token == b.access_token && a.master_package_id ==
		b.master_package_id
}

[inline]
pub fn (a CMsgClientLicenseList_License) ne(b CMsgClientLicenseList_License) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLicenseList_License) eq(b []CMsgClientLicenseList_License) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLicenseList_License) ne(b []CMsgClientLicenseList_License) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlicenselist_license() CMsgClientLicenseList_License {
	return CMsgClientLicenseList_License{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlicenselist_license(o CMsgClientLicenseList_License, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlicenselist_license(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLicenseList_License) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlicenselist_license_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLicenseList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	licenses       []CMsgClientLicenseList_License
}

pub fn (o &CMsgClientLicenseList) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.licenses {
		res << zzz_vproto_internal_pack_cmsgclientlicenselist_license(x, 2)
	}
	return res
}

pub fn cmsgclientlicenselist_unpack(buf []byte) ?CMsgClientLicenseList {
	mut res := zzz_vproto_internal_new_cmsgclientlicenselist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientlicenselist_license(cur_buf,
					tag_wiretype.wire_type) ?
				res.licenses << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLicenseList) eq(b CMsgClientLicenseList) bool {
	return true && a.eresult == b.eresult && a.licenses.eq(b.licenses)
}

[inline]
pub fn (a CMsgClientLicenseList) ne(b CMsgClientLicenseList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLicenseList) eq(b []CMsgClientLicenseList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLicenseList) ne(b []CMsgClientLicenseList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlicenselist() CMsgClientLicenseList {
	return CMsgClientLicenseList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlicenselist(o CMsgClientLicenseList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlicenselist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLicenseList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlicenselist_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLBSSetScore {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	app_id              u32
	leaderboard_id      int
	score               int
	details             []byte
	upload_score_method int
}

pub fn (o &CMsgClientLBSSetScore) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.leaderboard_id != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_id, 2)
	}
	if o.score != int(0) {
		res << vproto.pack_int32_field(o.score, 3)
	}
	if o.details != []byte{} {
		res << vproto.pack_bytes_field(o.details, 4)
	}
	if o.upload_score_method != int(0) {
		res << vproto.pack_int32_field(o.upload_score_method, 5)
	}
	return res
}

pub fn cmsgclientlbssetscore_unpack(buf []byte) ?CMsgClientLBSSetScore {
	mut res := zzz_vproto_internal_new_cmsgclientlbssetscore()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.leaderboard_id = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.score = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.details = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.upload_score_method = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLBSSetScore) eq(b CMsgClientLBSSetScore) bool {
	return true && a.app_id == b.app_id && a.leaderboard_id == b.leaderboard_id && a.score ==
		b.score && a.details == b.details && a.upload_score_method == b.upload_score_method
}

[inline]
pub fn (a CMsgClientLBSSetScore) ne(b CMsgClientLBSSetScore) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLBSSetScore) eq(b []CMsgClientLBSSetScore) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLBSSetScore) ne(b []CMsgClientLBSSetScore) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlbssetscore() CMsgClientLBSSetScore {
	return CMsgClientLBSSetScore{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlbssetscore(o CMsgClientLBSSetScore, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetscore(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSSetScore) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlbssetscore_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLBSSetScoreResponse {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	eresult                 int = 2
	leaderboard_entry_count int
	score_changed           bool
	global_rank_previous    int
	global_rank_new         int
}

pub fn (o &CMsgClientLBSSetScoreResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.leaderboard_entry_count != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_entry_count, 2)
	}
	if o.score_changed != false {
		res << vproto.pack_bool_field(o.score_changed, 3)
	}
	if o.global_rank_previous != int(0) {
		res << vproto.pack_int32_field(o.global_rank_previous, 4)
	}
	if o.global_rank_new != int(0) {
		res << vproto.pack_int32_field(o.global_rank_new, 5)
	}
	return res
}

pub fn cmsgclientlbssetscoreresponse_unpack(buf []byte) ?CMsgClientLBSSetScoreResponse {
	mut res := zzz_vproto_internal_new_cmsgclientlbssetscoreresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.leaderboard_entry_count = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.score_changed = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.global_rank_previous = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.global_rank_new = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLBSSetScoreResponse) eq(b CMsgClientLBSSetScoreResponse) bool {
	return true && a.eresult == b.eresult && a.leaderboard_entry_count == b.leaderboard_entry_count &&
		a.score_changed == b.score_changed && a.global_rank_previous == b.global_rank_previous &&
		a.global_rank_new == b.global_rank_new
}

[inline]
pub fn (a CMsgClientLBSSetScoreResponse) ne(b CMsgClientLBSSetScoreResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLBSSetScoreResponse) eq(b []CMsgClientLBSSetScoreResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLBSSetScoreResponse) ne(b []CMsgClientLBSSetScoreResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlbssetscoreresponse() CMsgClientLBSSetScoreResponse {
	return CMsgClientLBSSetScoreResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlbssetscoreresponse(o CMsgClientLBSSetScoreResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetscoreresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSSetScoreResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlbssetscoreresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLBSSetUGC {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	leaderboard_id int
	ugc_id         u64
}

pub fn (o &CMsgClientLBSSetUGC) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.leaderboard_id != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_id, 2)
	}
	if o.ugc_id != u64(0) {
		res << vproto.pack_64bit_field(o.ugc_id, 3)
	}
	return res
}

pub fn cmsgclientlbssetugc_unpack(buf []byte) ?CMsgClientLBSSetUGC {
	mut res := zzz_vproto_internal_new_cmsgclientlbssetugc()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.leaderboard_id = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.ugc_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLBSSetUGC) eq(b CMsgClientLBSSetUGC) bool {
	return true && a.app_id == b.app_id && a.leaderboard_id == b.leaderboard_id && a.ugc_id ==
		b.ugc_id
}

[inline]
pub fn (a CMsgClientLBSSetUGC) ne(b CMsgClientLBSSetUGC) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLBSSetUGC) eq(b []CMsgClientLBSSetUGC) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLBSSetUGC) ne(b []CMsgClientLBSSetUGC) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlbssetugc() CMsgClientLBSSetUGC {
	return CMsgClientLBSSetUGC{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlbssetugc(o CMsgClientLBSSetUGC, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetugc(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSSetUGC) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlbssetugc_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLBSSetUGCResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
}

pub fn (o &CMsgClientLBSSetUGCResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientlbssetugcresponse_unpack(buf []byte) ?CMsgClientLBSSetUGCResponse {
	mut res := zzz_vproto_internal_new_cmsgclientlbssetugcresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLBSSetUGCResponse) eq(b CMsgClientLBSSetUGCResponse) bool {
	return true && a.eresult == b.eresult
}

[inline]
pub fn (a CMsgClientLBSSetUGCResponse) ne(b CMsgClientLBSSetUGCResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLBSSetUGCResponse) eq(b []CMsgClientLBSSetUGCResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLBSSetUGCResponse) ne(b []CMsgClientLBSSetUGCResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlbssetugcresponse() CMsgClientLBSSetUGCResponse {
	return CMsgClientLBSSetUGCResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlbssetugcresponse(o CMsgClientLBSSetUGCResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetugcresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSSetUGCResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlbssetugcresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLBSFindOrCreateLB {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	app_id                   u32
	leaderboard_sort_method  int
	leaderboard_display_type int
	create_if_not_found      bool
	leaderboard_name         string
}

pub fn (o &CMsgClientLBSFindOrCreateLB) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.leaderboard_sort_method != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_sort_method, 2)
	}
	if o.leaderboard_display_type != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_display_type, 3)
	}
	if o.create_if_not_found != false {
		res << vproto.pack_bool_field(o.create_if_not_found, 4)
	}
	if o.leaderboard_name != '' {
		res << vproto.pack_string_field(o.leaderboard_name, 5)
	}
	return res
}

pub fn cmsgclientlbsfindorcreatelb_unpack(buf []byte) ?CMsgClientLBSFindOrCreateLB {
	mut res := zzz_vproto_internal_new_cmsgclientlbsfindorcreatelb()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.leaderboard_sort_method = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.leaderboard_display_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.create_if_not_found = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.leaderboard_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLBSFindOrCreateLB) eq(b CMsgClientLBSFindOrCreateLB) bool {
	return true && a.app_id == b.app_id && a.leaderboard_sort_method == b.leaderboard_sort_method &&
		a.leaderboard_display_type == b.leaderboard_display_type && a.create_if_not_found == b.create_if_not_found &&
		a.leaderboard_name == b.leaderboard_name
}

[inline]
pub fn (a CMsgClientLBSFindOrCreateLB) ne(b CMsgClientLBSFindOrCreateLB) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLBSFindOrCreateLB) eq(b []CMsgClientLBSFindOrCreateLB) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLBSFindOrCreateLB) ne(b []CMsgClientLBSFindOrCreateLB) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlbsfindorcreatelb() CMsgClientLBSFindOrCreateLB {
	return CMsgClientLBSFindOrCreateLB{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlbsfindorcreatelb(o CMsgClientLBSFindOrCreateLB, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlbsfindorcreatelb(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSFindOrCreateLB) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlbsfindorcreatelb_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLBSFindOrCreateLBResponse {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	eresult                  int = 2
	leaderboard_id           int
	leaderboard_entry_count  int
	leaderboard_sort_method  int
	leaderboard_display_type int
	leaderboard_name         string
}

pub fn (o &CMsgClientLBSFindOrCreateLBResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.leaderboard_id != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_id, 2)
	}
	if o.leaderboard_entry_count != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_entry_count, 3)
	}
	if o.leaderboard_sort_method != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_sort_method, 4)
	}
	if o.leaderboard_display_type != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_display_type, 5)
	}
	if o.leaderboard_name != '' {
		res << vproto.pack_string_field(o.leaderboard_name, 6)
	}
	return res
}

pub fn cmsgclientlbsfindorcreatelbresponse_unpack(buf []byte) ?CMsgClientLBSFindOrCreateLBResponse {
	mut res := zzz_vproto_internal_new_cmsgclientlbsfindorcreatelbresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.leaderboard_id = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.leaderboard_entry_count = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.leaderboard_sort_method = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.leaderboard_display_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.leaderboard_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLBSFindOrCreateLBResponse) eq(b CMsgClientLBSFindOrCreateLBResponse) bool {
	return true && a.eresult == b.eresult && a.leaderboard_id == b.leaderboard_id && a.leaderboard_entry_count ==
		b.leaderboard_entry_count && a.leaderboard_sort_method == b.leaderboard_sort_method &&
		a.leaderboard_display_type == b.leaderboard_display_type && a.leaderboard_name == b.leaderboard_name
}

[inline]
pub fn (a CMsgClientLBSFindOrCreateLBResponse) ne(b CMsgClientLBSFindOrCreateLBResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLBSFindOrCreateLBResponse) eq(b []CMsgClientLBSFindOrCreateLBResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLBSFindOrCreateLBResponse) ne(b []CMsgClientLBSFindOrCreateLBResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlbsfindorcreatelbresponse() CMsgClientLBSFindOrCreateLBResponse {
	return CMsgClientLBSFindOrCreateLBResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlbsfindorcreatelbresponse(o CMsgClientLBSFindOrCreateLBResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlbsfindorcreatelbresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSFindOrCreateLBResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlbsfindorcreatelbresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLBSGetLBEntries {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	app_id                   int
	leaderboard_id           int
	range_start              int
	range_end                int
	leaderboard_data_request int
	steamids                 []u64
}

pub fn (o &CMsgClientLBSGetLBEntries) pack() []byte {
	mut res := []byte{}
	if o.app_id != int(0) {
		res << vproto.pack_int32_field(o.app_id, 1)
	}
	if o.leaderboard_id != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_id, 2)
	}
	if o.range_start != int(0) {
		res << vproto.pack_int32_field(o.range_start, 3)
	}
	if o.range_end != int(0) {
		res << vproto.pack_int32_field(o.range_end, 4)
	}
	if o.leaderboard_data_request != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_data_request, 5)
	}
	// [packed=false]
	for _, x in o.steamids {
		res << vproto.pack_64bit_field(x, 6)
	}
	return res
}

pub fn cmsgclientlbsgetlbentries_unpack(buf []byte) ?CMsgClientLBSGetLBEntries {
	mut res := zzz_vproto_internal_new_cmsgclientlbsgetlbentries()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.leaderboard_id = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.range_start = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.range_end = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.leaderboard_data_request = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLBSGetLBEntries) eq(b CMsgClientLBSGetLBEntries) bool {
	return true && a.app_id == b.app_id && a.leaderboard_id == b.leaderboard_id && a.range_start ==
		b.range_start && a.range_end == b.range_end && a.leaderboard_data_request == b.leaderboard_data_request &&
		a.steamids == b.steamids
}

[inline]
pub fn (a CMsgClientLBSGetLBEntries) ne(b CMsgClientLBSGetLBEntries) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLBSGetLBEntries) eq(b []CMsgClientLBSGetLBEntries) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLBSGetLBEntries) ne(b []CMsgClientLBSGetLBEntries) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlbsgetlbentries() CMsgClientLBSGetLBEntries {
	return CMsgClientLBSGetLBEntries{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlbsgetlbentries(o CMsgClientLBSGetLBEntries, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlbsgetlbentries(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSGetLBEntries) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlbsgetlbentries_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLBSGetLBEntriesResponse_Entry {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id_user  u64
	global_rank    int
	score          int
	details        []byte
	ugc_id         u64
}

pub fn (o &CMsgClientLBSGetLBEntriesResponse_Entry) pack() []byte {
	mut res := []byte{}
	if o.steam_id_user != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_user, 1)
	}
	if o.global_rank != int(0) {
		res << vproto.pack_int32_field(o.global_rank, 2)
	}
	if o.score != int(0) {
		res << vproto.pack_int32_field(o.score, 3)
	}
	if o.details != []byte{} {
		res << vproto.pack_bytes_field(o.details, 4)
	}
	if o.ugc_id != u64(0) {
		res << vproto.pack_64bit_field(o.ugc_id, 5)
	}
	return res
}

pub fn cmsgclientlbsgetlbentriesresponse_entry_unpack(buf []byte) ?CMsgClientLBSGetLBEntriesResponse_Entry {
	mut res := zzz_vproto_internal_new_cmsgclientlbsgetlbentriesresponse_entry()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id_user = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.global_rank = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.score = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.details = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.ugc_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLBSGetLBEntriesResponse_Entry) eq(b CMsgClientLBSGetLBEntriesResponse_Entry) bool {
	return true && a.steam_id_user == b.steam_id_user && a.global_rank == b.global_rank &&
		a.score == b.score && a.details == b.details && a.ugc_id == b.ugc_id
}

[inline]
pub fn (a CMsgClientLBSGetLBEntriesResponse_Entry) ne(b CMsgClientLBSGetLBEntriesResponse_Entry) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLBSGetLBEntriesResponse_Entry) eq(b []CMsgClientLBSGetLBEntriesResponse_Entry) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLBSGetLBEntriesResponse_Entry) ne(b []CMsgClientLBSGetLBEntriesResponse_Entry) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlbsgetlbentriesresponse_entry() CMsgClientLBSGetLBEntriesResponse_Entry {
	return CMsgClientLBSGetLBEntriesResponse_Entry{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlbsgetlbentriesresponse_entry(o CMsgClientLBSGetLBEntriesResponse_Entry, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlbsgetlbentriesresponse_entry(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSGetLBEntriesResponse_Entry) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlbsgetlbentriesresponse_entry_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientLBSGetLBEntriesResponse {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	eresult                 int = 2
	leaderboard_entry_count int
	entries                 []CMsgClientLBSGetLBEntriesResponse_Entry
}

pub fn (o &CMsgClientLBSGetLBEntriesResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.leaderboard_entry_count != int(0) {
		res << vproto.pack_int32_field(o.leaderboard_entry_count, 2)
	}
	// [packed=false]
	for _, x in o.entries {
		res << zzz_vproto_internal_pack_cmsgclientlbsgetlbentriesresponse_entry(x, 3)
	}
	return res
}

pub fn cmsgclientlbsgetlbentriesresponse_unpack(buf []byte) ?CMsgClientLBSGetLBEntriesResponse {
	mut res := zzz_vproto_internal_new_cmsgclientlbsgetlbentriesresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.leaderboard_entry_count = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientlbsgetlbentriesresponse_entry(cur_buf,
					tag_wiretype.wire_type) ?
				res.entries << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientLBSGetLBEntriesResponse) eq(b CMsgClientLBSGetLBEntriesResponse) bool {
	return true && a.eresult == b.eresult && a.leaderboard_entry_count == b.leaderboard_entry_count &&
		a.entries.eq(b.entries)
}

[inline]
pub fn (a CMsgClientLBSGetLBEntriesResponse) ne(b CMsgClientLBSGetLBEntriesResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientLBSGetLBEntriesResponse) eq(b []CMsgClientLBSGetLBEntriesResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientLBSGetLBEntriesResponse) ne(b []CMsgClientLBSGetLBEntriesResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientlbsgetlbentriesresponse() CMsgClientLBSGetLBEntriesResponse {
	return CMsgClientLBSGetLBEntriesResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientlbsgetlbentriesresponse(o CMsgClientLBSGetLBEntriesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientlbsgetlbentriesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSGetLBEntriesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientlbsgetlbentriesresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	forever        int
	last_two_weeks int
}

pub fn (o &CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.forever != int(0) {
		res << vproto.pack_int32_field(o.forever, 2)
	}
	if o.last_two_weeks != int(0) {
		res << vproto.pack_int32_field(o.last_two_weeks, 3)
	}
	return res
}

pub fn cmsgclientappminutesplayeddata_appminutesplayeddata_unpack(buf []byte) ?CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
	mut res := zzz_vproto_internal_new_cmsgclientappminutesplayeddata_appminutesplayeddata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.forever = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.last_two_weeks = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) eq(b CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) bool {
	return true && a.app_id == b.app_id && a.forever == b.forever && a.last_two_weeks == b.last_two_weeks
}

[inline]
pub fn (a CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) ne(b CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) eq(b []CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) ne(b []CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientappminutesplayeddata_appminutesplayeddata() CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
	return CMsgClientAppMinutesPlayedData_AppMinutesPlayedData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientappminutesplayeddata_appminutesplayeddata(o CMsgClientAppMinutesPlayedData_AppMinutesPlayedData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientappminutesplayeddata_appminutesplayeddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientappminutesplayeddata_appminutesplayeddata_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAppMinutesPlayedData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	minutes_played []CMsgClientAppMinutesPlayedData_AppMinutesPlayedData
}

pub fn (o &CMsgClientAppMinutesPlayedData) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.minutes_played {
		res <<
			zzz_vproto_internal_pack_cmsgclientappminutesplayeddata_appminutesplayeddata(x, 1)
	}
	return res
}

pub fn cmsgclientappminutesplayeddata_unpack(buf []byte) ?CMsgClientAppMinutesPlayedData {
	mut res := zzz_vproto_internal_new_cmsgclientappminutesplayeddata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientappminutesplayeddata_appminutesplayeddata(cur_buf,
					tag_wiretype.wire_type) ?
				res.minutes_played << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAppMinutesPlayedData) eq(b CMsgClientAppMinutesPlayedData) bool {
	return true && a.minutes_played.eq(b.minutes_played)
}

[inline]
pub fn (a CMsgClientAppMinutesPlayedData) ne(b CMsgClientAppMinutesPlayedData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAppMinutesPlayedData) eq(b []CMsgClientAppMinutesPlayedData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAppMinutesPlayedData) ne(b []CMsgClientAppMinutesPlayedData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientappminutesplayeddata() CMsgClientAppMinutesPlayedData {
	return CMsgClientAppMinutesPlayedData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientappminutesplayeddata(o CMsgClientAppMinutesPlayedData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientappminutesplayeddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppMinutesPlayedData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientappminutesplayeddata_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientIsLimitedAccount {
mut:
	unknown_fields                                []vproto.UnknownField
pub mut:
	bis_limited_account                           bool
	bis_community_banned                          bool
	bis_locked_account                            bool
	bis_limited_account_allowed_to_invite_friends bool
}

pub fn (o &CMsgClientIsLimitedAccount) pack() []byte {
	mut res := []byte{}
	if o.bis_limited_account != false {
		res << vproto.pack_bool_field(o.bis_limited_account, 1)
	}
	if o.bis_community_banned != false {
		res << vproto.pack_bool_field(o.bis_community_banned, 2)
	}
	if o.bis_locked_account != false {
		res << vproto.pack_bool_field(o.bis_locked_account, 3)
	}
	if o.bis_limited_account_allowed_to_invite_friends != false {
		res <<
			vproto.pack_bool_field(o.bis_limited_account_allowed_to_invite_friends, 4)
	}
	return res
}

pub fn cmsgclientislimitedaccount_unpack(buf []byte) ?CMsgClientIsLimitedAccount {
	mut res := zzz_vproto_internal_new_cmsgclientislimitedaccount()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.bis_limited_account = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.bis_community_banned = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.bis_locked_account = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.bis_limited_account_allowed_to_invite_friends = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientIsLimitedAccount) eq(b CMsgClientIsLimitedAccount) bool {
	return true && a.bis_limited_account == b.bis_limited_account && a.bis_community_banned ==
		b.bis_community_banned && a.bis_locked_account == b.bis_locked_account && a.bis_limited_account_allowed_to_invite_friends ==
		b.bis_limited_account_allowed_to_invite_friends
}

[inline]
pub fn (a CMsgClientIsLimitedAccount) ne(b CMsgClientIsLimitedAccount) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientIsLimitedAccount) eq(b []CMsgClientIsLimitedAccount) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientIsLimitedAccount) ne(b []CMsgClientIsLimitedAccount) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientislimitedaccount() CMsgClientIsLimitedAccount {
	return CMsgClientIsLimitedAccount{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientislimitedaccount(o CMsgClientIsLimitedAccount, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientislimitedaccount(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientIsLimitedAccount) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientislimitedaccount_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRequestedClientStats_StatsToSend {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	client_stat           u32
	stat_aggregate_method u32
}

pub fn (o &CMsgClientRequestedClientStats_StatsToSend) pack() []byte {
	mut res := []byte{}
	if o.client_stat != u32(0) {
		res << vproto.pack_uint32_field(o.client_stat, 1)
	}
	if o.stat_aggregate_method != u32(0) {
		res << vproto.pack_uint32_field(o.stat_aggregate_method, 2)
	}
	return res
}

pub fn cmsgclientrequestedclientstats_statstosend_unpack(buf []byte) ?CMsgClientRequestedClientStats_StatsToSend {
	mut res := zzz_vproto_internal_new_cmsgclientrequestedclientstats_statstosend()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.client_stat = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.stat_aggregate_method = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRequestedClientStats_StatsToSend) eq(b CMsgClientRequestedClientStats_StatsToSend) bool {
	return true && a.client_stat == b.client_stat && a.stat_aggregate_method == b.stat_aggregate_method
}

[inline]
pub fn (a CMsgClientRequestedClientStats_StatsToSend) ne(b CMsgClientRequestedClientStats_StatsToSend) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRequestedClientStats_StatsToSend) eq(b []CMsgClientRequestedClientStats_StatsToSend) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRequestedClientStats_StatsToSend) ne(b []CMsgClientRequestedClientStats_StatsToSend) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientrequestedclientstats_statstosend() CMsgClientRequestedClientStats_StatsToSend {
	return CMsgClientRequestedClientStats_StatsToSend{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientrequestedclientstats_statstosend(o CMsgClientRequestedClientStats_StatsToSend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientrequestedclientstats_statstosend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestedClientStats_StatsToSend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientrequestedclientstats_statstosend_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRequestedClientStats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stats_to_send  []CMsgClientRequestedClientStats_StatsToSend
}

pub fn (o &CMsgClientRequestedClientStats) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.stats_to_send {
		res <<
			zzz_vproto_internal_pack_cmsgclientrequestedclientstats_statstosend(x, 1)
	}
	return res
}

pub fn cmsgclientrequestedclientstats_unpack(buf []byte) ?CMsgClientRequestedClientStats {
	mut res := zzz_vproto_internal_new_cmsgclientrequestedclientstats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientrequestedclientstats_statstosend(cur_buf,
					tag_wiretype.wire_type) ?
				res.stats_to_send << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRequestedClientStats) eq(b CMsgClientRequestedClientStats) bool {
	return true && a.stats_to_send.eq(b.stats_to_send)
}

[inline]
pub fn (a CMsgClientRequestedClientStats) ne(b CMsgClientRequestedClientStats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRequestedClientStats) eq(b []CMsgClientRequestedClientStats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRequestedClientStats) ne(b []CMsgClientRequestedClientStats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientrequestedclientstats() CMsgClientRequestedClientStats {
	return CMsgClientRequestedClientStats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientrequestedclientstats(o CMsgClientRequestedClientStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientrequestedclientstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestedClientStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientrequestedclientstats_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientStat2_StatDetail {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	client_stat    u32
	ll_value       i64
	time_of_day    u32
	cell_id        u32
	depot_id       u32
	app_id         u32
}

pub fn (o &CMsgClientStat2_StatDetail) pack() []byte {
	mut res := []byte{}
	if o.client_stat != u32(0) {
		res << vproto.pack_uint32_field(o.client_stat, 1)
	}
	if o.ll_value != i64(0) {
		res << vproto.pack_int64_field(o.ll_value, 2)
	}
	if o.time_of_day != u32(0) {
		res << vproto.pack_uint32_field(o.time_of_day, 3)
	}
	if o.cell_id != u32(0) {
		res << vproto.pack_uint32_field(o.cell_id, 4)
	}
	if o.depot_id != u32(0) {
		res << vproto.pack_uint32_field(o.depot_id, 5)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 6)
	}
	return res
}

pub fn cmsgclientstat2_statdetail_unpack(buf []byte) ?CMsgClientStat2_StatDetail {
	mut res := zzz_vproto_internal_new_cmsgclientstat2_statdetail()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.client_stat = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.ll_value = vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.time_of_day = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.cell_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.depot_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientStat2_StatDetail) eq(b CMsgClientStat2_StatDetail) bool {
	return true && a.client_stat == b.client_stat && a.ll_value == b.ll_value && a.time_of_day ==
		b.time_of_day && a.cell_id == b.cell_id && a.depot_id == b.depot_id && a.app_id == b.app_id
}

[inline]
pub fn (a CMsgClientStat2_StatDetail) ne(b CMsgClientStat2_StatDetail) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientStat2_StatDetail) eq(b []CMsgClientStat2_StatDetail) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientStat2_StatDetail) ne(b []CMsgClientStat2_StatDetail) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientstat2_statdetail() CMsgClientStat2_StatDetail {
	return CMsgClientStat2_StatDetail{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientstat2_statdetail(o CMsgClientStat2_StatDetail, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientstat2_statdetail(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStat2_StatDetail) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientstat2_statdetail_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientStat2 {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_detail    []CMsgClientStat2_StatDetail
}

pub fn (o &CMsgClientStat2) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.stat_detail {
		res << zzz_vproto_internal_pack_cmsgclientstat2_statdetail(x, 1)
	}
	return res
}

pub fn cmsgclientstat2_unpack(buf []byte) ?CMsgClientStat2 {
	mut res := zzz_vproto_internal_new_cmsgclientstat2()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientstat2_statdetail(cur_buf,
					tag_wiretype.wire_type) ?
				res.stat_detail << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientStat2) eq(b CMsgClientStat2) bool {
	return true && a.stat_detail.eq(b.stat_detail)
}

[inline]
pub fn (a CMsgClientStat2) ne(b CMsgClientStat2) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientStat2) eq(b []CMsgClientStat2) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientStat2) ne(b []CMsgClientStat2) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientstat2() CMsgClientStat2 {
	return CMsgClientStat2{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientstat2(o CMsgClientStat2, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientstat2(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStat2) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientstat2_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSSetRatelimitPolicyOnClient {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	app_id                       u32
	enable_rate_limits           bool
	seconds_per_message          int
	milliseconds_per_data_update int
}

pub fn (o &CMsgClientMMSSetRatelimitPolicyOnClient) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.enable_rate_limits != false {
		res << vproto.pack_bool_field(o.enable_rate_limits, 2)
	}
	if o.seconds_per_message != int(0) {
		res << vproto.pack_int32_field(o.seconds_per_message, 3)
	}
	if o.milliseconds_per_data_update != int(0) {
		res << vproto.pack_int32_field(o.milliseconds_per_data_update, 4)
	}
	return res
}

pub fn cmsgclientmmssetratelimitpolicyonclient_unpack(buf []byte) ?CMsgClientMMSSetRatelimitPolicyOnClient {
	mut res := zzz_vproto_internal_new_cmsgclientmmssetratelimitpolicyonclient()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.enable_rate_limits = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.seconds_per_message = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.milliseconds_per_data_update = vproto.unpack_int32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSSetRatelimitPolicyOnClient) eq(b CMsgClientMMSSetRatelimitPolicyOnClient) bool {
	return true && a.app_id == b.app_id && a.enable_rate_limits == b.enable_rate_limits &&
		a.seconds_per_message == b.seconds_per_message && a.milliseconds_per_data_update == b.milliseconds_per_data_update
}

[inline]
pub fn (a CMsgClientMMSSetRatelimitPolicyOnClient) ne(b CMsgClientMMSSetRatelimitPolicyOnClient) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSSetRatelimitPolicyOnClient) eq(b []CMsgClientMMSSetRatelimitPolicyOnClient) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSSetRatelimitPolicyOnClient) ne(b []CMsgClientMMSSetRatelimitPolicyOnClient) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmssetratelimitpolicyonclient() CMsgClientMMSSetRatelimitPolicyOnClient {
	return CMsgClientMMSSetRatelimitPolicyOnClient{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmssetratelimitpolicyonclient(o CMsgClientMMSSetRatelimitPolicyOnClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetratelimitpolicyonclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetRatelimitPolicyOnClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmssetratelimitpolicyonclient_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSCreateLobby {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	app_id               u32
	max_members          int
	lobby_type           int
	lobby_flags          int
	cell_id              u32
	deprecated_public_ip u32
	metadata             []byte
	persona_name_owner   string
	public_ip            CMsgIPAddress
}

pub fn (o &CMsgClientMMSCreateLobby) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.max_members != int(0) {
		res << vproto.pack_int32_field(o.max_members, 2)
	}
	if o.lobby_type != int(0) {
		res << vproto.pack_int32_field(o.lobby_type, 3)
	}
	if o.lobby_flags != int(0) {
		res << vproto.pack_int32_field(o.lobby_flags, 4)
	}
	if o.cell_id != u32(0) {
		res << vproto.pack_uint32_field(o.cell_id, 5)
	}
	if o.deprecated_public_ip != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 6)
	}
	if o.metadata != []byte{} {
		res << vproto.pack_bytes_field(o.metadata, 7)
	}
	if o.persona_name_owner != '' {
		res << vproto.pack_string_field(o.persona_name_owner, 8)
	}
	if o.public_ip.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 9)
	}
	return res
}

pub fn cmsgclientmmscreatelobby_unpack(buf []byte) ?CMsgClientMMSCreateLobby {
	mut res := zzz_vproto_internal_new_cmsgclientmmscreatelobby()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.max_members = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.lobby_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.lobby_flags = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.cell_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.deprecated_public_ip = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.metadata = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.persona_name_owner = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.public_ip = zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSCreateLobby) eq(b CMsgClientMMSCreateLobby) bool {
	return true && a.app_id == b.app_id && a.max_members == b.max_members && a.lobby_type == b.lobby_type &&
		a.lobby_flags == b.lobby_flags && a.cell_id == b.cell_id && a.deprecated_public_ip == b.deprecated_public_ip &&
		a.metadata == b.metadata && a.persona_name_owner == b.persona_name_owner && a.public_ip.eq(b.public_ip)
}

[inline]
pub fn (a CMsgClientMMSCreateLobby) ne(b CMsgClientMMSCreateLobby) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSCreateLobby) eq(b []CMsgClientMMSCreateLobby) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSCreateLobby) ne(b []CMsgClientMMSCreateLobby) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmscreatelobby() CMsgClientMMSCreateLobby {
	return CMsgClientMMSCreateLobby{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmscreatelobby(o CMsgClientMMSCreateLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmscreatelobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSCreateLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmscreatelobby_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSCreateLobbyResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steam_id_lobby u64
	eresult        int = 2
}

pub fn (o &CMsgClientMMSCreateLobbyResponse) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	return res
}

pub fn cmsgclientmmscreatelobbyresponse_unpack(buf []byte) ?CMsgClientMMSCreateLobbyResponse {
	mut res := zzz_vproto_internal_new_cmsgclientmmscreatelobbyresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSCreateLobbyResponse) eq(b CMsgClientMMSCreateLobbyResponse) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.eresult ==
		b.eresult
}

[inline]
pub fn (a CMsgClientMMSCreateLobbyResponse) ne(b CMsgClientMMSCreateLobbyResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSCreateLobbyResponse) eq(b []CMsgClientMMSCreateLobbyResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSCreateLobbyResponse) ne(b []CMsgClientMMSCreateLobbyResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmscreatelobbyresponse() CMsgClientMMSCreateLobbyResponse {
	return CMsgClientMMSCreateLobbyResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmscreatelobbyresponse(o CMsgClientMMSCreateLobbyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmscreatelobbyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSCreateLobbyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmscreatelobbyresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSJoinLobby {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steam_id_lobby u64
	persona_name   string
}

pub fn (o &CMsgClientMMSJoinLobby) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.persona_name != '' {
		res << vproto.pack_string_field(o.persona_name, 3)
	}
	return res
}

pub fn cmsgclientmmsjoinlobby_unpack(buf []byte) ?CMsgClientMMSJoinLobby {
	mut res := zzz_vproto_internal_new_cmsgclientmmsjoinlobby()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.persona_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSJoinLobby) eq(b CMsgClientMMSJoinLobby) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.persona_name ==
		b.persona_name
}

[inline]
pub fn (a CMsgClientMMSJoinLobby) ne(b CMsgClientMMSJoinLobby) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSJoinLobby) eq(b []CMsgClientMMSJoinLobby) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSJoinLobby) ne(b []CMsgClientMMSJoinLobby) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsjoinlobby() CMsgClientMMSJoinLobby {
	return CMsgClientMMSJoinLobby{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsjoinlobby(o CMsgClientMMSJoinLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsjoinlobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSJoinLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsjoinlobby_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSJoinLobbyResponse_Member {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	persona_name   string
	metadata       []byte
}

pub fn (o &CMsgClientMMSJoinLobbyResponse_Member) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.persona_name != '' {
		res << vproto.pack_string_field(o.persona_name, 2)
	}
	if o.metadata != []byte{} {
		res << vproto.pack_bytes_field(o.metadata, 3)
	}
	return res
}

pub fn cmsgclientmmsjoinlobbyresponse_member_unpack(buf []byte) ?CMsgClientMMSJoinLobbyResponse_Member {
	mut res := zzz_vproto_internal_new_cmsgclientmmsjoinlobbyresponse_member()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.persona_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.metadata = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSJoinLobbyResponse_Member) eq(b CMsgClientMMSJoinLobbyResponse_Member) bool {
	return true && a.steam_id == b.steam_id && a.persona_name == b.persona_name && a.metadata ==
		b.metadata
}

[inline]
pub fn (a CMsgClientMMSJoinLobbyResponse_Member) ne(b CMsgClientMMSJoinLobbyResponse_Member) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSJoinLobbyResponse_Member) eq(b []CMsgClientMMSJoinLobbyResponse_Member) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSJoinLobbyResponse_Member) ne(b []CMsgClientMMSJoinLobbyResponse_Member) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsjoinlobbyresponse_member() CMsgClientMMSJoinLobbyResponse_Member {
	return CMsgClientMMSJoinLobbyResponse_Member{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsjoinlobbyresponse_member(o CMsgClientMMSJoinLobbyResponse_Member, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsjoinlobbyresponse_member(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSJoinLobbyResponse_Member) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsjoinlobbyresponse_member_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSJoinLobbyResponse {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	app_id                   u32
	steam_id_lobby           u64
	chat_room_enter_response int
	max_members              int
	lobby_type               int
	lobby_flags              int
	steam_id_owner           u64
	metadata                 []byte
	members                  []CMsgClientMMSJoinLobbyResponse_Member
}

pub fn (o &CMsgClientMMSJoinLobbyResponse) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.chat_room_enter_response != int(0) {
		res << vproto.pack_int32_field(o.chat_room_enter_response, 3)
	}
	if o.max_members != int(0) {
		res << vproto.pack_int32_field(o.max_members, 4)
	}
	if o.lobby_type != int(0) {
		res << vproto.pack_int32_field(o.lobby_type, 5)
	}
	if o.lobby_flags != int(0) {
		res << vproto.pack_int32_field(o.lobby_flags, 6)
	}
	if o.steam_id_owner != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_owner, 7)
	}
	if o.metadata != []byte{} {
		res << vproto.pack_bytes_field(o.metadata, 8)
	}
	// [packed=false]
	for _, x in o.members {
		res << zzz_vproto_internal_pack_cmsgclientmmsjoinlobbyresponse_member(x, 9)
	}
	return res
}

pub fn cmsgclientmmsjoinlobbyresponse_unpack(buf []byte) ?CMsgClientMMSJoinLobbyResponse {
	mut res := zzz_vproto_internal_new_cmsgclientmmsjoinlobbyresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.chat_room_enter_response = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.max_members = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.lobby_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.lobby_flags = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.steam_id_owner = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.metadata = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientmmsjoinlobbyresponse_member(cur_buf,
					tag_wiretype.wire_type) ?
				res.members << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSJoinLobbyResponse) eq(b CMsgClientMMSJoinLobbyResponse) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.chat_room_enter_response ==
		b.chat_room_enter_response && a.max_members == b.max_members && a.lobby_type == b.lobby_type &&
		a.lobby_flags == b.lobby_flags && a.steam_id_owner == b.steam_id_owner && a.metadata == b.metadata &&
		a.members.eq(b.members)
}

[inline]
pub fn (a CMsgClientMMSJoinLobbyResponse) ne(b CMsgClientMMSJoinLobbyResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSJoinLobbyResponse) eq(b []CMsgClientMMSJoinLobbyResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSJoinLobbyResponse) ne(b []CMsgClientMMSJoinLobbyResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsjoinlobbyresponse() CMsgClientMMSJoinLobbyResponse {
	return CMsgClientMMSJoinLobbyResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsjoinlobbyresponse(o CMsgClientMMSJoinLobbyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsjoinlobbyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSJoinLobbyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsjoinlobbyresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSLeaveLobby {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steam_id_lobby u64
}

pub fn (o &CMsgClientMMSLeaveLobby) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	return res
}

pub fn cmsgclientmmsleavelobby_unpack(buf []byte) ?CMsgClientMMSLeaveLobby {
	mut res := zzz_vproto_internal_new_cmsgclientmmsleavelobby()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSLeaveLobby) eq(b CMsgClientMMSLeaveLobby) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby
}

[inline]
pub fn (a CMsgClientMMSLeaveLobby) ne(b CMsgClientMMSLeaveLobby) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSLeaveLobby) eq(b []CMsgClientMMSLeaveLobby) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSLeaveLobby) ne(b []CMsgClientMMSLeaveLobby) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsleavelobby() CMsgClientMMSLeaveLobby {
	return CMsgClientMMSLeaveLobby{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsleavelobby(o CMsgClientMMSLeaveLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsleavelobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLeaveLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsleavelobby_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSLeaveLobbyResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steam_id_lobby u64
	eresult        int = 2
}

pub fn (o &CMsgClientMMSLeaveLobbyResponse) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	return res
}

pub fn cmsgclientmmsleavelobbyresponse_unpack(buf []byte) ?CMsgClientMMSLeaveLobbyResponse {
	mut res := zzz_vproto_internal_new_cmsgclientmmsleavelobbyresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSLeaveLobbyResponse) eq(b CMsgClientMMSLeaveLobbyResponse) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.eresult ==
		b.eresult
}

[inline]
pub fn (a CMsgClientMMSLeaveLobbyResponse) ne(b CMsgClientMMSLeaveLobbyResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSLeaveLobbyResponse) eq(b []CMsgClientMMSLeaveLobbyResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSLeaveLobbyResponse) ne(b []CMsgClientMMSLeaveLobbyResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsleavelobbyresponse() CMsgClientMMSLeaveLobbyResponse {
	return CMsgClientMMSLeaveLobbyResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsleavelobbyresponse(o CMsgClientMMSLeaveLobbyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsleavelobbyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLeaveLobbyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsleavelobbyresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyList_Filter {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	value          string
	comparision    int
	filter_type    int
}

pub fn (o &CMsgClientMMSGetLobbyList_Filter) pack() []byte {
	mut res := []byte{}
	if o.key != '' {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.value != '' {
		res << vproto.pack_string_field(o.value, 2)
	}
	if o.comparision != int(0) {
		res << vproto.pack_int32_field(o.comparision, 3)
	}
	if o.filter_type != int(0) {
		res << vproto.pack_int32_field(o.filter_type, 4)
	}
	return res
}

pub fn cmsgclientmmsgetlobbylist_filter_unpack(buf []byte) ?CMsgClientMMSGetLobbyList_Filter {
	mut res := zzz_vproto_internal_new_cmsgclientmmsgetlobbylist_filter()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.key = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.value = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.comparision = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.filter_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSGetLobbyList_Filter) eq(b CMsgClientMMSGetLobbyList_Filter) bool {
	return true && a.key == b.key && a.value == b.value && a.comparision == b.comparision &&
		a.filter_type == b.filter_type
}

[inline]
pub fn (a CMsgClientMMSGetLobbyList_Filter) ne(b CMsgClientMMSGetLobbyList_Filter) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyList_Filter) eq(b []CMsgClientMMSGetLobbyList_Filter) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyList_Filter) ne(b []CMsgClientMMSGetLobbyList_Filter) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylist_filter() CMsgClientMMSGetLobbyList_Filter {
	return CMsgClientMMSGetLobbyList_Filter{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylist_filter(o CMsgClientMMSGetLobbyList_Filter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylist_filter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyList_Filter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsgetlobbylist_filter_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyList {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	app_id                u32
	num_lobbies_requested int
	cell_id               u32
	deprecated_public_ip  u32
	filters               []CMsgClientMMSGetLobbyList_Filter
	public_ip             CMsgIPAddress
}

pub fn (o &CMsgClientMMSGetLobbyList) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.num_lobbies_requested != int(0) {
		res << vproto.pack_int32_field(o.num_lobbies_requested, 3)
	}
	if o.cell_id != u32(0) {
		res << vproto.pack_uint32_field(o.cell_id, 4)
	}
	if o.deprecated_public_ip != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 5)
	}
	// [packed=false]
	for _, x in o.filters {
		res << zzz_vproto_internal_pack_cmsgclientmmsgetlobbylist_filter(x, 6)
	}
	if o.public_ip.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 7)
	}
	return res
}

pub fn cmsgclientmmsgetlobbylist_unpack(buf []byte) ?CMsgClientMMSGetLobbyList {
	mut res := zzz_vproto_internal_new_cmsgclientmmsgetlobbylist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.num_lobbies_requested = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.cell_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.deprecated_public_ip = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylist_filter(cur_buf,
					tag_wiretype.wire_type) ?
				res.filters << v
				i = ii
			}
			7 {
				i, res.public_ip = zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSGetLobbyList) eq(b CMsgClientMMSGetLobbyList) bool {
	return true && a.app_id == b.app_id && a.num_lobbies_requested == b.num_lobbies_requested &&
		a.cell_id == b.cell_id && a.deprecated_public_ip == b.deprecated_public_ip && a.filters.eq(b.filters) &&
		a.public_ip.eq(b.public_ip)
}

[inline]
pub fn (a CMsgClientMMSGetLobbyList) ne(b CMsgClientMMSGetLobbyList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyList) eq(b []CMsgClientMMSGetLobbyList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyList) ne(b []CMsgClientMMSGetLobbyList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylist() CMsgClientMMSGetLobbyList {
	return CMsgClientMMSGetLobbyList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylist(o CMsgClientMMSGetLobbyList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsgetlobbylist_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyListResponse_Lobby {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	max_members    int
	lobby_type     int
	lobby_flags    int
	metadata       []byte
	num_members    int
	distance       f32
	weight         i64
}

pub fn (o &CMsgClientMMSGetLobbyListResponse_Lobby) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.max_members != int(0) {
		res << vproto.pack_int32_field(o.max_members, 2)
	}
	if o.lobby_type != int(0) {
		res << vproto.pack_int32_field(o.lobby_type, 3)
	}
	if o.lobby_flags != int(0) {
		res << vproto.pack_int32_field(o.lobby_flags, 4)
	}
	if o.metadata != []byte{} {
		res << vproto.pack_bytes_field(o.metadata, 5)
	}
	if o.num_members != int(0) {
		res << vproto.pack_int32_field(o.num_members, 6)
	}
	if o.distance != f32(0) {
		res << vproto.pack_float_field(o.distance, 7)
	}
	if o.weight != i64(0) {
		res << vproto.pack_int64_field(o.weight, 8)
	}
	return res
}

pub fn cmsgclientmmsgetlobbylistresponse_lobby_unpack(buf []byte) ?CMsgClientMMSGetLobbyListResponse_Lobby {
	mut res := zzz_vproto_internal_new_cmsgclientmmsgetlobbylistresponse_lobby()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.max_members = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.lobby_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.lobby_flags = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.metadata = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.num_members = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.distance = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.weight = vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSGetLobbyListResponse_Lobby) eq(b CMsgClientMMSGetLobbyListResponse_Lobby) bool {
	return true && a.steam_id == b.steam_id && a.max_members == b.max_members && a.lobby_type ==
		b.lobby_type && a.lobby_flags == b.lobby_flags && a.metadata == b.metadata && a.num_members ==
		b.num_members && a.distance == b.distance && a.weight == b.weight
}

[inline]
pub fn (a CMsgClientMMSGetLobbyListResponse_Lobby) ne(b CMsgClientMMSGetLobbyListResponse_Lobby) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyListResponse_Lobby) eq(b []CMsgClientMMSGetLobbyListResponse_Lobby) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyListResponse_Lobby) ne(b []CMsgClientMMSGetLobbyListResponse_Lobby) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylistresponse_lobby() CMsgClientMMSGetLobbyListResponse_Lobby {
	return CMsgClientMMSGetLobbyListResponse_Lobby{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistresponse_lobby(o CMsgClientMMSGetLobbyListResponse_Lobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistresponse_lobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyListResponse_Lobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsgetlobbylistresponse_lobby_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyListResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	eresult        int = 2
	lobbies        []CMsgClientMMSGetLobbyListResponse_Lobby
}

pub fn (o &CMsgClientMMSGetLobbyListResponse) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	// [packed=false]
	for _, x in o.lobbies {
		res << zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistresponse_lobby(x, 4)
	}
	return res
}

pub fn cmsgclientmmsgetlobbylistresponse_unpack(buf []byte) ?CMsgClientMMSGetLobbyListResponse {
	mut res := zzz_vproto_internal_new_cmsgclientmmsgetlobbylistresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistresponse_lobby(cur_buf,
					tag_wiretype.wire_type) ?
				res.lobbies << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSGetLobbyListResponse) eq(b CMsgClientMMSGetLobbyListResponse) bool {
	return true && a.app_id == b.app_id && a.eresult == b.eresult && a.lobbies.eq(b.lobbies)
}

[inline]
pub fn (a CMsgClientMMSGetLobbyListResponse) ne(b CMsgClientMMSGetLobbyListResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyListResponse) eq(b []CMsgClientMMSGetLobbyListResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyListResponse) ne(b []CMsgClientMMSGetLobbyListResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylistresponse() CMsgClientMMSGetLobbyListResponse {
	return CMsgClientMMSGetLobbyListResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistresponse(o CMsgClientMMSGetLobbyListResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyListResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsgetlobbylistresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyData {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	app_id          u32
	steam_id_lobby  u64
	steam_id_member u64
	max_members     int
	lobby_type      int
	lobby_flags     int
	metadata        []byte
}

pub fn (o &CMsgClientMMSSetLobbyData) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.steam_id_member != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_member, 3)
	}
	if o.max_members != int(0) {
		res << vproto.pack_int32_field(o.max_members, 4)
	}
	if o.lobby_type != int(0) {
		res << vproto.pack_int32_field(o.lobby_type, 5)
	}
	if o.lobby_flags != int(0) {
		res << vproto.pack_int32_field(o.lobby_flags, 6)
	}
	if o.metadata != []byte{} {
		res << vproto.pack_bytes_field(o.metadata, 7)
	}
	return res
}

pub fn cmsgclientmmssetlobbydata_unpack(buf []byte) ?CMsgClientMMSSetLobbyData {
	mut res := zzz_vproto_internal_new_cmsgclientmmssetlobbydata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.steam_id_member = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.max_members = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.lobby_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.lobby_flags = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.metadata = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSSetLobbyData) eq(b CMsgClientMMSSetLobbyData) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.steam_id_member ==
		b.steam_id_member && a.max_members == b.max_members && a.lobby_type == b.lobby_type &&
		a.lobby_flags == b.lobby_flags && a.metadata == b.metadata
}

[inline]
pub fn (a CMsgClientMMSSetLobbyData) ne(b CMsgClientMMSSetLobbyData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyData) eq(b []CMsgClientMMSSetLobbyData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyData) ne(b []CMsgClientMMSSetLobbyData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbydata() CMsgClientMMSSetLobbyData {
	return CMsgClientMMSSetLobbyData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbydata(o CMsgClientMMSSetLobbyData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbydata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmssetlobbydata_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyDataResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steam_id_lobby u64
	eresult        int = 2
}

pub fn (o &CMsgClientMMSSetLobbyDataResponse) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	return res
}

pub fn cmsgclientmmssetlobbydataresponse_unpack(buf []byte) ?CMsgClientMMSSetLobbyDataResponse {
	mut res := zzz_vproto_internal_new_cmsgclientmmssetlobbydataresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSSetLobbyDataResponse) eq(b CMsgClientMMSSetLobbyDataResponse) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.eresult ==
		b.eresult
}

[inline]
pub fn (a CMsgClientMMSSetLobbyDataResponse) ne(b CMsgClientMMSSetLobbyDataResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyDataResponse) eq(b []CMsgClientMMSSetLobbyDataResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyDataResponse) ne(b []CMsgClientMMSSetLobbyDataResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbydataresponse() CMsgClientMMSSetLobbyDataResponse {
	return CMsgClientMMSSetLobbyDataResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbydataresponse(o CMsgClientMMSSetLobbyDataResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbydataresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyDataResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmssetlobbydataresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steam_id_lobby u64
}

pub fn (o &CMsgClientMMSGetLobbyData) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	return res
}

pub fn cmsgclientmmsgetlobbydata_unpack(buf []byte) ?CMsgClientMMSGetLobbyData {
	mut res := zzz_vproto_internal_new_cmsgclientmmsgetlobbydata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSGetLobbyData) eq(b CMsgClientMMSGetLobbyData) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby
}

[inline]
pub fn (a CMsgClientMMSGetLobbyData) ne(b CMsgClientMMSGetLobbyData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyData) eq(b []CMsgClientMMSGetLobbyData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyData) ne(b []CMsgClientMMSGetLobbyData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbydata() CMsgClientMMSGetLobbyData {
	return CMsgClientMMSGetLobbyData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbydata(o CMsgClientMMSGetLobbyData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbydata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsgetlobbydata_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSLobbyData_Member {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	persona_name   string
	metadata       []byte
}

pub fn (o &CMsgClientMMSLobbyData_Member) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.persona_name != '' {
		res << vproto.pack_string_field(o.persona_name, 2)
	}
	if o.metadata != []byte{} {
		res << vproto.pack_bytes_field(o.metadata, 3)
	}
	return res
}

pub fn cmsgclientmmslobbydata_member_unpack(buf []byte) ?CMsgClientMMSLobbyData_Member {
	mut res := zzz_vproto_internal_new_cmsgclientmmslobbydata_member()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.persona_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.metadata = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSLobbyData_Member) eq(b CMsgClientMMSLobbyData_Member) bool {
	return true && a.steam_id == b.steam_id && a.persona_name == b.persona_name && a.metadata ==
		b.metadata
}

[inline]
pub fn (a CMsgClientMMSLobbyData_Member) ne(b CMsgClientMMSLobbyData_Member) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSLobbyData_Member) eq(b []CMsgClientMMSLobbyData_Member) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSLobbyData_Member) ne(b []CMsgClientMMSLobbyData_Member) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmslobbydata_member() CMsgClientMMSLobbyData_Member {
	return CMsgClientMMSLobbyData_Member{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbydata_member(o CMsgClientMMSLobbyData_Member, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbydata_member(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLobbyData_Member) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmslobbydata_member_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSLobbyData {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	app_id                      u32
	steam_id_lobby              u64
	num_members                 int
	max_members                 int
	lobby_type                  int
	lobby_flags                 int
	steam_id_owner              u64
	metadata                    []byte
	members                     []CMsgClientMMSLobbyData_Member
	lobby_cellid                u32
	owner_should_accept_changes bool
}

pub fn (o &CMsgClientMMSLobbyData) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.num_members != int(0) {
		res << vproto.pack_int32_field(o.num_members, 3)
	}
	if o.max_members != int(0) {
		res << vproto.pack_int32_field(o.max_members, 4)
	}
	if o.lobby_type != int(0) {
		res << vproto.pack_int32_field(o.lobby_type, 5)
	}
	if o.lobby_flags != int(0) {
		res << vproto.pack_int32_field(o.lobby_flags, 6)
	}
	if o.steam_id_owner != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_owner, 7)
	}
	if o.metadata != []byte{} {
		res << vproto.pack_bytes_field(o.metadata, 8)
	}
	// [packed=false]
	for _, x in o.members {
		res << zzz_vproto_internal_pack_cmsgclientmmslobbydata_member(x, 9)
	}
	if o.lobby_cellid != u32(0) {
		res << vproto.pack_uint32_field(o.lobby_cellid, 10)
	}
	if o.owner_should_accept_changes != false {
		res << vproto.pack_bool_field(o.owner_should_accept_changes, 11)
	}
	return res
}

pub fn cmsgclientmmslobbydata_unpack(buf []byte) ?CMsgClientMMSLobbyData {
	mut res := zzz_vproto_internal_new_cmsgclientmmslobbydata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.num_members = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.max_members = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.lobby_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.lobby_flags = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.steam_id_owner = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.metadata = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientmmslobbydata_member(cur_buf,
					tag_wiretype.wire_type) ?
				res.members << v
				i = ii
			}
			10 {
				i, res.lobby_cellid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				i, res.owner_should_accept_changes = vproto.unpack_bool_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSLobbyData) eq(b CMsgClientMMSLobbyData) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.num_members ==
		b.num_members && a.max_members == b.max_members && a.lobby_type == b.lobby_type && a.lobby_flags ==
		b.lobby_flags && a.steam_id_owner == b.steam_id_owner && a.metadata == b.metadata && a.members.eq(b.members) &&
		a.lobby_cellid == b.lobby_cellid && a.owner_should_accept_changes == b.owner_should_accept_changes
}

[inline]
pub fn (a CMsgClientMMSLobbyData) ne(b CMsgClientMMSLobbyData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSLobbyData) eq(b []CMsgClientMMSLobbyData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSLobbyData) ne(b []CMsgClientMMSLobbyData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmslobbydata() CMsgClientMMSLobbyData {
	return CMsgClientMMSLobbyData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbydata(o CMsgClientMMSLobbyData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbydata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLobbyData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmslobbydata_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSSendLobbyChatMsg {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	app_id          u32
	steam_id_lobby  u64
	steam_id_target u64
	lobby_message   []byte
}

pub fn (o &CMsgClientMMSSendLobbyChatMsg) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.steam_id_target != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_target, 3)
	}
	if o.lobby_message != []byte{} {
		res << vproto.pack_bytes_field(o.lobby_message, 4)
	}
	return res
}

pub fn cmsgclientmmssendlobbychatmsg_unpack(buf []byte) ?CMsgClientMMSSendLobbyChatMsg {
	mut res := zzz_vproto_internal_new_cmsgclientmmssendlobbychatmsg()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.steam_id_target = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.lobby_message = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSSendLobbyChatMsg) eq(b CMsgClientMMSSendLobbyChatMsg) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.steam_id_target ==
		b.steam_id_target && a.lobby_message == b.lobby_message
}

[inline]
pub fn (a CMsgClientMMSSendLobbyChatMsg) ne(b CMsgClientMMSSendLobbyChatMsg) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSSendLobbyChatMsg) eq(b []CMsgClientMMSSendLobbyChatMsg) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSSendLobbyChatMsg) ne(b []CMsgClientMMSSendLobbyChatMsg) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmssendlobbychatmsg() CMsgClientMMSSendLobbyChatMsg {
	return CMsgClientMMSSendLobbyChatMsg{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmssendlobbychatmsg(o CMsgClientMMSSendLobbyChatMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmssendlobbychatmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSendLobbyChatMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmssendlobbychatmsg_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSLobbyChatMsg {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	app_id          u32
	steam_id_lobby  u64
	steam_id_sender u64
	lobby_message   []byte
}

pub fn (o &CMsgClientMMSLobbyChatMsg) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.steam_id_sender != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_sender, 3)
	}
	if o.lobby_message != []byte{} {
		res << vproto.pack_bytes_field(o.lobby_message, 4)
	}
	return res
}

pub fn cmsgclientmmslobbychatmsg_unpack(buf []byte) ?CMsgClientMMSLobbyChatMsg {
	mut res := zzz_vproto_internal_new_cmsgclientmmslobbychatmsg()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.steam_id_sender = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.lobby_message = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSLobbyChatMsg) eq(b CMsgClientMMSLobbyChatMsg) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.steam_id_sender ==
		b.steam_id_sender && a.lobby_message == b.lobby_message
}

[inline]
pub fn (a CMsgClientMMSLobbyChatMsg) ne(b CMsgClientMMSLobbyChatMsg) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSLobbyChatMsg) eq(b []CMsgClientMMSLobbyChatMsg) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSLobbyChatMsg) ne(b []CMsgClientMMSLobbyChatMsg) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmslobbychatmsg() CMsgClientMMSLobbyChatMsg {
	return CMsgClientMMSLobbyChatMsg{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbychatmsg(o CMsgClientMMSLobbyChatMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbychatmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLobbyChatMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmslobbychatmsg_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyOwner {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	steam_id_lobby     u64
	steam_id_new_owner u64
}

pub fn (o &CMsgClientMMSSetLobbyOwner) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.steam_id_new_owner != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_new_owner, 3)
	}
	return res
}

pub fn cmsgclientmmssetlobbyowner_unpack(buf []byte) ?CMsgClientMMSSetLobbyOwner {
	mut res := zzz_vproto_internal_new_cmsgclientmmssetlobbyowner()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.steam_id_new_owner = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSSetLobbyOwner) eq(b CMsgClientMMSSetLobbyOwner) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.steam_id_new_owner ==
		b.steam_id_new_owner
}

[inline]
pub fn (a CMsgClientMMSSetLobbyOwner) ne(b CMsgClientMMSSetLobbyOwner) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyOwner) eq(b []CMsgClientMMSSetLobbyOwner) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyOwner) ne(b []CMsgClientMMSSetLobbyOwner) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbyowner() CMsgClientMMSSetLobbyOwner {
	return CMsgClientMMSSetLobbyOwner{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbyowner(o CMsgClientMMSSetLobbyOwner, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbyowner(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyOwner) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmssetlobbyowner_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyOwnerResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steam_id_lobby u64
	eresult        int = 2
}

pub fn (o &CMsgClientMMSSetLobbyOwnerResponse) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	return res
}

pub fn cmsgclientmmssetlobbyownerresponse_unpack(buf []byte) ?CMsgClientMMSSetLobbyOwnerResponse {
	mut res := zzz_vproto_internal_new_cmsgclientmmssetlobbyownerresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSSetLobbyOwnerResponse) eq(b CMsgClientMMSSetLobbyOwnerResponse) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.eresult ==
		b.eresult
}

[inline]
pub fn (a CMsgClientMMSSetLobbyOwnerResponse) ne(b CMsgClientMMSSetLobbyOwnerResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyOwnerResponse) eq(b []CMsgClientMMSSetLobbyOwnerResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyOwnerResponse) ne(b []CMsgClientMMSSetLobbyOwnerResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbyownerresponse() CMsgClientMMSSetLobbyOwnerResponse {
	return CMsgClientMMSSetLobbyOwnerResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbyownerresponse(o CMsgClientMMSSetLobbyOwnerResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbyownerresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyOwnerResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmssetlobbyownerresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyLinked {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	app_id          u32
	steam_id_lobby  u64
	steam_id_lobby2 u64
}

pub fn (o &CMsgClientMMSSetLobbyLinked) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.steam_id_lobby2 != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby2, 3)
	}
	return res
}

pub fn cmsgclientmmssetlobbylinked_unpack(buf []byte) ?CMsgClientMMSSetLobbyLinked {
	mut res := zzz_vproto_internal_new_cmsgclientmmssetlobbylinked()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.steam_id_lobby2 = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSSetLobbyLinked) eq(b CMsgClientMMSSetLobbyLinked) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.steam_id_lobby2 ==
		b.steam_id_lobby2
}

[inline]
pub fn (a CMsgClientMMSSetLobbyLinked) ne(b CMsgClientMMSSetLobbyLinked) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyLinked) eq(b []CMsgClientMMSSetLobbyLinked) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyLinked) ne(b []CMsgClientMMSSetLobbyLinked) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbylinked() CMsgClientMMSSetLobbyLinked {
	return CMsgClientMMSSetLobbyLinked{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbylinked(o CMsgClientMMSSetLobbyLinked, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbylinked(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyLinked) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmssetlobbylinked_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyGameServer {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	app_id                    u32
	steam_id_lobby            u64
	deprecated_game_server_ip u32
	game_server_port          u32
	game_server_steam_id      u64
	game_server_ip            CMsgIPAddress
}

pub fn (o &CMsgClientMMSSetLobbyGameServer) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.deprecated_game_server_ip != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_game_server_ip, 3)
	}
	if o.game_server_port != u32(0) {
		res << vproto.pack_uint32_field(o.game_server_port, 4)
	}
	if o.game_server_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_server_steam_id, 5)
	}
	if o.game_server_ip.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.game_server_ip, 6)
	}
	return res
}

pub fn cmsgclientmmssetlobbygameserver_unpack(buf []byte) ?CMsgClientMMSSetLobbyGameServer {
	mut res := zzz_vproto_internal_new_cmsgclientmmssetlobbygameserver()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.deprecated_game_server_ip = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			4 {
				i, res.game_server_port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.game_server_steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.game_server_ip = zzz_vproto_internal_unpack_cmsgipaddress(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSSetLobbyGameServer) eq(b CMsgClientMMSSetLobbyGameServer) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.deprecated_game_server_ip ==
		b.deprecated_game_server_ip && a.game_server_port == b.game_server_port && a.game_server_steam_id ==
		b.game_server_steam_id && a.game_server_ip.eq(b.game_server_ip)
}

[inline]
pub fn (a CMsgClientMMSSetLobbyGameServer) ne(b CMsgClientMMSSetLobbyGameServer) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyGameServer) eq(b []CMsgClientMMSSetLobbyGameServer) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSSetLobbyGameServer) ne(b []CMsgClientMMSSetLobbyGameServer) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbygameserver() CMsgClientMMSSetLobbyGameServer {
	return CMsgClientMMSSetLobbyGameServer{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbygameserver(o CMsgClientMMSSetLobbyGameServer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbygameserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyGameServer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmssetlobbygameserver_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSLobbyGameServerSet {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	app_id                    u32
	steam_id_lobby            u64
	deprecated_game_server_ip u32
	game_server_port          u32
	game_server_steam_id      u64
	game_server_ip            CMsgIPAddress
}

pub fn (o &CMsgClientMMSLobbyGameServerSet) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.deprecated_game_server_ip != u32(0) {
		res << vproto.pack_uint32_field(o.deprecated_game_server_ip, 3)
	}
	if o.game_server_port != u32(0) {
		res << vproto.pack_uint32_field(o.game_server_port, 4)
	}
	if o.game_server_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_server_steam_id, 5)
	}
	if o.game_server_ip.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.game_server_ip, 6)
	}
	return res
}

pub fn cmsgclientmmslobbygameserverset_unpack(buf []byte) ?CMsgClientMMSLobbyGameServerSet {
	mut res := zzz_vproto_internal_new_cmsgclientmmslobbygameserverset()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.deprecated_game_server_ip = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			4 {
				i, res.game_server_port = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.game_server_steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.game_server_ip = zzz_vproto_internal_unpack_cmsgipaddress(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSLobbyGameServerSet) eq(b CMsgClientMMSLobbyGameServerSet) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.deprecated_game_server_ip ==
		b.deprecated_game_server_ip && a.game_server_port == b.game_server_port && a.game_server_steam_id ==
		b.game_server_steam_id && a.game_server_ip.eq(b.game_server_ip)
}

[inline]
pub fn (a CMsgClientMMSLobbyGameServerSet) ne(b CMsgClientMMSLobbyGameServerSet) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSLobbyGameServerSet) eq(b []CMsgClientMMSLobbyGameServerSet) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSLobbyGameServerSet) ne(b []CMsgClientMMSLobbyGameServerSet) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmslobbygameserverset() CMsgClientMMSLobbyGameServerSet {
	return CMsgClientMMSLobbyGameServerSet{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbygameserverset(o CMsgClientMMSLobbyGameServerSet, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbygameserverset(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLobbyGameServerSet) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmslobbygameserverset_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSUserJoinedLobby {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steam_id_lobby u64
	steam_id_user  u64
	persona_name   string
}

pub fn (o &CMsgClientMMSUserJoinedLobby) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.steam_id_user != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_user, 3)
	}
	if o.persona_name != '' {
		res << vproto.pack_string_field(o.persona_name, 4)
	}
	return res
}

pub fn cmsgclientmmsuserjoinedlobby_unpack(buf []byte) ?CMsgClientMMSUserJoinedLobby {
	mut res := zzz_vproto_internal_new_cmsgclientmmsuserjoinedlobby()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.steam_id_user = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.persona_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSUserJoinedLobby) eq(b CMsgClientMMSUserJoinedLobby) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.steam_id_user ==
		b.steam_id_user && a.persona_name == b.persona_name
}

[inline]
pub fn (a CMsgClientMMSUserJoinedLobby) ne(b CMsgClientMMSUserJoinedLobby) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSUserJoinedLobby) eq(b []CMsgClientMMSUserJoinedLobby) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSUserJoinedLobby) ne(b []CMsgClientMMSUserJoinedLobby) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsuserjoinedlobby() CMsgClientMMSUserJoinedLobby {
	return CMsgClientMMSUserJoinedLobby{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsuserjoinedlobby(o CMsgClientMMSUserJoinedLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsuserjoinedlobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSUserJoinedLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsuserjoinedlobby_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSUserLeftLobby {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steam_id_lobby u64
	steam_id_user  u64
	persona_name   string
}

pub fn (o &CMsgClientMMSUserLeftLobby) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.steam_id_user != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_user, 3)
	}
	if o.persona_name != '' {
		res << vproto.pack_string_field(o.persona_name, 4)
	}
	return res
}

pub fn cmsgclientmmsuserleftlobby_unpack(buf []byte) ?CMsgClientMMSUserLeftLobby {
	mut res := zzz_vproto_internal_new_cmsgclientmmsuserleftlobby()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.steam_id_user = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.persona_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSUserLeftLobby) eq(b CMsgClientMMSUserLeftLobby) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.steam_id_user ==
		b.steam_id_user && a.persona_name == b.persona_name
}

[inline]
pub fn (a CMsgClientMMSUserLeftLobby) ne(b CMsgClientMMSUserLeftLobby) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSUserLeftLobby) eq(b []CMsgClientMMSUserLeftLobby) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSUserLeftLobby) ne(b []CMsgClientMMSUserLeftLobby) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsuserleftlobby() CMsgClientMMSUserLeftLobby {
	return CMsgClientMMSUserLeftLobby{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsuserleftlobby(o CMsgClientMMSUserLeftLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsuserleftlobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSUserLeftLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsuserleftlobby_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSInviteToLobby {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	app_id                u32
	steam_id_lobby        u64
	steam_id_user_invited u64
}

pub fn (o &CMsgClientMMSInviteToLobby) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.steam_id_user_invited != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_user_invited, 3)
	}
	return res
}

pub fn cmsgclientmmsinvitetolobby_unpack(buf []byte) ?CMsgClientMMSInviteToLobby {
	mut res := zzz_vproto_internal_new_cmsgclientmmsinvitetolobby()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.steam_id_user_invited = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSInviteToLobby) eq(b CMsgClientMMSInviteToLobby) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.steam_id_user_invited ==
		b.steam_id_user_invited
}

[inline]
pub fn (a CMsgClientMMSInviteToLobby) ne(b CMsgClientMMSInviteToLobby) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSInviteToLobby) eq(b []CMsgClientMMSInviteToLobby) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSInviteToLobby) ne(b []CMsgClientMMSInviteToLobby) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsinvitetolobby() CMsgClientMMSInviteToLobby {
	return CMsgClientMMSInviteToLobby{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsinvitetolobby(o CMsgClientMMSInviteToLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsinvitetolobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSInviteToLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsinvitetolobby_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyStatus {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	app_id           u32
	steam_id_lobby   u64
	claim_membership bool
	claim_ownership  bool
}

pub fn (o &CMsgClientMMSGetLobbyStatus) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.claim_membership != false {
		res << vproto.pack_bool_field(o.claim_membership, 3)
	}
	if o.claim_ownership != false {
		res << vproto.pack_bool_field(o.claim_ownership, 4)
	}
	return res
}

pub fn cmsgclientmmsgetlobbystatus_unpack(buf []byte) ?CMsgClientMMSGetLobbyStatus {
	mut res := zzz_vproto_internal_new_cmsgclientmmsgetlobbystatus()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.claim_membership = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.claim_ownership = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSGetLobbyStatus) eq(b CMsgClientMMSGetLobbyStatus) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.claim_membership ==
		b.claim_membership && a.claim_ownership == b.claim_ownership
}

[inline]
pub fn (a CMsgClientMMSGetLobbyStatus) ne(b CMsgClientMMSGetLobbyStatus) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyStatus) eq(b []CMsgClientMMSGetLobbyStatus) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyStatus) ne(b []CMsgClientMMSGetLobbyStatus) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbystatus() CMsgClientMMSGetLobbyStatus {
	return CMsgClientMMSGetLobbyStatus{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbystatus(o CMsgClientMMSGetLobbyStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbystatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsgetlobbystatus_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyStatusResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	steam_id_lobby u64
	lobby_status   EMMSLobbyStatus = .k_emmslobbystatusinvalid
}

pub fn (o &CMsgClientMMSGetLobbyStatusResponse) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.steam_id_lobby != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.lobby_status != zzz_vproto_internal_new_emmslobbystatus() {
		res << zzz_vproto_internal_pack_emmslobbystatus(o.lobby_status, 3)
	}
	return res
}

pub fn cmsgclientmmsgetlobbystatusresponse_unpack(buf []byte) ?CMsgClientMMSGetLobbyStatusResponse {
	mut res := zzz_vproto_internal_new_cmsgclientmmsgetlobbystatusresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_lobby = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.lobby_status = zzz_vproto_internal_unpack_emmslobbystatus(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientMMSGetLobbyStatusResponse) eq(b CMsgClientMMSGetLobbyStatusResponse) bool {
	return true && a.app_id == b.app_id && a.steam_id_lobby == b.steam_id_lobby && a.lobby_status ==
		b.lobby_status
}

[inline]
pub fn (a CMsgClientMMSGetLobbyStatusResponse) ne(b CMsgClientMMSGetLobbyStatusResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyStatusResponse) eq(b []CMsgClientMMSGetLobbyStatusResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientMMSGetLobbyStatusResponse) ne(b []CMsgClientMMSGetLobbyStatusResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbystatusresponse() CMsgClientMMSGetLobbyStatusResponse {
	return CMsgClientMMSGetLobbyStatusResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbystatusresponse(o CMsgClientMMSGetLobbyStatusResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbystatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyStatusResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientmmsgetlobbystatusresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientInviteToGame {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id_dest  u64
	steam_id_src   u64
	connect_string string
	remote_play    string
}

pub fn (o &CMsgClientInviteToGame) pack() []byte {
	mut res := []byte{}
	if o.steam_id_dest != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_dest, 1)
	}
	if o.steam_id_src != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_src, 2)
	}
	if o.connect_string != '' {
		res << vproto.pack_string_field(o.connect_string, 3)
	}
	if o.remote_play != '' {
		res << vproto.pack_string_field(o.remote_play, 4)
	}
	return res
}

pub fn cmsgclientinvitetogame_unpack(buf []byte) ?CMsgClientInviteToGame {
	mut res := zzz_vproto_internal_new_cmsgclientinvitetogame()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id_dest = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_src = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.connect_string = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.remote_play = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientInviteToGame) eq(b CMsgClientInviteToGame) bool {
	return true && a.steam_id_dest == b.steam_id_dest && a.steam_id_src == b.steam_id_src &&
		a.connect_string == b.connect_string && a.remote_play == b.remote_play
}

[inline]
pub fn (a CMsgClientInviteToGame) ne(b CMsgClientInviteToGame) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientInviteToGame) eq(b []CMsgClientInviteToGame) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientInviteToGame) ne(b []CMsgClientInviteToGame) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientinvitetogame() CMsgClientInviteToGame {
	return CMsgClientInviteToGame{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientinvitetogame(o CMsgClientInviteToGame, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientinvitetogame(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientInviteToGame) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientinvitetogame_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientChatInvite {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steam_id_invited     u64
	steam_id_chat        u64
	steam_id_patron      u64
	chatroom_type        int
	steam_id_friend_chat u64
	chat_name            string
	game_id              u64
}

pub fn (o &CMsgClientChatInvite) pack() []byte {
	mut res := []byte{}
	if o.steam_id_invited != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_invited, 1)
	}
	if o.steam_id_chat != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_chat, 2)
	}
	if o.steam_id_patron != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_patron, 3)
	}
	if o.chatroom_type != int(0) {
		res << vproto.pack_int32_field(o.chatroom_type, 4)
	}
	if o.steam_id_friend_chat != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_friend_chat, 5)
	}
	if o.chat_name != '' {
		res << vproto.pack_string_field(o.chat_name, 6)
	}
	if o.game_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_id, 7)
	}
	return res
}

pub fn cmsgclientchatinvite_unpack(buf []byte) ?CMsgClientChatInvite {
	mut res := zzz_vproto_internal_new_cmsgclientchatinvite()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id_invited = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steam_id_chat = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.steam_id_patron = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.chatroom_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.steam_id_friend_chat = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.chat_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.game_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientChatInvite) eq(b CMsgClientChatInvite) bool {
	return true && a.steam_id_invited == b.steam_id_invited && a.steam_id_chat == b.steam_id_chat &&
		a.steam_id_patron == b.steam_id_patron && a.chatroom_type == b.chatroom_type && a.steam_id_friend_chat ==
		b.steam_id_friend_chat && a.chat_name == b.chat_name && a.game_id == b.game_id
}

[inline]
pub fn (a CMsgClientChatInvite) ne(b CMsgClientChatInvite) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientChatInvite) eq(b []CMsgClientChatInvite) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientChatInvite) ne(b []CMsgClientChatInvite) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientchatinvite() CMsgClientChatInvite {
	return CMsgClientChatInvite{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientchatinvite(o CMsgClientChatInvite, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientchatinvite(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatInvite) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientchatinvite_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientConnectionStats_Stats_Logon {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	connect_attempts     int
	connect_successes    int
	connect_failures     int
	connections_dropped  int
	seconds_running      u32
	msec_tologonthistime u32
	count_bad_cms        u32
}

pub fn (o &CMsgClientConnectionStats_Stats_Logon) pack() []byte {
	mut res := []byte{}
	if o.connect_attempts != int(0) {
		res << vproto.pack_int32_field(o.connect_attempts, 1)
	}
	if o.connect_successes != int(0) {
		res << vproto.pack_int32_field(o.connect_successes, 2)
	}
	if o.connect_failures != int(0) {
		res << vproto.pack_int32_field(o.connect_failures, 3)
	}
	if o.connections_dropped != int(0) {
		res << vproto.pack_int32_field(o.connections_dropped, 4)
	}
	if o.seconds_running != u32(0) {
		res << vproto.pack_uint32_field(o.seconds_running, 5)
	}
	if o.msec_tologonthistime != u32(0) {
		res << vproto.pack_uint32_field(o.msec_tologonthistime, 6)
	}
	if o.count_bad_cms != u32(0) {
		res << vproto.pack_uint32_field(o.count_bad_cms, 7)
	}
	return res
}

pub fn cmsgclientconnectionstats_stats_logon_unpack(buf []byte) ?CMsgClientConnectionStats_Stats_Logon {
	mut res := zzz_vproto_internal_new_cmsgclientconnectionstats_stats_logon()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.connect_attempts = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.connect_successes = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.connect_failures = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.connections_dropped = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.seconds_running = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.msec_tologonthistime = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.count_bad_cms = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientConnectionStats_Stats_Logon) eq(b CMsgClientConnectionStats_Stats_Logon) bool {
	return true && a.connect_attempts == b.connect_attempts && a.connect_successes == b.connect_successes &&
		a.connect_failures == b.connect_failures && a.connections_dropped == b.connections_dropped &&
		a.seconds_running == b.seconds_running && a.msec_tologonthistime == b.msec_tologonthistime &&
		a.count_bad_cms == b.count_bad_cms
}

[inline]
pub fn (a CMsgClientConnectionStats_Stats_Logon) ne(b CMsgClientConnectionStats_Stats_Logon) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientConnectionStats_Stats_Logon) eq(b []CMsgClientConnectionStats_Stats_Logon) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientConnectionStats_Stats_Logon) ne(b []CMsgClientConnectionStats_Stats_Logon) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientconnectionstats_stats_logon() CMsgClientConnectionStats_Stats_Logon {
	return CMsgClientConnectionStats_Stats_Logon{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_logon(o CMsgClientConnectionStats_Stats_Logon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_logon(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStats_Stats_Logon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientconnectionstats_stats_logon_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientConnectionStats_Stats_UDP {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	pkts_sent      u64
	bytes_sent     u64
	pkts_recv      u64
	pkts_processed u64
	bytes_recv     u64
}

pub fn (o &CMsgClientConnectionStats_Stats_UDP) pack() []byte {
	mut res := []byte{}
	if o.pkts_sent != u64(0) {
		res << vproto.pack_uint64_field(o.pkts_sent, 1)
	}
	if o.bytes_sent != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_sent, 2)
	}
	if o.pkts_recv != u64(0) {
		res << vproto.pack_uint64_field(o.pkts_recv, 3)
	}
	if o.pkts_processed != u64(0) {
		res << vproto.pack_uint64_field(o.pkts_processed, 4)
	}
	if o.bytes_recv != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_recv, 5)
	}
	return res
}

pub fn cmsgclientconnectionstats_stats_udp_unpack(buf []byte) ?CMsgClientConnectionStats_Stats_UDP {
	mut res := zzz_vproto_internal_new_cmsgclientconnectionstats_stats_udp()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.pkts_sent = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.bytes_sent = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.pkts_recv = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.pkts_processed = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.bytes_recv = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientConnectionStats_Stats_UDP) eq(b CMsgClientConnectionStats_Stats_UDP) bool {
	return true && a.pkts_sent == b.pkts_sent && a.bytes_sent == b.bytes_sent && a.pkts_recv ==
		b.pkts_recv && a.pkts_processed == b.pkts_processed && a.bytes_recv == b.bytes_recv
}

[inline]
pub fn (a CMsgClientConnectionStats_Stats_UDP) ne(b CMsgClientConnectionStats_Stats_UDP) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientConnectionStats_Stats_UDP) eq(b []CMsgClientConnectionStats_Stats_UDP) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientConnectionStats_Stats_UDP) ne(b []CMsgClientConnectionStats_Stats_UDP) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientconnectionstats_stats_udp() CMsgClientConnectionStats_Stats_UDP {
	return CMsgClientConnectionStats_Stats_UDP{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_udp(o CMsgClientConnectionStats_Stats_UDP, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_udp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStats_Stats_UDP) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientconnectionstats_stats_udp_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientConnectionStats_Stats_VConn {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	connections_udp           u32
	connections_tcp           u32
	stats_udp                 CMsgClientConnectionStats_Stats_UDP
	pkts_abandoned            u64
	conn_req_received         u64
	pkts_resent               u64
	msgs_sent                 u64
	msgs_sent_failed          u64
	msgs_recv                 u64
	datagrams_sent            u64
	datagrams_recv            u64
	bad_pkts_recv             u64
	unknown_conn_pkts_recv    u64
	missed_pkts_recv          u64
	dup_pkts_recv             u64
	failed_connect_challenges u64
	micro_sec_avg_latency     u32
	micro_sec_min_latency     u32
	micro_sec_max_latency     u32
	mem_pool_msg_in_use       u32
}

pub fn (o &CMsgClientConnectionStats_Stats_VConn) pack() []byte {
	mut res := []byte{}
	if o.connections_udp != u32(0) {
		res << vproto.pack_uint32_field(o.connections_udp, 1)
	}
	if o.connections_tcp != u32(0) {
		res << vproto.pack_uint32_field(o.connections_tcp, 2)
	}
	if o.stats_udp.ne(zzz_vproto_internal_new_cmsgclientconnectionstats_stats_udp()) {
		res <<
			zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_udp(o.stats_udp, 3)
	}
	if o.pkts_abandoned != u64(0) {
		res << vproto.pack_uint64_field(o.pkts_abandoned, 4)
	}
	if o.conn_req_received != u64(0) {
		res << vproto.pack_uint64_field(o.conn_req_received, 5)
	}
	if o.pkts_resent != u64(0) {
		res << vproto.pack_uint64_field(o.pkts_resent, 6)
	}
	if o.msgs_sent != u64(0) {
		res << vproto.pack_uint64_field(o.msgs_sent, 7)
	}
	if o.msgs_sent_failed != u64(0) {
		res << vproto.pack_uint64_field(o.msgs_sent_failed, 8)
	}
	if o.msgs_recv != u64(0) {
		res << vproto.pack_uint64_field(o.msgs_recv, 9)
	}
	if o.datagrams_sent != u64(0) {
		res << vproto.pack_uint64_field(o.datagrams_sent, 10)
	}
	if o.datagrams_recv != u64(0) {
		res << vproto.pack_uint64_field(o.datagrams_recv, 11)
	}
	if o.bad_pkts_recv != u64(0) {
		res << vproto.pack_uint64_field(o.bad_pkts_recv, 12)
	}
	if o.unknown_conn_pkts_recv != u64(0) {
		res << vproto.pack_uint64_field(o.unknown_conn_pkts_recv, 13)
	}
	if o.missed_pkts_recv != u64(0) {
		res << vproto.pack_uint64_field(o.missed_pkts_recv, 14)
	}
	if o.dup_pkts_recv != u64(0) {
		res << vproto.pack_uint64_field(o.dup_pkts_recv, 15)
	}
	if o.failed_connect_challenges != u64(0) {
		res << vproto.pack_uint64_field(o.failed_connect_challenges, 16)
	}
	if o.micro_sec_avg_latency != u32(0) {
		res << vproto.pack_uint32_field(o.micro_sec_avg_latency, 17)
	}
	if o.micro_sec_min_latency != u32(0) {
		res << vproto.pack_uint32_field(o.micro_sec_min_latency, 18)
	}
	if o.micro_sec_max_latency != u32(0) {
		res << vproto.pack_uint32_field(o.micro_sec_max_latency, 19)
	}
	if o.mem_pool_msg_in_use != u32(0) {
		res << vproto.pack_uint32_field(o.mem_pool_msg_in_use, 20)
	}
	return res
}

pub fn cmsgclientconnectionstats_stats_vconn_unpack(buf []byte) ?CMsgClientConnectionStats_Stats_VConn {
	mut res := zzz_vproto_internal_new_cmsgclientconnectionstats_stats_vconn()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.connections_udp = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.connections_tcp = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.stats_udp = zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_udp(cur_buf,
					tag_wiretype.wire_type) ?
			}
			4 {
				i, res.pkts_abandoned = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.conn_req_received = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.pkts_resent = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.msgs_sent = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.msgs_sent_failed = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.msgs_recv = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.datagrams_sent = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				i, res.datagrams_recv = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			12 {
				i, res.bad_pkts_recv = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			13 {
				i, res.unknown_conn_pkts_recv = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			14 {
				i, res.missed_pkts_recv = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			15 {
				i, res.dup_pkts_recv = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			16 {
				i, res.failed_connect_challenges = vproto.unpack_uint64_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			17 {
				i, res.micro_sec_avg_latency = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			18 {
				i, res.micro_sec_min_latency = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			19 {
				i, res.micro_sec_max_latency = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			20 {
				i, res.mem_pool_msg_in_use = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientConnectionStats_Stats_VConn) eq(b CMsgClientConnectionStats_Stats_VConn) bool {
	return true && a.connections_udp == b.connections_udp && a.connections_tcp == b.connections_tcp &&
		a.stats_udp.eq(b.stats_udp) && a.pkts_abandoned == b.pkts_abandoned && a.conn_req_received ==
		b.conn_req_received && a.pkts_resent == b.pkts_resent && a.msgs_sent == b.msgs_sent &&
		a.msgs_sent_failed == b.msgs_sent_failed && a.msgs_recv == b.msgs_recv && a.datagrams_sent ==
		b.datagrams_sent && a.datagrams_recv == b.datagrams_recv && a.bad_pkts_recv == b.bad_pkts_recv &&
		a.unknown_conn_pkts_recv == b.unknown_conn_pkts_recv && a.missed_pkts_recv == b.missed_pkts_recv &&
		a.dup_pkts_recv == b.dup_pkts_recv && a.failed_connect_challenges == b.failed_connect_challenges &&
		a.micro_sec_avg_latency == b.micro_sec_avg_latency && a.micro_sec_min_latency == b.micro_sec_min_latency &&
		a.micro_sec_max_latency == b.micro_sec_max_latency && a.mem_pool_msg_in_use == b.mem_pool_msg_in_use
}

[inline]
pub fn (a CMsgClientConnectionStats_Stats_VConn) ne(b CMsgClientConnectionStats_Stats_VConn) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientConnectionStats_Stats_VConn) eq(b []CMsgClientConnectionStats_Stats_VConn) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientConnectionStats_Stats_VConn) ne(b []CMsgClientConnectionStats_Stats_VConn) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientconnectionstats_stats_vconn() CMsgClientConnectionStats_Stats_VConn {
	return CMsgClientConnectionStats_Stats_VConn{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_vconn(o CMsgClientConnectionStats_Stats_VConn, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_vconn(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStats_Stats_VConn) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientconnectionstats_stats_vconn_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientConnectionStats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stats_logon    CMsgClientConnectionStats_Stats_Logon
	stats_vconn    CMsgClientConnectionStats_Stats_VConn
}

pub fn (o &CMsgClientConnectionStats) pack() []byte {
	mut res := []byte{}
	if o.stats_logon.ne(zzz_vproto_internal_new_cmsgclientconnectionstats_stats_logon()) {
		res <<
			zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_logon(o.stats_logon, 1)
	}
	if o.stats_vconn.ne(zzz_vproto_internal_new_cmsgclientconnectionstats_stats_vconn()) {
		res <<
			zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_vconn(o.stats_vconn, 2)
	}
	return res
}

pub fn cmsgclientconnectionstats_unpack(buf []byte) ?CMsgClientConnectionStats {
	mut res := zzz_vproto_internal_new_cmsgclientconnectionstats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.stats_logon = zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_logon(cur_buf,
					tag_wiretype.wire_type) ?
			}
			2 {
				i, res.stats_vconn = zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_vconn(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientConnectionStats) eq(b CMsgClientConnectionStats) bool {
	return true && a.stats_logon.eq(b.stats_logon) && a.stats_vconn.eq(b.stats_vconn)
}

[inline]
pub fn (a CMsgClientConnectionStats) ne(b CMsgClientConnectionStats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientConnectionStats) eq(b []CMsgClientConnectionStats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientConnectionStats) ne(b []CMsgClientConnectionStats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientconnectionstats() CMsgClientConnectionStats {
	return CMsgClientConnectionStats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstats(o CMsgClientConnectionStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientconnectionstats_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientServersAvailable_Server_Types_Available {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	server         u32
	changed        bool
}

pub fn (o &CMsgClientServersAvailable_Server_Types_Available) pack() []byte {
	mut res := []byte{}
	if o.server != u32(0) {
		res << vproto.pack_uint32_field(o.server, 1)
	}
	if o.changed != false {
		res << vproto.pack_bool_field(o.changed, 2)
	}
	return res
}

pub fn cmsgclientserversavailable_server_types_available_unpack(buf []byte) ?CMsgClientServersAvailable_Server_Types_Available {
	mut res := zzz_vproto_internal_new_cmsgclientserversavailable_server_types_available()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.server = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.changed = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientServersAvailable_Server_Types_Available) eq(b CMsgClientServersAvailable_Server_Types_Available) bool {
	return true && a.server == b.server && a.changed == b.changed
}

[inline]
pub fn (a CMsgClientServersAvailable_Server_Types_Available) ne(b CMsgClientServersAvailable_Server_Types_Available) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientServersAvailable_Server_Types_Available) eq(b []CMsgClientServersAvailable_Server_Types_Available) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientServersAvailable_Server_Types_Available) ne(b []CMsgClientServersAvailable_Server_Types_Available) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientserversavailable_server_types_available() CMsgClientServersAvailable_Server_Types_Available {
	return CMsgClientServersAvailable_Server_Types_Available{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientserversavailable_server_types_available(o CMsgClientServersAvailable_Server_Types_Available, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientserversavailable_server_types_available(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServersAvailable_Server_Types_Available) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientserversavailable_server_types_available_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientServersAvailable {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	server_types_available        []CMsgClientServersAvailable_Server_Types_Available
	server_type_for_auth_services u32
}

pub fn (o &CMsgClientServersAvailable) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.server_types_available {
		res <<
			zzz_vproto_internal_pack_cmsgclientserversavailable_server_types_available(x, 1)
	}
	if o.server_type_for_auth_services != u32(0) {
		res << vproto.pack_uint32_field(o.server_type_for_auth_services, 2)
	}
	return res
}

pub fn cmsgclientserversavailable_unpack(buf []byte) ?CMsgClientServersAvailable {
	mut res := zzz_vproto_internal_new_cmsgclientserversavailable()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientserversavailable_server_types_available(cur_buf,
					tag_wiretype.wire_type) ?
				res.server_types_available << v
				i = ii
			}
			2 {
				i, res.server_type_for_auth_services = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientServersAvailable) eq(b CMsgClientServersAvailable) bool {
	return true && a.server_types_available.eq(b.server_types_available) && a.server_type_for_auth_services ==
		b.server_type_for_auth_services
}

[inline]
pub fn (a CMsgClientServersAvailable) ne(b CMsgClientServersAvailable) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientServersAvailable) eq(b []CMsgClientServersAvailable) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientServersAvailable) ne(b []CMsgClientServersAvailable) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientserversavailable() CMsgClientServersAvailable {
	return CMsgClientServersAvailable{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientserversavailable(o CMsgClientServersAvailable, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientserversavailable(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServersAvailable) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientserversavailable_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetUserStats {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	game_id              u64
	crc_stats            u32
	schema_local_version int
	steam_id_for_user    u64
}

pub fn (o &CMsgClientGetUserStats) pack() []byte {
	mut res := []byte{}
	if o.game_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_id, 1)
	}
	if o.crc_stats != u32(0) {
		res << vproto.pack_uint32_field(o.crc_stats, 2)
	}
	if o.schema_local_version != int(0) {
		res << vproto.pack_int32_field(o.schema_local_version, 3)
	}
	if o.steam_id_for_user != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id_for_user, 4)
	}
	return res
}

pub fn cmsgclientgetuserstats_unpack(buf []byte) ?CMsgClientGetUserStats {
	mut res := zzz_vproto_internal_new_cmsgclientgetuserstats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.game_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.crc_stats = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.schema_local_version = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.steam_id_for_user = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetUserStats) eq(b CMsgClientGetUserStats) bool {
	return true && a.game_id == b.game_id && a.crc_stats == b.crc_stats && a.schema_local_version ==
		b.schema_local_version && a.steam_id_for_user == b.steam_id_for_user
}

[inline]
pub fn (a CMsgClientGetUserStats) ne(b CMsgClientGetUserStats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetUserStats) eq(b []CMsgClientGetUserStats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetUserStats) ne(b []CMsgClientGetUserStats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetuserstats() CMsgClientGetUserStats {
	return CMsgClientGetUserStats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstats(o CMsgClientGetUserStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetuserstats_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetUserStatsResponse_Stats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_id        u32
	stat_value     u32
}

pub fn (o &CMsgClientGetUserStatsResponse_Stats) pack() []byte {
	mut res := []byte{}
	if o.stat_id != u32(0) {
		res << vproto.pack_uint32_field(o.stat_id, 1)
	}
	if o.stat_value != u32(0) {
		res << vproto.pack_uint32_field(o.stat_value, 2)
	}
	return res
}

pub fn cmsgclientgetuserstatsresponse_stats_unpack(buf []byte) ?CMsgClientGetUserStatsResponse_Stats {
	mut res := zzz_vproto_internal_new_cmsgclientgetuserstatsresponse_stats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.stat_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.stat_value = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetUserStatsResponse_Stats) eq(b CMsgClientGetUserStatsResponse_Stats) bool {
	return true && a.stat_id == b.stat_id && a.stat_value == b.stat_value
}

[inline]
pub fn (a CMsgClientGetUserStatsResponse_Stats) ne(b CMsgClientGetUserStatsResponse_Stats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetUserStatsResponse_Stats) eq(b []CMsgClientGetUserStatsResponse_Stats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetUserStatsResponse_Stats) ne(b []CMsgClientGetUserStatsResponse_Stats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetuserstatsresponse_stats() CMsgClientGetUserStatsResponse_Stats {
	return CMsgClientGetUserStatsResponse_Stats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse_stats(o CMsgClientGetUserStatsResponse_Stats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse_stats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStatsResponse_Stats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetuserstatsresponse_stats_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetUserStatsResponse_Achievement_Blocks {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	achievement_id u32
	unlock_time    []u32
}

pub fn (o &CMsgClientGetUserStatsResponse_Achievement_Blocks) pack() []byte {
	mut res := []byte{}
	if o.achievement_id != u32(0) {
		res << vproto.pack_uint32_field(o.achievement_id, 1)
	}
	// [packed=false]
	for _, x in o.unlock_time {
		res << vproto.pack_32bit_field(x, 2)
	}
	return res
}

pub fn cmsgclientgetuserstatsresponse_achievement_blocks_unpack(buf []byte) ?CMsgClientGetUserStatsResponse_Achievement_Blocks {
	mut res := zzz_vproto_internal_new_cmsgclientgetuserstatsresponse_achievement_blocks()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.achievement_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.unlock_time << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetUserStatsResponse_Achievement_Blocks) eq(b CMsgClientGetUserStatsResponse_Achievement_Blocks) bool {
	return true && a.achievement_id == b.achievement_id && a.unlock_time == b.unlock_time
}

[inline]
pub fn (a CMsgClientGetUserStatsResponse_Achievement_Blocks) ne(b CMsgClientGetUserStatsResponse_Achievement_Blocks) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetUserStatsResponse_Achievement_Blocks) eq(b []CMsgClientGetUserStatsResponse_Achievement_Blocks) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetUserStatsResponse_Achievement_Blocks) ne(b []CMsgClientGetUserStatsResponse_Achievement_Blocks) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetuserstatsresponse_achievement_blocks() CMsgClientGetUserStatsResponse_Achievement_Blocks {
	return CMsgClientGetUserStatsResponse_Achievement_Blocks{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse_achievement_blocks(o CMsgClientGetUserStatsResponse_Achievement_Blocks, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse_achievement_blocks(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStatsResponse_Achievement_Blocks) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetuserstatsresponse_achievement_blocks_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetUserStatsResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	game_id            u64
	eresult            int = 2
	crc_stats          u32
	schema             []byte
	stats              []CMsgClientGetUserStatsResponse_Stats
	achievement_blocks []CMsgClientGetUserStatsResponse_Achievement_Blocks
}

pub fn (o &CMsgClientGetUserStatsResponse) pack() []byte {
	mut res := []byte{}
	if o.game_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_id, 1)
	}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 2)
	}
	if o.crc_stats != u32(0) {
		res << vproto.pack_uint32_field(o.crc_stats, 3)
	}
	if o.schema != []byte{} {
		res << vproto.pack_bytes_field(o.schema, 4)
	}
	// [packed=false]
	for _, x in o.stats {
		res << zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse_stats(x, 5)
	}
	// [packed=false]
	for _, x in o.achievement_blocks {
		res <<
			zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse_achievement_blocks(x, 6)
	}
	return res
}

pub fn cmsgclientgetuserstatsresponse_unpack(buf []byte) ?CMsgClientGetUserStatsResponse {
	mut res := zzz_vproto_internal_new_cmsgclientgetuserstatsresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.game_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.crc_stats = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.schema = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse_stats(cur_buf,
					tag_wiretype.wire_type) ?
				res.stats << v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse_achievement_blocks(cur_buf,
					tag_wiretype.wire_type) ?
				res.achievement_blocks << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetUserStatsResponse) eq(b CMsgClientGetUserStatsResponse) bool {
	return true && a.game_id == b.game_id && a.eresult == b.eresult && a.crc_stats == b.crc_stats &&
		a.schema == b.schema && a.stats.eq(b.stats) && a.achievement_blocks.eq(b.achievement_blocks)
}

[inline]
pub fn (a CMsgClientGetUserStatsResponse) ne(b CMsgClientGetUserStatsResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetUserStatsResponse) eq(b []CMsgClientGetUserStatsResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetUserStatsResponse) ne(b []CMsgClientGetUserStatsResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetuserstatsresponse() CMsgClientGetUserStatsResponse {
	return CMsgClientGetUserStatsResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse(o CMsgClientGetUserStatsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStatsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetuserstatsresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	stat_id             u32
	reverted_stat_value u32
}

pub fn (o &CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) pack() []byte {
	mut res := []byte{}
	if o.stat_id != u32(0) {
		res << vproto.pack_uint32_field(o.stat_id, 1)
	}
	if o.reverted_stat_value != u32(0) {
		res << vproto.pack_uint32_field(o.reverted_stat_value, 2)
	}
	return res
}

pub fn cmsgclientstoreuserstatsresponse_stats_failed_validation_unpack(buf []byte) ?CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
	mut res := zzz_vproto_internal_new_cmsgclientstoreuserstatsresponse_stats_failed_validation()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.stat_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.reverted_stat_value = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) eq(b CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) bool {
	return true && a.stat_id == b.stat_id && a.reverted_stat_value == b.reverted_stat_value
}

[inline]
pub fn (a CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) ne(b CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) eq(b []CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) ne(b []CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstatsresponse_stats_failed_validation() CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
	return CMsgClientStoreUserStatsResponse_Stats_Failed_Validation{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstatsresponse_stats_failed_validation(o CMsgClientStoreUserStatsResponse_Stats_Failed_Validation, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstatsresponse_stats_failed_validation(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientstoreuserstatsresponse_stats_failed_validation_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientStoreUserStatsResponse {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	game_id                 u64
	eresult                 int = 2
	crc_stats               u32
	stats_failed_validation []CMsgClientStoreUserStatsResponse_Stats_Failed_Validation
	stats_out_of_date       bool
}

pub fn (o &CMsgClientStoreUserStatsResponse) pack() []byte {
	mut res := []byte{}
	if o.game_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_id, 1)
	}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 2)
	}
	if o.crc_stats != u32(0) {
		res << vproto.pack_uint32_field(o.crc_stats, 3)
	}
	// [packed=false]
	for _, x in o.stats_failed_validation {
		res <<
			zzz_vproto_internal_pack_cmsgclientstoreuserstatsresponse_stats_failed_validation(x, 4)
	}
	if o.stats_out_of_date != false {
		res << vproto.pack_bool_field(o.stats_out_of_date, 5)
	}
	return res
}

pub fn cmsgclientstoreuserstatsresponse_unpack(buf []byte) ?CMsgClientStoreUserStatsResponse {
	mut res := zzz_vproto_internal_new_cmsgclientstoreuserstatsresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.game_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.crc_stats = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientstoreuserstatsresponse_stats_failed_validation(cur_buf,
					tag_wiretype.wire_type) ?
				res.stats_failed_validation << v
				i = ii
			}
			5 {
				i, res.stats_out_of_date = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientStoreUserStatsResponse) eq(b CMsgClientStoreUserStatsResponse) bool {
	return true && a.game_id == b.game_id && a.eresult == b.eresult && a.crc_stats == b.crc_stats &&
		a.stats_failed_validation.eq(b.stats_failed_validation) && a.stats_out_of_date == b.stats_out_of_date
}

[inline]
pub fn (a CMsgClientStoreUserStatsResponse) ne(b CMsgClientStoreUserStatsResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientStoreUserStatsResponse) eq(b []CMsgClientStoreUserStatsResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientStoreUserStatsResponse) ne(b []CMsgClientStoreUserStatsResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstatsresponse() CMsgClientStoreUserStatsResponse {
	return CMsgClientStoreUserStatsResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstatsresponse(o CMsgClientStoreUserStatsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStatsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientstoreuserstatsresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientStoreUserStats2_Stats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_id        u32
	stat_value     u32
}

pub fn (o &CMsgClientStoreUserStats2_Stats) pack() []byte {
	mut res := []byte{}
	if o.stat_id != u32(0) {
		res << vproto.pack_uint32_field(o.stat_id, 1)
	}
	if o.stat_value != u32(0) {
		res << vproto.pack_uint32_field(o.stat_value, 2)
	}
	return res
}

pub fn cmsgclientstoreuserstats2_stats_unpack(buf []byte) ?CMsgClientStoreUserStats2_Stats {
	mut res := zzz_vproto_internal_new_cmsgclientstoreuserstats2_stats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.stat_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.stat_value = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientStoreUserStats2_Stats) eq(b CMsgClientStoreUserStats2_Stats) bool {
	return true && a.stat_id == b.stat_id && a.stat_value == b.stat_value
}

[inline]
pub fn (a CMsgClientStoreUserStats2_Stats) ne(b CMsgClientStoreUserStats2_Stats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientStoreUserStats2_Stats) eq(b []CMsgClientStoreUserStats2_Stats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientStoreUserStats2_Stats) ne(b []CMsgClientStoreUserStats2_Stats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats2_stats() CMsgClientStoreUserStats2_Stats {
	return CMsgClientStoreUserStats2_Stats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats2_stats(o CMsgClientStoreUserStats2_Stats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats2_stats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats2_Stats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientstoreuserstats2_stats_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientStoreUserStats2 {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	game_id         u64
	settor_steam_id u64
	settee_steam_id u64
	crc_stats       u32
	explicit_reset  bool
	stats           []CMsgClientStoreUserStats2_Stats
}

pub fn (o &CMsgClientStoreUserStats2) pack() []byte {
	mut res := []byte{}
	if o.game_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_id, 1)
	}
	if o.settor_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.settor_steam_id, 2)
	}
	if o.settee_steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.settee_steam_id, 3)
	}
	if o.crc_stats != u32(0) {
		res << vproto.pack_uint32_field(o.crc_stats, 4)
	}
	if o.explicit_reset != false {
		res << vproto.pack_bool_field(o.explicit_reset, 5)
	}
	// [packed=false]
	for _, x in o.stats {
		res << zzz_vproto_internal_pack_cmsgclientstoreuserstats2_stats(x, 6)
	}
	return res
}

pub fn cmsgclientstoreuserstats2_unpack(buf []byte) ?CMsgClientStoreUserStats2 {
	mut res := zzz_vproto_internal_new_cmsgclientstoreuserstats2()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.game_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.settor_steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.settee_steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.crc_stats = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.explicit_reset = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientstoreuserstats2_stats(cur_buf,
					tag_wiretype.wire_type) ?
				res.stats << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientStoreUserStats2) eq(b CMsgClientStoreUserStats2) bool {
	return true && a.game_id == b.game_id && a.settor_steam_id == b.settor_steam_id &&
		a.settee_steam_id == b.settee_steam_id && a.crc_stats == b.crc_stats && a.explicit_reset == b.explicit_reset &&
		a.stats.eq(b.stats)
}

[inline]
pub fn (a CMsgClientStoreUserStats2) ne(b CMsgClientStoreUserStats2) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientStoreUserStats2) eq(b []CMsgClientStoreUserStats2) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientStoreUserStats2) ne(b []CMsgClientStoreUserStats2) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats2() CMsgClientStoreUserStats2 {
	return CMsgClientStoreUserStats2{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats2(o CMsgClientStoreUserStats2, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats2(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats2) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientstoreuserstats2_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientStatsUpdated_Updated_Stats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_id        u32
	stat_value     u32
}

pub fn (o &CMsgClientStatsUpdated_Updated_Stats) pack() []byte {
	mut res := []byte{}
	if o.stat_id != u32(0) {
		res << vproto.pack_uint32_field(o.stat_id, 1)
	}
	if o.stat_value != u32(0) {
		res << vproto.pack_uint32_field(o.stat_value, 2)
	}
	return res
}

pub fn cmsgclientstatsupdated_updated_stats_unpack(buf []byte) ?CMsgClientStatsUpdated_Updated_Stats {
	mut res := zzz_vproto_internal_new_cmsgclientstatsupdated_updated_stats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.stat_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.stat_value = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientStatsUpdated_Updated_Stats) eq(b CMsgClientStatsUpdated_Updated_Stats) bool {
	return true && a.stat_id == b.stat_id && a.stat_value == b.stat_value
}

[inline]
pub fn (a CMsgClientStatsUpdated_Updated_Stats) ne(b CMsgClientStatsUpdated_Updated_Stats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientStatsUpdated_Updated_Stats) eq(b []CMsgClientStatsUpdated_Updated_Stats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientStatsUpdated_Updated_Stats) ne(b []CMsgClientStatsUpdated_Updated_Stats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientstatsupdated_updated_stats() CMsgClientStatsUpdated_Updated_Stats {
	return CMsgClientStatsUpdated_Updated_Stats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientstatsupdated_updated_stats(o CMsgClientStatsUpdated_Updated_Stats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientstatsupdated_updated_stats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStatsUpdated_Updated_Stats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientstatsupdated_updated_stats_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientStatsUpdated {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	game_id        u64
	crc_stats      u32
	updated_stats  []CMsgClientStatsUpdated_Updated_Stats
}

pub fn (o &CMsgClientStatsUpdated) pack() []byte {
	mut res := []byte{}
	if o.steam_id != u64(0) {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.game_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_id, 2)
	}
	if o.crc_stats != u32(0) {
		res << vproto.pack_uint32_field(o.crc_stats, 3)
	}
	// [packed=false]
	for _, x in o.updated_stats {
		res << zzz_vproto_internal_pack_cmsgclientstatsupdated_updated_stats(x, 4)
	}
	return res
}

pub fn cmsgclientstatsupdated_unpack(buf []byte) ?CMsgClientStatsUpdated {
	mut res := zzz_vproto_internal_new_cmsgclientstatsupdated()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steam_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.game_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.crc_stats = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientstatsupdated_updated_stats(cur_buf,
					tag_wiretype.wire_type) ?
				res.updated_stats << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientStatsUpdated) eq(b CMsgClientStatsUpdated) bool {
	return true && a.steam_id == b.steam_id && a.game_id == b.game_id && a.crc_stats == b.crc_stats &&
		a.updated_stats.eq(b.updated_stats)
}

[inline]
pub fn (a CMsgClientStatsUpdated) ne(b CMsgClientStatsUpdated) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientStatsUpdated) eq(b []CMsgClientStatsUpdated) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientStatsUpdated) ne(b []CMsgClientStatsUpdated) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientstatsupdated() CMsgClientStatsUpdated {
	return CMsgClientStatsUpdated{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientstatsupdated(o CMsgClientStatsUpdated, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientstatsupdated(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStatsUpdated) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientstatsupdated_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientStoreUserStats_Stats_To_Store {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_id        u32
	stat_value     u32
}

pub fn (o &CMsgClientStoreUserStats_Stats_To_Store) pack() []byte {
	mut res := []byte{}
	if o.stat_id != u32(0) {
		res << vproto.pack_uint32_field(o.stat_id, 1)
	}
	if o.stat_value != u32(0) {
		res << vproto.pack_uint32_field(o.stat_value, 2)
	}
	return res
}

pub fn cmsgclientstoreuserstats_stats_to_store_unpack(buf []byte) ?CMsgClientStoreUserStats_Stats_To_Store {
	mut res := zzz_vproto_internal_new_cmsgclientstoreuserstats_stats_to_store()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.stat_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.stat_value = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientStoreUserStats_Stats_To_Store) eq(b CMsgClientStoreUserStats_Stats_To_Store) bool {
	return true && a.stat_id == b.stat_id && a.stat_value == b.stat_value
}

[inline]
pub fn (a CMsgClientStoreUserStats_Stats_To_Store) ne(b CMsgClientStoreUserStats_Stats_To_Store) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientStoreUserStats_Stats_To_Store) eq(b []CMsgClientStoreUserStats_Stats_To_Store) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientStoreUserStats_Stats_To_Store) ne(b []CMsgClientStoreUserStats_Stats_To_Store) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats_stats_to_store() CMsgClientStoreUserStats_Stats_To_Store {
	return CMsgClientStoreUserStats_Stats_To_Store{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats_stats_to_store(o CMsgClientStoreUserStats_Stats_To_Store, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats_stats_to_store(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats_Stats_To_Store) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientstoreuserstats_stats_to_store_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientStoreUserStats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	game_id        u64
	explicit_reset bool
	stats_to_store []CMsgClientStoreUserStats_Stats_To_Store
}

pub fn (o &CMsgClientStoreUserStats) pack() []byte {
	mut res := []byte{}
	if o.game_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_id, 1)
	}
	if o.explicit_reset != false {
		res << vproto.pack_bool_field(o.explicit_reset, 2)
	}
	// [packed=false]
	for _, x in o.stats_to_store {
		res << zzz_vproto_internal_pack_cmsgclientstoreuserstats_stats_to_store(x, 3)
	}
	return res
}

pub fn cmsgclientstoreuserstats_unpack(buf []byte) ?CMsgClientStoreUserStats {
	mut res := zzz_vproto_internal_new_cmsgclientstoreuserstats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.game_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.explicit_reset = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientstoreuserstats_stats_to_store(cur_buf,
					tag_wiretype.wire_type) ?
				res.stats_to_store << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientStoreUserStats) eq(b CMsgClientStoreUserStats) bool {
	return true && a.game_id == b.game_id && a.explicit_reset == b.explicit_reset && a.stats_to_store.eq(b.stats_to_store)
}

[inline]
pub fn (a CMsgClientStoreUserStats) ne(b CMsgClientStoreUserStats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientStoreUserStats) eq(b []CMsgClientStoreUserStats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientStoreUserStats) ne(b []CMsgClientStoreUserStats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats() CMsgClientStoreUserStats {
	return CMsgClientStoreUserStats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats(o CMsgClientStoreUserStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientstoreuserstats_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetClientDetails {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientGetClientDetails) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientgetclientdetails_unpack(buf []byte) ?CMsgClientGetClientDetails {
	res := zzz_vproto_internal_new_cmsgclientgetclientdetails()
	return res
}

[inline]
pub fn (a CMsgClientGetClientDetails) eq(b CMsgClientGetClientDetails) bool {
	return true
}

[inline]
pub fn (a CMsgClientGetClientDetails) ne(b CMsgClientGetClientDetails) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetClientDetails) eq(b []CMsgClientGetClientDetails) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetClientDetails) ne(b []CMsgClientGetClientDetails) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetclientdetails() CMsgClientGetClientDetails {
	return CMsgClientGetClientDetails{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetclientdetails(o CMsgClientGetClientDetails, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientdetails(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientDetails) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetclientdetails_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientReportOverlayDetourFailure {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	failure_strings []string
}

pub fn (o &CMsgClientReportOverlayDetourFailure) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.failure_strings {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn cmsgclientreportoverlaydetourfailure_unpack(buf []byte) ?CMsgClientReportOverlayDetourFailure {
	mut res := zzz_vproto_internal_new_cmsgclientreportoverlaydetourfailure()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.failure_strings << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientReportOverlayDetourFailure) eq(b CMsgClientReportOverlayDetourFailure) bool {
	return true && a.failure_strings == b.failure_strings
}

[inline]
pub fn (a CMsgClientReportOverlayDetourFailure) ne(b CMsgClientReportOverlayDetourFailure) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientReportOverlayDetourFailure) eq(b []CMsgClientReportOverlayDetourFailure) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientReportOverlayDetourFailure) ne(b []CMsgClientReportOverlayDetourFailure) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientreportoverlaydetourfailure() CMsgClientReportOverlayDetourFailure {
	return CMsgClientReportOverlayDetourFailure{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientreportoverlaydetourfailure(o CMsgClientReportOverlayDetourFailure, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientreportoverlaydetourfailure(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientReportOverlayDetourFailure) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientreportoverlaydetourfailure_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetClientDetailsResponse_Game {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	extra_info       string
	time_running_sec u32
}

pub fn (o &CMsgClientGetClientDetailsResponse_Game) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.extra_info != '' {
		res << vproto.pack_string_field(o.extra_info, 2)
	}
	if o.time_running_sec != u32(0) {
		res << vproto.pack_uint32_field(o.time_running_sec, 3)
	}
	return res
}

pub fn cmsgclientgetclientdetailsresponse_game_unpack(buf []byte) ?CMsgClientGetClientDetailsResponse_Game {
	mut res := zzz_vproto_internal_new_cmsgclientgetclientdetailsresponse_game()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.extra_info = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.time_running_sec = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetClientDetailsResponse_Game) eq(b CMsgClientGetClientDetailsResponse_Game) bool {
	return true && a.appid == b.appid && a.extra_info == b.extra_info && a.time_running_sec ==
		b.time_running_sec
}

[inline]
pub fn (a CMsgClientGetClientDetailsResponse_Game) ne(b CMsgClientGetClientDetailsResponse_Game) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetClientDetailsResponse_Game) eq(b []CMsgClientGetClientDetailsResponse_Game) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetClientDetailsResponse_Game) ne(b []CMsgClientGetClientDetailsResponse_Game) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetclientdetailsresponse_game() CMsgClientGetClientDetailsResponse_Game {
	return CMsgClientGetClientDetailsResponse_Game{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetclientdetailsresponse_game(o CMsgClientGetClientDetailsResponse_Game, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientdetailsresponse_game(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientDetailsResponse_Game) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetclientdetailsresponse_game_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetClientDetailsResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	package_version  u32
	protocol_version u32
	os               string
	machine_name     string
	ip_public        string
	ip_private       string
	bytes_available  u64
	games_running    []CMsgClientGetClientDetailsResponse_Game
}

pub fn (o &CMsgClientGetClientDetailsResponse) pack() []byte {
	mut res := []byte{}
	if o.package_version != u32(0) {
		res << vproto.pack_uint32_field(o.package_version, 1)
	}
	if o.protocol_version != u32(0) {
		res << vproto.pack_uint32_field(o.protocol_version, 8)
	}
	if o.os != '' {
		res << vproto.pack_string_field(o.os, 2)
	}
	if o.machine_name != '' {
		res << vproto.pack_string_field(o.machine_name, 3)
	}
	if o.ip_public != '' {
		res << vproto.pack_string_field(o.ip_public, 4)
	}
	if o.ip_private != '' {
		res << vproto.pack_string_field(o.ip_private, 5)
	}
	if o.bytes_available != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_available, 7)
	}
	// [packed=false]
	for _, x in o.games_running {
		res << zzz_vproto_internal_pack_cmsgclientgetclientdetailsresponse_game(x, 6)
	}
	return res
}

pub fn cmsgclientgetclientdetailsresponse_unpack(buf []byte) ?CMsgClientGetClientDetailsResponse {
	mut res := zzz_vproto_internal_new_cmsgclientgetclientdetailsresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.package_version = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.protocol_version = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.os = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.machine_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.ip_public = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.ip_private = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.bytes_available = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetclientdetailsresponse_game(cur_buf,
					tag_wiretype.wire_type) ?
				res.games_running << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetClientDetailsResponse) eq(b CMsgClientGetClientDetailsResponse) bool {
	return true && a.package_version == b.package_version && a.protocol_version == b.protocol_version &&
		a.os == b.os && a.machine_name == b.machine_name && a.ip_public == b.ip_public && a.ip_private ==
		b.ip_private && a.bytes_available == b.bytes_available && a.games_running.eq(b.games_running)
}

[inline]
pub fn (a CMsgClientGetClientDetailsResponse) ne(b CMsgClientGetClientDetailsResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetClientDetailsResponse) eq(b []CMsgClientGetClientDetailsResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetClientDetailsResponse) ne(b []CMsgClientGetClientDetailsResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetclientdetailsresponse() CMsgClientGetClientDetailsResponse {
	return CMsgClientGetClientDetailsResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetclientdetailsresponse(o CMsgClientGetClientDetailsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientdetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientDetailsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetclientdetailsresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetClientAppList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	media          bool
	tools          bool
	games          bool
	only_installed bool
	only_changing  bool
	comics         bool
}

pub fn (o &CMsgClientGetClientAppList) pack() []byte {
	mut res := []byte{}
	if o.media != false {
		res << vproto.pack_bool_field(o.media, 1)
	}
	if o.tools != false {
		res << vproto.pack_bool_field(o.tools, 2)
	}
	if o.games != false {
		res << vproto.pack_bool_field(o.games, 3)
	}
	if o.only_installed != false {
		res << vproto.pack_bool_field(o.only_installed, 4)
	}
	if o.only_changing != false {
		res << vproto.pack_bool_field(o.only_changing, 5)
	}
	if o.comics != false {
		res << vproto.pack_bool_field(o.comics, 6)
	}
	return res
}

pub fn cmsgclientgetclientapplist_unpack(buf []byte) ?CMsgClientGetClientAppList {
	mut res := zzz_vproto_internal_new_cmsgclientgetclientapplist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.media = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.tools = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.games = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.only_installed = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.only_changing = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.comics = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetClientAppList) eq(b CMsgClientGetClientAppList) bool {
	return true && a.media == b.media && a.tools == b.tools && a.games == b.games && a.only_installed ==
		b.only_installed && a.only_changing == b.only_changing && a.comics == b.comics
}

[inline]
pub fn (a CMsgClientGetClientAppList) ne(b CMsgClientGetClientAppList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetClientAppList) eq(b []CMsgClientGetClientAppList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetClientAppList) ne(b []CMsgClientGetClientAppList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplist() CMsgClientGetClientAppList {
	return CMsgClientGetClientAppList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplist(o CMsgClientGetClientAppList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetclientapplist_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetClientAppListResponseApp_DLC {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	installed      bool
}

pub fn (o &CMsgClientGetClientAppListResponseApp_DLC) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.installed != false {
		res << vproto.pack_bool_field(o.installed, 2)
	}
	return res
}

pub fn cmsgclientgetclientapplistresponseapp_dlc_unpack(buf []byte) ?CMsgClientGetClientAppListResponseApp_DLC {
	mut res := zzz_vproto_internal_new_cmsgclientgetclientapplistresponseapp_dlc()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.installed = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetClientAppListResponseApp_DLC) eq(b CMsgClientGetClientAppListResponseApp_DLC) bool {
	return true && a.appid == b.appid && a.installed == b.installed
}

[inline]
pub fn (a CMsgClientGetClientAppListResponseApp_DLC) ne(b CMsgClientGetClientAppListResponseApp_DLC) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetClientAppListResponseApp_DLC) eq(b []CMsgClientGetClientAppListResponseApp_DLC) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetClientAppListResponseApp_DLC) ne(b []CMsgClientGetClientAppListResponseApp_DLC) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplistresponseapp_dlc() CMsgClientGetClientAppListResponseApp_DLC {
	return CMsgClientGetClientAppListResponseApp_DLC{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplistresponseapp_dlc(o CMsgClientGetClientAppListResponseApp_DLC, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponseapp_dlc(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppListResponseApp_DLC) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetclientapplistresponseapp_dlc_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetClientAppListResponse_App {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	appid                 u32
	category              string
	app_type              string
	favorite              bool
	installed             bool
	auto_update           bool
	bytes_downloaded      u64
	bytes_needed          u64
	bytes_download_rate   u32
	download_paused       bool
	num_downloading       u32
	num_paused            u32
	changing              bool
	available_on_platform bool
	dlcs                  []CMsgClientGetClientAppListResponseApp_DLC
}

pub fn (o &CMsgClientGetClientAppListResponse_App) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.category != '' {
		res << vproto.pack_string_field(o.category, 2)
	}
	if o.app_type != '' {
		res << vproto.pack_string_field(o.app_type, 10)
	}
	if o.favorite != false {
		res << vproto.pack_bool_field(o.favorite, 3)
	}
	if o.installed != false {
		res << vproto.pack_bool_field(o.installed, 4)
	}
	if o.auto_update != false {
		res << vproto.pack_bool_field(o.auto_update, 5)
	}
	if o.bytes_downloaded != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_downloaded, 6)
	}
	if o.bytes_needed != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_needed, 7)
	}
	if o.bytes_download_rate != u32(0) {
		res << vproto.pack_uint32_field(o.bytes_download_rate, 8)
	}
	if o.download_paused != false {
		res << vproto.pack_bool_field(o.download_paused, 11)
	}
	if o.num_downloading != u32(0) {
		res << vproto.pack_uint32_field(o.num_downloading, 12)
	}
	if o.num_paused != u32(0) {
		res << vproto.pack_uint32_field(o.num_paused, 13)
	}
	if o.changing != false {
		res << vproto.pack_bool_field(o.changing, 14)
	}
	if o.available_on_platform != false {
		res << vproto.pack_bool_field(o.available_on_platform, 15)
	}
	// [packed=false]
	for _, x in o.dlcs {
		res <<
			zzz_vproto_internal_pack_cmsgclientgetclientapplistresponseapp_dlc(x, 9)
	}
	return res
}

pub fn cmsgclientgetclientapplistresponse_app_unpack(buf []byte) ?CMsgClientGetClientAppListResponse_App {
	mut res := zzz_vproto_internal_new_cmsgclientgetclientapplistresponse_app()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.category = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.app_type = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.favorite = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.installed = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.auto_update = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.bytes_downloaded = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.bytes_needed = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.bytes_download_rate = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				i, res.download_paused = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			12 {
				i, res.num_downloading = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			13 {
				i, res.num_paused = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			14 {
				i, res.changing = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			15 {
				i, res.available_on_platform = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponseapp_dlc(cur_buf,
					tag_wiretype.wire_type) ?
				res.dlcs << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetClientAppListResponse_App) eq(b CMsgClientGetClientAppListResponse_App) bool {
	return true && a.appid == b.appid && a.category == b.category && a.app_type == b.app_type &&
		a.favorite == b.favorite && a.installed == b.installed && a.auto_update == b.auto_update &&
		a.bytes_downloaded == b.bytes_downloaded && a.bytes_needed == b.bytes_needed && a.bytes_download_rate ==
		b.bytes_download_rate && a.download_paused == b.download_paused && a.num_downloading == b.num_downloading &&
		a.num_paused == b.num_paused && a.changing == b.changing && a.available_on_platform == b.available_on_platform &&
		a.dlcs.eq(b.dlcs)
}

[inline]
pub fn (a CMsgClientGetClientAppListResponse_App) ne(b CMsgClientGetClientAppListResponse_App) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetClientAppListResponse_App) eq(b []CMsgClientGetClientAppListResponse_App) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetClientAppListResponse_App) ne(b []CMsgClientGetClientAppListResponse_App) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplistresponse_app() CMsgClientGetClientAppListResponse_App {
	return CMsgClientGetClientAppListResponse_App{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplistresponse_app(o CMsgClientGetClientAppListResponse_App, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponse_app(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppListResponse_App) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetclientapplistresponse_app_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientGetClientAppListResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	apps            []CMsgClientGetClientAppListResponse_App
	bytes_available u64
}

pub fn (o &CMsgClientGetClientAppListResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgclientgetclientapplistresponse_app(x, 1)
	}
	if o.bytes_available != u64(0) {
		res << vproto.pack_uint64_field(o.bytes_available, 2)
	}
	return res
}

pub fn cmsgclientgetclientapplistresponse_unpack(buf []byte) ?CMsgClientGetClientAppListResponse {
	mut res := zzz_vproto_internal_new_cmsgclientgetclientapplistresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponse_app(cur_buf,
					tag_wiretype.wire_type) ?
				res.apps << v
				i = ii
			}
			2 {
				i, res.bytes_available = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientGetClientAppListResponse) eq(b CMsgClientGetClientAppListResponse) bool {
	return true && a.apps.eq(b.apps) && a.bytes_available == b.bytes_available
}

[inline]
pub fn (a CMsgClientGetClientAppListResponse) ne(b CMsgClientGetClientAppListResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientGetClientAppListResponse) eq(b []CMsgClientGetClientAppListResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientGetClientAppListResponse) ne(b []CMsgClientGetClientAppListResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplistresponse() CMsgClientGetClientAppListResponse {
	return CMsgClientGetClientAppListResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplistresponse(o CMsgClientGetClientAppListResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppListResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientgetclientapplistresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientInstallClientApp {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
}

pub fn (o &CMsgClientInstallClientApp) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cmsgclientinstallclientapp_unpack(buf []byte) ?CMsgClientInstallClientApp {
	mut res := zzz_vproto_internal_new_cmsgclientinstallclientapp()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientInstallClientApp) eq(b CMsgClientInstallClientApp) bool {
	return true && a.appid == b.appid
}

[inline]
pub fn (a CMsgClientInstallClientApp) ne(b CMsgClientInstallClientApp) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientInstallClientApp) eq(b []CMsgClientInstallClientApp) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientInstallClientApp) ne(b []CMsgClientInstallClientApp) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientinstallclientapp() CMsgClientInstallClientApp {
	return CMsgClientInstallClientApp{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientinstallclientapp(o CMsgClientInstallClientApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientinstallclientapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientInstallClientApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientinstallclientapp_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientInstallClientAppResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         u32
}

pub fn (o &CMsgClientInstallClientAppResponse) pack() []byte {
	mut res := []byte{}
	if o.result != u32(0) {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	return res
}

pub fn cmsgclientinstallclientappresponse_unpack(buf []byte) ?CMsgClientInstallClientAppResponse {
	mut res := zzz_vproto_internal_new_cmsgclientinstallclientappresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.result = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientInstallClientAppResponse) eq(b CMsgClientInstallClientAppResponse) bool {
	return true && a.result == b.result
}

[inline]
pub fn (a CMsgClientInstallClientAppResponse) ne(b CMsgClientInstallClientAppResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientInstallClientAppResponse) eq(b []CMsgClientInstallClientAppResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientInstallClientAppResponse) ne(b []CMsgClientInstallClientAppResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientinstallclientappresponse() CMsgClientInstallClientAppResponse {
	return CMsgClientInstallClientAppResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientinstallclientappresponse(o CMsgClientInstallClientAppResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientinstallclientappresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientInstallClientAppResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientinstallclientappresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUninstallClientApp {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
}

pub fn (o &CMsgClientUninstallClientApp) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cmsgclientuninstallclientapp_unpack(buf []byte) ?CMsgClientUninstallClientApp {
	mut res := zzz_vproto_internal_new_cmsgclientuninstallclientapp()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUninstallClientApp) eq(b CMsgClientUninstallClientApp) bool {
	return true && a.appid == b.appid
}

[inline]
pub fn (a CMsgClientUninstallClientApp) ne(b CMsgClientUninstallClientApp) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUninstallClientApp) eq(b []CMsgClientUninstallClientApp) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUninstallClientApp) ne(b []CMsgClientUninstallClientApp) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientuninstallclientapp() CMsgClientUninstallClientApp {
	return CMsgClientUninstallClientApp{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientuninstallclientapp(o CMsgClientUninstallClientApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientuninstallclientapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUninstallClientApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientuninstallclientapp_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUninstallClientAppResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         u32
}

pub fn (o &CMsgClientUninstallClientAppResponse) pack() []byte {
	mut res := []byte{}
	if o.result != u32(0) {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	return res
}

pub fn cmsgclientuninstallclientappresponse_unpack(buf []byte) ?CMsgClientUninstallClientAppResponse {
	mut res := zzz_vproto_internal_new_cmsgclientuninstallclientappresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.result = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUninstallClientAppResponse) eq(b CMsgClientUninstallClientAppResponse) bool {
	return true && a.result == b.result
}

[inline]
pub fn (a CMsgClientUninstallClientAppResponse) ne(b CMsgClientUninstallClientAppResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUninstallClientAppResponse) eq(b []CMsgClientUninstallClientAppResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUninstallClientAppResponse) ne(b []CMsgClientUninstallClientAppResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientuninstallclientappresponse() CMsgClientUninstallClientAppResponse {
	return CMsgClientUninstallClientAppResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientuninstallclientappresponse(o CMsgClientUninstallClientAppResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientuninstallclientappresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUninstallClientAppResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientuninstallclientappresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSetClientAppUpdateState {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	update         bool
}

pub fn (o &CMsgClientSetClientAppUpdateState) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.update != false {
		res << vproto.pack_bool_field(o.update, 2)
	}
	return res
}

pub fn cmsgclientsetclientappupdatestate_unpack(buf []byte) ?CMsgClientSetClientAppUpdateState {
	mut res := zzz_vproto_internal_new_cmsgclientsetclientappupdatestate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.update = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSetClientAppUpdateState) eq(b CMsgClientSetClientAppUpdateState) bool {
	return true && a.appid == b.appid && a.update == b.update
}

[inline]
pub fn (a CMsgClientSetClientAppUpdateState) ne(b CMsgClientSetClientAppUpdateState) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSetClientAppUpdateState) eq(b []CMsgClientSetClientAppUpdateState) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSetClientAppUpdateState) ne(b []CMsgClientSetClientAppUpdateState) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsetclientappupdatestate() CMsgClientSetClientAppUpdateState {
	return CMsgClientSetClientAppUpdateState{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsetclientappupdatestate(o CMsgClientSetClientAppUpdateState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsetclientappupdatestate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSetClientAppUpdateState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsetclientappupdatestate_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientSetClientAppUpdateStateResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         u32
}

pub fn (o &CMsgClientSetClientAppUpdateStateResponse) pack() []byte {
	mut res := []byte{}
	if o.result != u32(0) {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	return res
}

pub fn cmsgclientsetclientappupdatestateresponse_unpack(buf []byte) ?CMsgClientSetClientAppUpdateStateResponse {
	mut res := zzz_vproto_internal_new_cmsgclientsetclientappupdatestateresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.result = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientSetClientAppUpdateStateResponse) eq(b CMsgClientSetClientAppUpdateStateResponse) bool {
	return true && a.result == b.result
}

[inline]
pub fn (a CMsgClientSetClientAppUpdateStateResponse) ne(b CMsgClientSetClientAppUpdateStateResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientSetClientAppUpdateStateResponse) eq(b []CMsgClientSetClientAppUpdateStateResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientSetClientAppUpdateStateResponse) ne(b []CMsgClientSetClientAppUpdateStateResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientsetclientappupdatestateresponse() CMsgClientSetClientAppUpdateStateResponse {
	return CMsgClientSetClientAppUpdateStateResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientsetclientappupdatestateresponse(o CMsgClientSetClientAppUpdateStateResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientsetclientappupdatestateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSetClientAppUpdateStateResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientsetclientappupdatestateresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSUploadFileRequest {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	app_id                       u32
	file_size                    u32
	raw_file_size                u32
	sha_file                     []byte
	time_stamp                   u64
	file_name                    string
	platforms_to_sync_deprecated u32
	platforms_to_sync            u32 = 4294967295
	cell_id                      u32
	can_encrypt                  bool
}

pub fn (o &CMsgClientUFSUploadFileRequest) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.file_size != u32(0) {
		res << vproto.pack_uint32_field(o.file_size, 2)
	}
	if o.raw_file_size != u32(0) {
		res << vproto.pack_uint32_field(o.raw_file_size, 3)
	}
	if o.sha_file != []byte{} {
		res << vproto.pack_bytes_field(o.sha_file, 4)
	}
	if o.time_stamp != u64(0) {
		res << vproto.pack_uint64_field(o.time_stamp, 5)
	}
	if o.file_name != '' {
		res << vproto.pack_string_field(o.file_name, 6)
	}
	if o.platforms_to_sync_deprecated != u32(0) {
		res << vproto.pack_uint32_field(o.platforms_to_sync_deprecated, 7)
	}
	if o.platforms_to_sync != u32(0) {
		res << vproto.pack_uint32_field(o.platforms_to_sync, 8)
	}
	if o.cell_id != u32(0) {
		res << vproto.pack_uint32_field(o.cell_id, 9)
	}
	if o.can_encrypt != false {
		res << vproto.pack_bool_field(o.can_encrypt, 10)
	}
	return res
}

pub fn cmsgclientufsuploadfilerequest_unpack(buf []byte) ?CMsgClientUFSUploadFileRequest {
	mut res := zzz_vproto_internal_new_cmsgclientufsuploadfilerequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.file_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.raw_file_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.sha_file = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.time_stamp = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.file_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.platforms_to_sync_deprecated = vproto.unpack_uint32_field(cur_buf,
					tag_wiretype.wire_type) ?
			}
			8 {
				i, res.platforms_to_sync = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.cell_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.can_encrypt = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSUploadFileRequest) eq(b CMsgClientUFSUploadFileRequest) bool {
	return true && a.app_id == b.app_id && a.file_size == b.file_size && a.raw_file_size == b.raw_file_size &&
		a.sha_file == b.sha_file && a.time_stamp == b.time_stamp && a.file_name == b.file_name &&
		a.platforms_to_sync_deprecated == b.platforms_to_sync_deprecated && a.platforms_to_sync == b.platforms_to_sync &&
		a.cell_id == b.cell_id && a.can_encrypt == b.can_encrypt
}

[inline]
pub fn (a CMsgClientUFSUploadFileRequest) ne(b CMsgClientUFSUploadFileRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSUploadFileRequest) eq(b []CMsgClientUFSUploadFileRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSUploadFileRequest) ne(b []CMsgClientUFSUploadFileRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsuploadfilerequest() CMsgClientUFSUploadFileRequest {
	return CMsgClientUFSUploadFileRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadfilerequest(o CMsgClientUFSUploadFileRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadfilerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadFileRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsuploadfilerequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSUploadFileResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	sha_file       []byte
	use_http       bool
	http_host      string
	http_url       string
	kv_headers     []byte
	use_https      bool
	encrypt_file   bool
}

pub fn (o &CMsgClientUFSUploadFileResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.sha_file != []byte{} {
		res << vproto.pack_bytes_field(o.sha_file, 2)
	}
	if o.use_http != false {
		res << vproto.pack_bool_field(o.use_http, 3)
	}
	if o.http_host != '' {
		res << vproto.pack_string_field(o.http_host, 4)
	}
	if o.http_url != '' {
		res << vproto.pack_string_field(o.http_url, 5)
	}
	if o.kv_headers != []byte{} {
		res << vproto.pack_bytes_field(o.kv_headers, 6)
	}
	if o.use_https != false {
		res << vproto.pack_bool_field(o.use_https, 7)
	}
	if o.encrypt_file != false {
		res << vproto.pack_bool_field(o.encrypt_file, 8)
	}
	return res
}

pub fn cmsgclientufsuploadfileresponse_unpack(buf []byte) ?CMsgClientUFSUploadFileResponse {
	mut res := zzz_vproto_internal_new_cmsgclientufsuploadfileresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.sha_file = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.use_http = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.http_host = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.http_url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.kv_headers = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.use_https = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.encrypt_file = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSUploadFileResponse) eq(b CMsgClientUFSUploadFileResponse) bool {
	return true && a.eresult == b.eresult && a.sha_file == b.sha_file && a.use_http == b.use_http &&
		a.http_host == b.http_host && a.http_url == b.http_url && a.kv_headers == b.kv_headers &&
		a.use_https == b.use_https && a.encrypt_file == b.encrypt_file
}

[inline]
pub fn (a CMsgClientUFSUploadFileResponse) ne(b CMsgClientUFSUploadFileResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSUploadFileResponse) eq(b []CMsgClientUFSUploadFileResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSUploadFileResponse) ne(b []CMsgClientUFSUploadFileResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsuploadfileresponse() CMsgClientUFSUploadFileResponse {
	return CMsgClientUFSUploadFileResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadfileresponse(o CMsgClientUFSUploadFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsuploadfileresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSUploadCommit_File {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	app_id         u32
	sha_file       []byte
	cub_file       u32
	file_name      string
}

pub fn (o &CMsgClientUFSUploadCommit_File) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.sha_file != []byte{} {
		res << vproto.pack_bytes_field(o.sha_file, 3)
	}
	if o.cub_file != u32(0) {
		res << vproto.pack_uint32_field(o.cub_file, 4)
	}
	if o.file_name != '' {
		res << vproto.pack_string_field(o.file_name, 5)
	}
	return res
}

pub fn cmsgclientufsuploadcommit_file_unpack(buf []byte) ?CMsgClientUFSUploadCommit_File {
	mut res := zzz_vproto_internal_new_cmsgclientufsuploadcommit_file()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.sha_file = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.cub_file = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.file_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSUploadCommit_File) eq(b CMsgClientUFSUploadCommit_File) bool {
	return true && a.eresult == b.eresult && a.app_id == b.app_id && a.sha_file == b.sha_file &&
		a.cub_file == b.cub_file && a.file_name == b.file_name
}

[inline]
pub fn (a CMsgClientUFSUploadCommit_File) ne(b CMsgClientUFSUploadCommit_File) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSUploadCommit_File) eq(b []CMsgClientUFSUploadCommit_File) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSUploadCommit_File) ne(b []CMsgClientUFSUploadCommit_File) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommit_file() CMsgClientUFSUploadCommit_File {
	return CMsgClientUFSUploadCommit_File{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommit_file(o CMsgClientUFSUploadCommit_File, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommit_file(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadCommit_File) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsuploadcommit_file_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSUploadCommit {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	files          []CMsgClientUFSUploadCommit_File
}

pub fn (o &CMsgClientUFSUploadCommit) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.files {
		res << zzz_vproto_internal_pack_cmsgclientufsuploadcommit_file(x, 1)
	}
	return res
}

pub fn cmsgclientufsuploadcommit_unpack(buf []byte) ?CMsgClientUFSUploadCommit {
	mut res := zzz_vproto_internal_new_cmsgclientufsuploadcommit()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientufsuploadcommit_file(cur_buf,
					tag_wiretype.wire_type) ?
				res.files << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSUploadCommit) eq(b CMsgClientUFSUploadCommit) bool {
	return true && a.files.eq(b.files)
}

[inline]
pub fn (a CMsgClientUFSUploadCommit) ne(b CMsgClientUFSUploadCommit) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSUploadCommit) eq(b []CMsgClientUFSUploadCommit) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSUploadCommit) ne(b []CMsgClientUFSUploadCommit) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommit() CMsgClientUFSUploadCommit {
	return CMsgClientUFSUploadCommit{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommit(o CMsgClientUFSUploadCommit, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommit(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadCommit) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsuploadcommit_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSUploadCommitResponse_File {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	app_id         u32
	sha_file       []byte
}

pub fn (o &CMsgClientUFSUploadCommitResponse_File) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.sha_file != []byte{} {
		res << vproto.pack_bytes_field(o.sha_file, 3)
	}
	return res
}

pub fn cmsgclientufsuploadcommitresponse_file_unpack(buf []byte) ?CMsgClientUFSUploadCommitResponse_File {
	mut res := zzz_vproto_internal_new_cmsgclientufsuploadcommitresponse_file()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.sha_file = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSUploadCommitResponse_File) eq(b CMsgClientUFSUploadCommitResponse_File) bool {
	return true && a.eresult == b.eresult && a.app_id == b.app_id && a.sha_file == b.sha_file
}

[inline]
pub fn (a CMsgClientUFSUploadCommitResponse_File) ne(b CMsgClientUFSUploadCommitResponse_File) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSUploadCommitResponse_File) eq(b []CMsgClientUFSUploadCommitResponse_File) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSUploadCommitResponse_File) ne(b []CMsgClientUFSUploadCommitResponse_File) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommitresponse_file() CMsgClientUFSUploadCommitResponse_File {
	return CMsgClientUFSUploadCommitResponse_File{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommitresponse_file(o CMsgClientUFSUploadCommitResponse_File, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommitresponse_file(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadCommitResponse_File) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsuploadcommitresponse_file_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSUploadCommitResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	files          []CMsgClientUFSUploadCommitResponse_File
}

pub fn (o &CMsgClientUFSUploadCommitResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.files {
		res << zzz_vproto_internal_pack_cmsgclientufsuploadcommitresponse_file(x, 1)
	}
	return res
}

pub fn cmsgclientufsuploadcommitresponse_unpack(buf []byte) ?CMsgClientUFSUploadCommitResponse {
	mut res := zzz_vproto_internal_new_cmsgclientufsuploadcommitresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientufsuploadcommitresponse_file(cur_buf,
					tag_wiretype.wire_type) ?
				res.files << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSUploadCommitResponse) eq(b CMsgClientUFSUploadCommitResponse) bool {
	return true && a.files.eq(b.files)
}

[inline]
pub fn (a CMsgClientUFSUploadCommitResponse) ne(b CMsgClientUFSUploadCommitResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSUploadCommitResponse) eq(b []CMsgClientUFSUploadCommitResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSUploadCommitResponse) ne(b []CMsgClientUFSUploadCommitResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommitresponse() CMsgClientUFSUploadCommitResponse {
	return CMsgClientUFSUploadCommitResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommitresponse(o CMsgClientUFSUploadCommitResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommitresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadCommitResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsuploadcommitresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSFileChunk {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sha_file       []byte
	file_start     u32
	data           []byte
}

pub fn (o &CMsgClientUFSFileChunk) pack() []byte {
	mut res := []byte{}
	if o.sha_file != []byte{} {
		res << vproto.pack_bytes_field(o.sha_file, 1)
	}
	if o.file_start != u32(0) {
		res << vproto.pack_uint32_field(o.file_start, 2)
	}
	if o.data != []byte{} {
		res << vproto.pack_bytes_field(o.data, 3)
	}
	return res
}

pub fn cmsgclientufsfilechunk_unpack(buf []byte) ?CMsgClientUFSFileChunk {
	mut res := zzz_vproto_internal_new_cmsgclientufsfilechunk()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.sha_file = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.file_start = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.data = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSFileChunk) eq(b CMsgClientUFSFileChunk) bool {
	return true && a.sha_file == b.sha_file && a.file_start == b.file_start && a.data == b.data
}

[inline]
pub fn (a CMsgClientUFSFileChunk) ne(b CMsgClientUFSFileChunk) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSFileChunk) eq(b []CMsgClientUFSFileChunk) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSFileChunk) ne(b []CMsgClientUFSFileChunk) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsfilechunk() CMsgClientUFSFileChunk {
	return CMsgClientUFSFileChunk{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsfilechunk(o CMsgClientUFSFileChunk, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsfilechunk(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSFileChunk) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsfilechunk_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSTransferHeartbeat {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientUFSTransferHeartbeat) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientufstransferheartbeat_unpack(buf []byte) ?CMsgClientUFSTransferHeartbeat {
	res := zzz_vproto_internal_new_cmsgclientufstransferheartbeat()
	return res
}

[inline]
pub fn (a CMsgClientUFSTransferHeartbeat) eq(b CMsgClientUFSTransferHeartbeat) bool {
	return true
}

[inline]
pub fn (a CMsgClientUFSTransferHeartbeat) ne(b CMsgClientUFSTransferHeartbeat) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSTransferHeartbeat) eq(b []CMsgClientUFSTransferHeartbeat) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSTransferHeartbeat) ne(b []CMsgClientUFSTransferHeartbeat) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufstransferheartbeat() CMsgClientUFSTransferHeartbeat {
	return CMsgClientUFSTransferHeartbeat{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufstransferheartbeat(o CMsgClientUFSTransferHeartbeat, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufstransferheartbeat(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSTransferHeartbeat) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufstransferheartbeat_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSUploadFileFinished {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	sha_file       []byte
}

pub fn (o &CMsgClientUFSUploadFileFinished) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.sha_file != []byte{} {
		res << vproto.pack_bytes_field(o.sha_file, 2)
	}
	return res
}

pub fn cmsgclientufsuploadfilefinished_unpack(buf []byte) ?CMsgClientUFSUploadFileFinished {
	mut res := zzz_vproto_internal_new_cmsgclientufsuploadfilefinished()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.sha_file = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSUploadFileFinished) eq(b CMsgClientUFSUploadFileFinished) bool {
	return true && a.eresult == b.eresult && a.sha_file == b.sha_file
}

[inline]
pub fn (a CMsgClientUFSUploadFileFinished) ne(b CMsgClientUFSUploadFileFinished) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSUploadFileFinished) eq(b []CMsgClientUFSUploadFileFinished) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSUploadFileFinished) ne(b []CMsgClientUFSUploadFileFinished) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsuploadfilefinished() CMsgClientUFSUploadFileFinished {
	return CMsgClientUFSUploadFileFinished{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadfilefinished(o CMsgClientUFSUploadFileFinished, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadfilefinished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadFileFinished) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsuploadfilefinished_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSDeleteFileRequest {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	file_name          string
	is_explicit_delete bool
}

pub fn (o &CMsgClientUFSDeleteFileRequest) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.file_name != '' {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	if o.is_explicit_delete != false {
		res << vproto.pack_bool_field(o.is_explicit_delete, 3)
	}
	return res
}

pub fn cmsgclientufsdeletefilerequest_unpack(buf []byte) ?CMsgClientUFSDeleteFileRequest {
	mut res := zzz_vproto_internal_new_cmsgclientufsdeletefilerequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.file_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.is_explicit_delete = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSDeleteFileRequest) eq(b CMsgClientUFSDeleteFileRequest) bool {
	return true && a.app_id == b.app_id && a.file_name == b.file_name && a.is_explicit_delete ==
		b.is_explicit_delete
}

[inline]
pub fn (a CMsgClientUFSDeleteFileRequest) ne(b CMsgClientUFSDeleteFileRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSDeleteFileRequest) eq(b []CMsgClientUFSDeleteFileRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSDeleteFileRequest) ne(b []CMsgClientUFSDeleteFileRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsdeletefilerequest() CMsgClientUFSDeleteFileRequest {
	return CMsgClientUFSDeleteFileRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsdeletefilerequest(o CMsgClientUFSDeleteFileRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsdeletefilerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSDeleteFileRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsdeletefilerequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSDeleteFileResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	file_name      string
}

pub fn (o &CMsgClientUFSDeleteFileResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.file_name != '' {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	return res
}

pub fn cmsgclientufsdeletefileresponse_unpack(buf []byte) ?CMsgClientUFSDeleteFileResponse {
	mut res := zzz_vproto_internal_new_cmsgclientufsdeletefileresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.file_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSDeleteFileResponse) eq(b CMsgClientUFSDeleteFileResponse) bool {
	return true && a.eresult == b.eresult && a.file_name == b.file_name
}

[inline]
pub fn (a CMsgClientUFSDeleteFileResponse) ne(b CMsgClientUFSDeleteFileResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSDeleteFileResponse) eq(b []CMsgClientUFSDeleteFileResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSDeleteFileResponse) ne(b []CMsgClientUFSDeleteFileResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsdeletefileresponse() CMsgClientUFSDeleteFileResponse {
	return CMsgClientUFSDeleteFileResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsdeletefileresponse(o CMsgClientUFSDeleteFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsdeletefileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSDeleteFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsdeletefileresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSGetFileListForApp {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	apps_to_query      []u32
	send_path_prefixes bool
}

pub fn (o &CMsgClientUFSGetFileListForApp) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps_to_query {
		res << vproto.pack_uint32_field(x, 1)
	}
	if o.send_path_prefixes != false {
		res << vproto.pack_bool_field(o.send_path_prefixes, 2)
	}
	return res
}

pub fn cmsgclientufsgetfilelistforapp_unpack(buf []byte) ?CMsgClientUFSGetFileListForApp {
	mut res := zzz_vproto_internal_new_cmsgclientufsgetfilelistforapp()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.apps_to_query << v
				i = ii
			}
			2 {
				i, res.send_path_prefixes = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSGetFileListForApp) eq(b CMsgClientUFSGetFileListForApp) bool {
	return true && a.apps_to_query == b.apps_to_query && a.send_path_prefixes == b.send_path_prefixes
}

[inline]
pub fn (a CMsgClientUFSGetFileListForApp) ne(b CMsgClientUFSGetFileListForApp) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSGetFileListForApp) eq(b []CMsgClientUFSGetFileListForApp) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSGetFileListForApp) ne(b []CMsgClientUFSGetFileListForApp) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsgetfilelistforapp() CMsgClientUFSGetFileListForApp {
	return CMsgClientUFSGetFileListForApp{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsgetfilelistforapp(o CMsgClientUFSGetFileListForApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetFileListForApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsgetfilelistforapp_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSGetFileListForAppResponse_File {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	file_name          string
	sha_file           []byte
	time_stamp         u64
	raw_file_size      u32
	is_explicit_delete bool
	platforms_to_sync  u32
	path_prefix_index  u32
}

pub fn (o &CMsgClientUFSGetFileListForAppResponse_File) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.file_name != '' {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	if o.sha_file != []byte{} {
		res << vproto.pack_bytes_field(o.sha_file, 3)
	}
	if o.time_stamp != u64(0) {
		res << vproto.pack_uint64_field(o.time_stamp, 4)
	}
	if o.raw_file_size != u32(0) {
		res << vproto.pack_uint32_field(o.raw_file_size, 5)
	}
	if o.is_explicit_delete != false {
		res << vproto.pack_bool_field(o.is_explicit_delete, 6)
	}
	if o.platforms_to_sync != u32(0) {
		res << vproto.pack_uint32_field(o.platforms_to_sync, 7)
	}
	if o.path_prefix_index != u32(0) {
		res << vproto.pack_uint32_field(o.path_prefix_index, 8)
	}
	return res
}

pub fn cmsgclientufsgetfilelistforappresponse_file_unpack(buf []byte) ?CMsgClientUFSGetFileListForAppResponse_File {
	mut res := zzz_vproto_internal_new_cmsgclientufsgetfilelistforappresponse_file()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.file_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.sha_file = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.time_stamp = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.raw_file_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.is_explicit_delete = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.platforms_to_sync = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.path_prefix_index = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSGetFileListForAppResponse_File) eq(b CMsgClientUFSGetFileListForAppResponse_File) bool {
	return true && a.app_id == b.app_id && a.file_name == b.file_name && a.sha_file == b.sha_file &&
		a.time_stamp == b.time_stamp && a.raw_file_size == b.raw_file_size && a.is_explicit_delete ==
		b.is_explicit_delete && a.platforms_to_sync == b.platforms_to_sync && a.path_prefix_index == b.path_prefix_index
}

[inline]
pub fn (a CMsgClientUFSGetFileListForAppResponse_File) ne(b CMsgClientUFSGetFileListForAppResponse_File) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSGetFileListForAppResponse_File) eq(b []CMsgClientUFSGetFileListForAppResponse_File) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSGetFileListForAppResponse_File) ne(b []CMsgClientUFSGetFileListForAppResponse_File) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsgetfilelistforappresponse_file() CMsgClientUFSGetFileListForAppResponse_File {
	return CMsgClientUFSGetFileListForAppResponse_File{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsgetfilelistforappresponse_file(o CMsgClientUFSGetFileListForAppResponse_File, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforappresponse_file(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetFileListForAppResponse_File) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsgetfilelistforappresponse_file_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSGetFileListForAppResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	files          []CMsgClientUFSGetFileListForAppResponse_File
	path_prefixes  []string
}

pub fn (o &CMsgClientUFSGetFileListForAppResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.files {
		res <<
			zzz_vproto_internal_pack_cmsgclientufsgetfilelistforappresponse_file(x, 1)
	}
	// [packed=false]
	for _, x in o.path_prefixes {
		res << vproto.pack_string_field(x, 2)
	}
	return res
}

pub fn cmsgclientufsgetfilelistforappresponse_unpack(buf []byte) ?CMsgClientUFSGetFileListForAppResponse {
	mut res := zzz_vproto_internal_new_cmsgclientufsgetfilelistforappresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforappresponse_file(cur_buf,
					tag_wiretype.wire_type) ?
				res.files << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.path_prefixes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSGetFileListForAppResponse) eq(b CMsgClientUFSGetFileListForAppResponse) bool {
	return true && a.files.eq(b.files) && a.path_prefixes == b.path_prefixes
}

[inline]
pub fn (a CMsgClientUFSGetFileListForAppResponse) ne(b CMsgClientUFSGetFileListForAppResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSGetFileListForAppResponse) eq(b []CMsgClientUFSGetFileListForAppResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSGetFileListForAppResponse) ne(b []CMsgClientUFSGetFileListForAppResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsgetfilelistforappresponse() CMsgClientUFSGetFileListForAppResponse {
	return CMsgClientUFSGetFileListForAppResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsgetfilelistforappresponse(o CMsgClientUFSGetFileListForAppResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforappresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetFileListForAppResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsgetfilelistforappresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSDownloadRequest {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	app_id          u32
	file_name       string
	can_handle_http bool
}

pub fn (o &CMsgClientUFSDownloadRequest) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.file_name != '' {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	if o.can_handle_http != false {
		res << vproto.pack_bool_field(o.can_handle_http, 3)
	}
	return res
}

pub fn cmsgclientufsdownloadrequest_unpack(buf []byte) ?CMsgClientUFSDownloadRequest {
	mut res := zzz_vproto_internal_new_cmsgclientufsdownloadrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.file_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.can_handle_http = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSDownloadRequest) eq(b CMsgClientUFSDownloadRequest) bool {
	return true && a.app_id == b.app_id && a.file_name == b.file_name && a.can_handle_http ==
		b.can_handle_http
}

[inline]
pub fn (a CMsgClientUFSDownloadRequest) ne(b CMsgClientUFSDownloadRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSDownloadRequest) eq(b []CMsgClientUFSDownloadRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSDownloadRequest) ne(b []CMsgClientUFSDownloadRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsdownloadrequest() CMsgClientUFSDownloadRequest {
	return CMsgClientUFSDownloadRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsdownloadrequest(o CMsgClientUFSDownloadRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsdownloadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSDownloadRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsdownloadrequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSDownloadResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	eresult            int = 2
	app_id             u32
	file_size          u32
	raw_file_size      u32
	sha_file           []byte
	time_stamp         u64
	is_explicit_delete bool
	use_http           bool
	http_host          string
	http_url           string
	kv_headers         []byte
	use_https          bool
	encrypted          bool
}

pub fn (o &CMsgClientUFSDownloadResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.file_size != u32(0) {
		res << vproto.pack_uint32_field(o.file_size, 3)
	}
	if o.raw_file_size != u32(0) {
		res << vproto.pack_uint32_field(o.raw_file_size, 4)
	}
	if o.sha_file != []byte{} {
		res << vproto.pack_bytes_field(o.sha_file, 5)
	}
	if o.time_stamp != u64(0) {
		res << vproto.pack_uint64_field(o.time_stamp, 6)
	}
	if o.is_explicit_delete != false {
		res << vproto.pack_bool_field(o.is_explicit_delete, 7)
	}
	if o.use_http != false {
		res << vproto.pack_bool_field(o.use_http, 8)
	}
	if o.http_host != '' {
		res << vproto.pack_string_field(o.http_host, 9)
	}
	if o.http_url != '' {
		res << vproto.pack_string_field(o.http_url, 10)
	}
	if o.kv_headers != []byte{} {
		res << vproto.pack_bytes_field(o.kv_headers, 11)
	}
	if o.use_https != false {
		res << vproto.pack_bool_field(o.use_https, 12)
	}
	if o.encrypted != false {
		res << vproto.pack_bool_field(o.encrypted, 13)
	}
	return res
}

pub fn cmsgclientufsdownloadresponse_unpack(buf []byte) ?CMsgClientUFSDownloadResponse {
	mut res := zzz_vproto_internal_new_cmsgclientufsdownloadresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.file_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.raw_file_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.sha_file = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.time_stamp = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.is_explicit_delete = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.use_http = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.http_host = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			10 {
				i, res.http_url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			11 {
				i, res.kv_headers = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			12 {
				i, res.use_https = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			13 {
				i, res.encrypted = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSDownloadResponse) eq(b CMsgClientUFSDownloadResponse) bool {
	return true && a.eresult == b.eresult && a.app_id == b.app_id && a.file_size == b.file_size &&
		a.raw_file_size == b.raw_file_size && a.sha_file == b.sha_file && a.time_stamp == b.time_stamp &&
		a.is_explicit_delete == b.is_explicit_delete && a.use_http == b.use_http && a.http_host == b.http_host &&
		a.http_url == b.http_url && a.kv_headers == b.kv_headers && a.use_https == b.use_https &&
		a.encrypted == b.encrypted
}

[inline]
pub fn (a CMsgClientUFSDownloadResponse) ne(b CMsgClientUFSDownloadResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSDownloadResponse) eq(b []CMsgClientUFSDownloadResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSDownloadResponse) ne(b []CMsgClientUFSDownloadResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsdownloadresponse() CMsgClientUFSDownloadResponse {
	return CMsgClientUFSDownloadResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsdownloadresponse(o CMsgClientUFSDownloadResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsdownloadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSDownloadResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsdownloadresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSLoginRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	protocol_version u32
	am_session_token u64
	apps             []u32
}

pub fn (o &CMsgClientUFSLoginRequest) pack() []byte {
	mut res := []byte{}
	if o.protocol_version != u32(0) {
		res << vproto.pack_uint32_field(o.protocol_version, 1)
	}
	if o.am_session_token != u64(0) {
		res << vproto.pack_uint64_field(o.am_session_token, 2)
	}
	// [packed=false]
	for _, x in o.apps {
		res << vproto.pack_uint32_field(x, 3)
	}
	return res
}

pub fn cmsgclientufsloginrequest_unpack(buf []byte) ?CMsgClientUFSLoginRequest {
	mut res := zzz_vproto_internal_new_cmsgclientufsloginrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.protocol_version = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.am_session_token = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.apps << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSLoginRequest) eq(b CMsgClientUFSLoginRequest) bool {
	return true && a.protocol_version == b.protocol_version && a.am_session_token == b.am_session_token &&
		a.apps == b.apps
}

[inline]
pub fn (a CMsgClientUFSLoginRequest) ne(b CMsgClientUFSLoginRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSLoginRequest) eq(b []CMsgClientUFSLoginRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSLoginRequest) ne(b []CMsgClientUFSLoginRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsloginrequest() CMsgClientUFSLoginRequest {
	return CMsgClientUFSLoginRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsloginrequest(o CMsgClientUFSLoginRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsloginrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSLoginRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsloginrequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSLoginResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
}

pub fn (o &CMsgClientUFSLoginResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientufsloginresponse_unpack(buf []byte) ?CMsgClientUFSLoginResponse {
	mut res := zzz_vproto_internal_new_cmsgclientufsloginresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSLoginResponse) eq(b CMsgClientUFSLoginResponse) bool {
	return true && a.eresult == b.eresult
}

[inline]
pub fn (a CMsgClientUFSLoginResponse) ne(b CMsgClientUFSLoginResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSLoginResponse) eq(b []CMsgClientUFSLoginResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSLoginResponse) ne(b []CMsgClientUFSLoginResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsloginresponse() CMsgClientUFSLoginResponse {
	return CMsgClientUFSLoginResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsloginresponse(o CMsgClientUFSLoginResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsloginresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSLoginResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsloginresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRequestEncryptedAppTicket {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	userdata       []byte
}

pub fn (o &CMsgClientRequestEncryptedAppTicket) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.userdata != []byte{} {
		res << vproto.pack_bytes_field(o.userdata, 2)
	}
	return res
}

pub fn cmsgclientrequestencryptedappticket_unpack(buf []byte) ?CMsgClientRequestEncryptedAppTicket {
	mut res := zzz_vproto_internal_new_cmsgclientrequestencryptedappticket()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.userdata = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRequestEncryptedAppTicket) eq(b CMsgClientRequestEncryptedAppTicket) bool {
	return true && a.app_id == b.app_id && a.userdata == b.userdata
}

[inline]
pub fn (a CMsgClientRequestEncryptedAppTicket) ne(b CMsgClientRequestEncryptedAppTicket) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRequestEncryptedAppTicket) eq(b []CMsgClientRequestEncryptedAppTicket) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRequestEncryptedAppTicket) ne(b []CMsgClientRequestEncryptedAppTicket) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientrequestencryptedappticket() CMsgClientRequestEncryptedAppTicket {
	return CMsgClientRequestEncryptedAppTicket{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientrequestencryptedappticket(o CMsgClientRequestEncryptedAppTicket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientrequestencryptedappticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestEncryptedAppTicket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientrequestencryptedappticket_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientRequestEncryptedAppTicketResponse {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	app_id               u32
	eresult              int = 2
	encrypted_app_ticket EncryptedAppTicket
}

pub fn (o &CMsgClientRequestEncryptedAppTicketResponse) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 2)
	}
	if o.encrypted_app_ticket.ne(zzz_vproto_internal_new_encryptedappticket()) {
		res << zzz_vproto_internal_pack_encryptedappticket(o.encrypted_app_ticket, 3)
	}
	return res
}

pub fn cmsgclientrequestencryptedappticketresponse_unpack(buf []byte) ?CMsgClientRequestEncryptedAppTicketResponse {
	mut res := zzz_vproto_internal_new_cmsgclientrequestencryptedappticketresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.encrypted_app_ticket = zzz_vproto_internal_unpack_encryptedappticket(cur_buf,
					tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientRequestEncryptedAppTicketResponse) eq(b CMsgClientRequestEncryptedAppTicketResponse) bool {
	return true && a.app_id == b.app_id && a.eresult == b.eresult && a.encrypted_app_ticket.eq(b.encrypted_app_ticket)
}

[inline]
pub fn (a CMsgClientRequestEncryptedAppTicketResponse) ne(b CMsgClientRequestEncryptedAppTicketResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientRequestEncryptedAppTicketResponse) eq(b []CMsgClientRequestEncryptedAppTicketResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientRequestEncryptedAppTicketResponse) ne(b []CMsgClientRequestEncryptedAppTicketResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientrequestencryptedappticketresponse() CMsgClientRequestEncryptedAppTicketResponse {
	return CMsgClientRequestEncryptedAppTicketResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientrequestencryptedappticketresponse(o CMsgClientRequestEncryptedAppTicketResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientrequestencryptedappticketresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestEncryptedAppTicketResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientrequestencryptedappticketresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientWalletInfoUpdate {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	has_wallet        bool
	balance           int
	currency          int
	balance_delayed   int
	balance64         i64
	balance64_delayed i64
}

pub fn (o &CMsgClientWalletInfoUpdate) pack() []byte {
	mut res := []byte{}
	if o.has_wallet != false {
		res << vproto.pack_bool_field(o.has_wallet, 1)
	}
	if o.balance != int(0) {
		res << vproto.pack_int32_field(o.balance, 2)
	}
	if o.currency != int(0) {
		res << vproto.pack_int32_field(o.currency, 3)
	}
	if o.balance_delayed != int(0) {
		res << vproto.pack_int32_field(o.balance_delayed, 4)
	}
	if o.balance64 != i64(0) {
		res << vproto.pack_int64_field(o.balance64, 5)
	}
	if o.balance64_delayed != i64(0) {
		res << vproto.pack_int64_field(o.balance64_delayed, 6)
	}
	return res
}

pub fn cmsgclientwalletinfoupdate_unpack(buf []byte) ?CMsgClientWalletInfoUpdate {
	mut res := zzz_vproto_internal_new_cmsgclientwalletinfoupdate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.has_wallet = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.balance = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.currency = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.balance_delayed = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.balance64 = vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.balance64_delayed = vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientWalletInfoUpdate) eq(b CMsgClientWalletInfoUpdate) bool {
	return true && a.has_wallet == b.has_wallet && a.balance == b.balance && a.currency == b.currency &&
		a.balance_delayed == b.balance_delayed && a.balance64 == b.balance64 && a.balance64_delayed ==
		b.balance64_delayed
}

[inline]
pub fn (a CMsgClientWalletInfoUpdate) ne(b CMsgClientWalletInfoUpdate) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientWalletInfoUpdate) eq(b []CMsgClientWalletInfoUpdate) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientWalletInfoUpdate) ne(b []CMsgClientWalletInfoUpdate) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientwalletinfoupdate() CMsgClientWalletInfoUpdate {
	return CMsgClientWalletInfoUpdate{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientwalletinfoupdate(o CMsgClientWalletInfoUpdate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientwalletinfoupdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWalletInfoUpdate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientwalletinfoupdate_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAppInfoUpdate {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	last_changenumber u32
	send_changelist   bool
}

pub fn (o &CMsgClientAppInfoUpdate) pack() []byte {
	mut res := []byte{}
	if o.last_changenumber != u32(0) {
		res << vproto.pack_uint32_field(o.last_changenumber, 1)
	}
	if o.send_changelist != false {
		res << vproto.pack_bool_field(o.send_changelist, 2)
	}
	return res
}

pub fn cmsgclientappinfoupdate_unpack(buf []byte) ?CMsgClientAppInfoUpdate {
	mut res := zzz_vproto_internal_new_cmsgclientappinfoupdate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.last_changenumber = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.send_changelist = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAppInfoUpdate) eq(b CMsgClientAppInfoUpdate) bool {
	return true && a.last_changenumber == b.last_changenumber && a.send_changelist == b.send_changelist
}

[inline]
pub fn (a CMsgClientAppInfoUpdate) ne(b CMsgClientAppInfoUpdate) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAppInfoUpdate) eq(b []CMsgClientAppInfoUpdate) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAppInfoUpdate) ne(b []CMsgClientAppInfoUpdate) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientappinfoupdate() CMsgClientAppInfoUpdate {
	return CMsgClientAppInfoUpdate{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientappinfoupdate(o CMsgClientAppInfoUpdate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientappinfoupdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoUpdate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientappinfoupdate_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAppInfoChanges {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	current_change_number u32
	force_full_update     bool
	appids                []u32
}

pub fn (o &CMsgClientAppInfoChanges) pack() []byte {
	mut res := []byte{}
	if o.current_change_number != u32(0) {
		res << vproto.pack_uint32_field(o.current_change_number, 1)
	}
	if o.force_full_update != false {
		res << vproto.pack_bool_field(o.force_full_update, 2)
	}
	// [packed=false]
	for _, x in o.appids {
		res << vproto.pack_uint32_field(x, 3)
	}
	return res
}

pub fn cmsgclientappinfochanges_unpack(buf []byte) ?CMsgClientAppInfoChanges {
	mut res := zzz_vproto_internal_new_cmsgclientappinfochanges()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.current_change_number = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.force_full_update = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAppInfoChanges) eq(b CMsgClientAppInfoChanges) bool {
	return true && a.current_change_number == b.current_change_number && a.force_full_update ==
		b.force_full_update && a.appids == b.appids
}

[inline]
pub fn (a CMsgClientAppInfoChanges) ne(b CMsgClientAppInfoChanges) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAppInfoChanges) eq(b []CMsgClientAppInfoChanges) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAppInfoChanges) ne(b []CMsgClientAppInfoChanges) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientappinfochanges() CMsgClientAppInfoChanges {
	return CMsgClientAppInfoChanges{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientappinfochanges(o CMsgClientAppInfoChanges, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientappinfochanges(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoChanges) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientappinfochanges_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAppInfoRequest_App {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	section_flags  u32
	section_crc    []u32
}

pub fn (o &CMsgClientAppInfoRequest_App) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.section_flags != u32(0) {
		res << vproto.pack_uint32_field(o.section_flags, 2)
	}
	// [packed=false]
	for _, x in o.section_crc {
		res << vproto.pack_uint32_field(x, 3)
	}
	return res
}

pub fn cmsgclientappinforequest_app_unpack(buf []byte) ?CMsgClientAppInfoRequest_App {
	mut res := zzz_vproto_internal_new_cmsgclientappinforequest_app()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.section_flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.section_crc << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAppInfoRequest_App) eq(b CMsgClientAppInfoRequest_App) bool {
	return true && a.app_id == b.app_id && a.section_flags == b.section_flags && a.section_crc ==
		b.section_crc
}

[inline]
pub fn (a CMsgClientAppInfoRequest_App) ne(b CMsgClientAppInfoRequest_App) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAppInfoRequest_App) eq(b []CMsgClientAppInfoRequest_App) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAppInfoRequest_App) ne(b []CMsgClientAppInfoRequest_App) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientappinforequest_app() CMsgClientAppInfoRequest_App {
	return CMsgClientAppInfoRequest_App{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientappinforequest_app(o CMsgClientAppInfoRequest_App, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientappinforequest_app(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoRequest_App) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientappinforequest_app_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAppInfoRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	apps             []CMsgClientAppInfoRequest_App
	supports_batches bool
}

pub fn (o &CMsgClientAppInfoRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgclientappinforequest_app(x, 1)
	}
	if o.supports_batches != false {
		res << vproto.pack_bool_field(o.supports_batches, 2)
	}
	return res
}

pub fn cmsgclientappinforequest_unpack(buf []byte) ?CMsgClientAppInfoRequest {
	mut res := zzz_vproto_internal_new_cmsgclientappinforequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientappinforequest_app(cur_buf,
					tag_wiretype.wire_type) ?
				res.apps << v
				i = ii
			}
			2 {
				i, res.supports_batches = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAppInfoRequest) eq(b CMsgClientAppInfoRequest) bool {
	return true && a.apps.eq(b.apps) && a.supports_batches == b.supports_batches
}

[inline]
pub fn (a CMsgClientAppInfoRequest) ne(b CMsgClientAppInfoRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAppInfoRequest) eq(b []CMsgClientAppInfoRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAppInfoRequest) ne(b []CMsgClientAppInfoRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientappinforequest() CMsgClientAppInfoRequest {
	return CMsgClientAppInfoRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientappinforequest(o CMsgClientAppInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientappinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientappinforequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAppInfoResponseApp_Section {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	section_id     u32
	section_kv     []byte
}

pub fn (o &CMsgClientAppInfoResponseApp_Section) pack() []byte {
	mut res := []byte{}
	if o.section_id != u32(0) {
		res << vproto.pack_uint32_field(o.section_id, 1)
	}
	if o.section_kv != []byte{} {
		res << vproto.pack_bytes_field(o.section_kv, 2)
	}
	return res
}

pub fn cmsgclientappinforesponseapp_section_unpack(buf []byte) ?CMsgClientAppInfoResponseApp_Section {
	mut res := zzz_vproto_internal_new_cmsgclientappinforesponseapp_section()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.section_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.section_kv = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAppInfoResponseApp_Section) eq(b CMsgClientAppInfoResponseApp_Section) bool {
	return true && a.section_id == b.section_id && a.section_kv == b.section_kv
}

[inline]
pub fn (a CMsgClientAppInfoResponseApp_Section) ne(b CMsgClientAppInfoResponseApp_Section) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAppInfoResponseApp_Section) eq(b []CMsgClientAppInfoResponseApp_Section) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAppInfoResponseApp_Section) ne(b []CMsgClientAppInfoResponseApp_Section) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientappinforesponseapp_section() CMsgClientAppInfoResponseApp_Section {
	return CMsgClientAppInfoResponseApp_Section{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientappinforesponseapp_section(o CMsgClientAppInfoResponseApp_Section, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientappinforesponseapp_section(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoResponseApp_Section) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientappinforesponseapp_section_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAppInfoResponse_App {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	change_number  u32
	sections       []CMsgClientAppInfoResponseApp_Section
}

pub fn (o &CMsgClientAppInfoResponse_App) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.change_number != u32(0) {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	// [packed=false]
	for _, x in o.sections {
		res << zzz_vproto_internal_pack_cmsgclientappinforesponseapp_section(x, 3)
	}
	return res
}

pub fn cmsgclientappinforesponse_app_unpack(buf []byte) ?CMsgClientAppInfoResponse_App {
	mut res := zzz_vproto_internal_new_cmsgclientappinforesponse_app()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.change_number = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientappinforesponseapp_section(cur_buf,
					tag_wiretype.wire_type) ?
				res.sections << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAppInfoResponse_App) eq(b CMsgClientAppInfoResponse_App) bool {
	return true && a.app_id == b.app_id && a.change_number == b.change_number && a.sections.eq(b.sections)
}

[inline]
pub fn (a CMsgClientAppInfoResponse_App) ne(b CMsgClientAppInfoResponse_App) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAppInfoResponse_App) eq(b []CMsgClientAppInfoResponse_App) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAppInfoResponse_App) ne(b []CMsgClientAppInfoResponse_App) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientappinforesponse_app() CMsgClientAppInfoResponse_App {
	return CMsgClientAppInfoResponse_App{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientappinforesponse_app(o CMsgClientAppInfoResponse_App, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientappinforesponse_app(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoResponse_App) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientappinforesponse_app_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAppInfoResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	apps           []CMsgClientAppInfoResponse_App
	apps_unknown   []u32
	apps_pending   u32
}

pub fn (o &CMsgClientAppInfoResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgclientappinforesponse_app(x, 1)
	}
	// [packed=false]
	for _, x in o.apps_unknown {
		res << vproto.pack_uint32_field(x, 2)
	}
	if o.apps_pending != u32(0) {
		res << vproto.pack_uint32_field(o.apps_pending, 3)
	}
	return res
}

pub fn cmsgclientappinforesponse_unpack(buf []byte) ?CMsgClientAppInfoResponse {
	mut res := zzz_vproto_internal_new_cmsgclientappinforesponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientappinforesponse_app(cur_buf,
					tag_wiretype.wire_type) ?
				res.apps << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.apps_unknown << v
				i = ii
			}
			3 {
				i, res.apps_pending = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAppInfoResponse) eq(b CMsgClientAppInfoResponse) bool {
	return true && a.apps.eq(b.apps) && a.apps_unknown == b.apps_unknown && a.apps_pending ==
		b.apps_pending
}

[inline]
pub fn (a CMsgClientAppInfoResponse) ne(b CMsgClientAppInfoResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAppInfoResponse) eq(b []CMsgClientAppInfoResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAppInfoResponse) ne(b []CMsgClientAppInfoResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientappinforesponse() CMsgClientAppInfoResponse {
	return CMsgClientAppInfoResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientappinforesponse(o CMsgClientAppInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientappinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientappinforesponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPackageInfoRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	package_ids    []u32
	meta_data_only bool
}

pub fn (o &CMsgClientPackageInfoRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.package_ids {
		res << vproto.pack_uint32_field(x, 1)
	}
	if o.meta_data_only != false {
		res << vproto.pack_bool_field(o.meta_data_only, 2)
	}
	return res
}

pub fn cmsgclientpackageinforequest_unpack(buf []byte) ?CMsgClientPackageInfoRequest {
	mut res := zzz_vproto_internal_new_cmsgclientpackageinforequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.package_ids << v
				i = ii
			}
			2 {
				i, res.meta_data_only = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPackageInfoRequest) eq(b CMsgClientPackageInfoRequest) bool {
	return true && a.package_ids == b.package_ids && a.meta_data_only == b.meta_data_only
}

[inline]
pub fn (a CMsgClientPackageInfoRequest) ne(b CMsgClientPackageInfoRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPackageInfoRequest) eq(b []CMsgClientPackageInfoRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPackageInfoRequest) ne(b []CMsgClientPackageInfoRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpackageinforequest() CMsgClientPackageInfoRequest {
	return CMsgClientPackageInfoRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpackageinforequest(o CMsgClientPackageInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpackageinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPackageInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpackageinforequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPackageInfoResponse_Package {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	package_id     u32
	change_number  u32
	sha            []byte
	buffer         []byte
}

pub fn (o &CMsgClientPackageInfoResponse_Package) pack() []byte {
	mut res := []byte{}
	if o.package_id != u32(0) {
		res << vproto.pack_uint32_field(o.package_id, 1)
	}
	if o.change_number != u32(0) {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	if o.sha != []byte{} {
		res << vproto.pack_bytes_field(o.sha, 3)
	}
	if o.buffer != []byte{} {
		res << vproto.pack_bytes_field(o.buffer, 4)
	}
	return res
}

pub fn cmsgclientpackageinforesponse_package_unpack(buf []byte) ?CMsgClientPackageInfoResponse_Package {
	mut res := zzz_vproto_internal_new_cmsgclientpackageinforesponse_package()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.package_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.change_number = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.sha = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.buffer = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPackageInfoResponse_Package) eq(b CMsgClientPackageInfoResponse_Package) bool {
	return true && a.package_id == b.package_id && a.change_number == b.change_number &&
		a.sha == b.sha && a.buffer == b.buffer
}

[inline]
pub fn (a CMsgClientPackageInfoResponse_Package) ne(b CMsgClientPackageInfoResponse_Package) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPackageInfoResponse_Package) eq(b []CMsgClientPackageInfoResponse_Package) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPackageInfoResponse_Package) ne(b []CMsgClientPackageInfoResponse_Package) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpackageinforesponse_package() CMsgClientPackageInfoResponse_Package {
	return CMsgClientPackageInfoResponse_Package{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpackageinforesponse_package(o CMsgClientPackageInfoResponse_Package, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpackageinforesponse_package(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPackageInfoResponse_Package) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpackageinforesponse_package_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPackageInfoResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	packages         []CMsgClientPackageInfoResponse_Package
	packages_unknown []u32
	packages_pending u32
}

pub fn (o &CMsgClientPackageInfoResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.packages {
		res << zzz_vproto_internal_pack_cmsgclientpackageinforesponse_package(x, 1)
	}
	// [packed=false]
	for _, x in o.packages_unknown {
		res << vproto.pack_uint32_field(x, 2)
	}
	if o.packages_pending != u32(0) {
		res << vproto.pack_uint32_field(o.packages_pending, 3)
	}
	return res
}

pub fn cmsgclientpackageinforesponse_unpack(buf []byte) ?CMsgClientPackageInfoResponse {
	mut res := zzz_vproto_internal_new_cmsgclientpackageinforesponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpackageinforesponse_package(cur_buf,
					tag_wiretype.wire_type) ?
				res.packages << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.packages_unknown << v
				i = ii
			}
			3 {
				i, res.packages_pending = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPackageInfoResponse) eq(b CMsgClientPackageInfoResponse) bool {
	return true && a.packages.eq(b.packages) && a.packages_unknown == b.packages_unknown &&
		a.packages_pending == b.packages_pending
}

[inline]
pub fn (a CMsgClientPackageInfoResponse) ne(b CMsgClientPackageInfoResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPackageInfoResponse) eq(b []CMsgClientPackageInfoResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPackageInfoResponse) ne(b []CMsgClientPackageInfoResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpackageinforesponse() CMsgClientPackageInfoResponse {
	return CMsgClientPackageInfoResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpackageinforesponse(o CMsgClientPackageInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpackageinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPackageInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpackageinforesponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSChangesSinceRequest {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	since_change_number       u32
	send_app_info_changes     bool
	send_package_info_changes bool
	num_app_info_cached       u32
	num_package_info_cached   u32
}

pub fn (o &CMsgClientPICSChangesSinceRequest) pack() []byte {
	mut res := []byte{}
	if o.since_change_number != u32(0) {
		res << vproto.pack_uint32_field(o.since_change_number, 1)
	}
	if o.send_app_info_changes != false {
		res << vproto.pack_bool_field(o.send_app_info_changes, 2)
	}
	if o.send_package_info_changes != false {
		res << vproto.pack_bool_field(o.send_package_info_changes, 3)
	}
	if o.num_app_info_cached != u32(0) {
		res << vproto.pack_uint32_field(o.num_app_info_cached, 4)
	}
	if o.num_package_info_cached != u32(0) {
		res << vproto.pack_uint32_field(o.num_package_info_cached, 5)
	}
	return res
}

pub fn cmsgclientpicschangessincerequest_unpack(buf []byte) ?CMsgClientPICSChangesSinceRequest {
	mut res := zzz_vproto_internal_new_cmsgclientpicschangessincerequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.since_change_number = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.send_app_info_changes = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.send_package_info_changes = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.num_app_info_cached = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.num_package_info_cached = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSChangesSinceRequest) eq(b CMsgClientPICSChangesSinceRequest) bool {
	return true && a.since_change_number == b.since_change_number && a.send_app_info_changes ==
		b.send_app_info_changes && a.send_package_info_changes == b.send_package_info_changes &&
		a.num_app_info_cached == b.num_app_info_cached && a.num_package_info_cached == b.num_package_info_cached
}

[inline]
pub fn (a CMsgClientPICSChangesSinceRequest) ne(b CMsgClientPICSChangesSinceRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSChangesSinceRequest) eq(b []CMsgClientPICSChangesSinceRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSChangesSinceRequest) ne(b []CMsgClientPICSChangesSinceRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicschangessincerequest() CMsgClientPICSChangesSinceRequest {
	return CMsgClientPICSChangesSinceRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessincerequest(o CMsgClientPICSChangesSinceRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessincerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSChangesSinceRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicschangessincerequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSChangesSinceResponse_PackageChange {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	packageid      u32
	change_number  u32
	needs_token    bool
}

pub fn (o &CMsgClientPICSChangesSinceResponse_PackageChange) pack() []byte {
	mut res := []byte{}
	if o.packageid != u32(0) {
		res << vproto.pack_uint32_field(o.packageid, 1)
	}
	if o.change_number != u32(0) {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	if o.needs_token != false {
		res << vproto.pack_bool_field(o.needs_token, 3)
	}
	return res
}

pub fn cmsgclientpicschangessinceresponse_packagechange_unpack(buf []byte) ?CMsgClientPICSChangesSinceResponse_PackageChange {
	mut res := zzz_vproto_internal_new_cmsgclientpicschangessinceresponse_packagechange()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.packageid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.change_number = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.needs_token = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSChangesSinceResponse_PackageChange) eq(b CMsgClientPICSChangesSinceResponse_PackageChange) bool {
	return true && a.packageid == b.packageid && a.change_number == b.change_number &&
		a.needs_token == b.needs_token
}

[inline]
pub fn (a CMsgClientPICSChangesSinceResponse_PackageChange) ne(b CMsgClientPICSChangesSinceResponse_PackageChange) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSChangesSinceResponse_PackageChange) eq(b []CMsgClientPICSChangesSinceResponse_PackageChange) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSChangesSinceResponse_PackageChange) ne(b []CMsgClientPICSChangesSinceResponse_PackageChange) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicschangessinceresponse_packagechange() CMsgClientPICSChangesSinceResponse_PackageChange {
	return CMsgClientPICSChangesSinceResponse_PackageChange{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse_packagechange(o CMsgClientPICSChangesSinceResponse_PackageChange, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse_packagechange(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSChangesSinceResponse_PackageChange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicschangessinceresponse_packagechange_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSChangesSinceResponse_AppChange {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	change_number  u32
	needs_token    bool
}

pub fn (o &CMsgClientPICSChangesSinceResponse_AppChange) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.change_number != u32(0) {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	if o.needs_token != false {
		res << vproto.pack_bool_field(o.needs_token, 3)
	}
	return res
}

pub fn cmsgclientpicschangessinceresponse_appchange_unpack(buf []byte) ?CMsgClientPICSChangesSinceResponse_AppChange {
	mut res := zzz_vproto_internal_new_cmsgclientpicschangessinceresponse_appchange()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.change_number = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.needs_token = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSChangesSinceResponse_AppChange) eq(b CMsgClientPICSChangesSinceResponse_AppChange) bool {
	return true && a.appid == b.appid && a.change_number == b.change_number && a.needs_token ==
		b.needs_token
}

[inline]
pub fn (a CMsgClientPICSChangesSinceResponse_AppChange) ne(b CMsgClientPICSChangesSinceResponse_AppChange) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSChangesSinceResponse_AppChange) eq(b []CMsgClientPICSChangesSinceResponse_AppChange) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSChangesSinceResponse_AppChange) ne(b []CMsgClientPICSChangesSinceResponse_AppChange) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicschangessinceresponse_appchange() CMsgClientPICSChangesSinceResponse_AppChange {
	return CMsgClientPICSChangesSinceResponse_AppChange{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse_appchange(o CMsgClientPICSChangesSinceResponse_AppChange, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse_appchange(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSChangesSinceResponse_AppChange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicschangessinceresponse_appchange_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSChangesSinceResponse {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	current_change_number     u32
	since_change_number       u32
	force_full_update         bool
	package_changes           []CMsgClientPICSChangesSinceResponse_PackageChange
	app_changes               []CMsgClientPICSChangesSinceResponse_AppChange
	force_full_app_update     bool
	force_full_package_update bool
}

pub fn (o &CMsgClientPICSChangesSinceResponse) pack() []byte {
	mut res := []byte{}
	if o.current_change_number != u32(0) {
		res << vproto.pack_uint32_field(o.current_change_number, 1)
	}
	if o.since_change_number != u32(0) {
		res << vproto.pack_uint32_field(o.since_change_number, 2)
	}
	if o.force_full_update != false {
		res << vproto.pack_bool_field(o.force_full_update, 3)
	}
	// [packed=false]
	for _, x in o.package_changes {
		res <<
			zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse_packagechange(x, 4)
	}
	// [packed=false]
	for _, x in o.app_changes {
		res <<
			zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse_appchange(x, 5)
	}
	if o.force_full_app_update != false {
		res << vproto.pack_bool_field(o.force_full_app_update, 6)
	}
	if o.force_full_package_update != false {
		res << vproto.pack_bool_field(o.force_full_package_update, 7)
	}
	return res
}

pub fn cmsgclientpicschangessinceresponse_unpack(buf []byte) ?CMsgClientPICSChangesSinceResponse {
	mut res := zzz_vproto_internal_new_cmsgclientpicschangessinceresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.current_change_number = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.since_change_number = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.force_full_update = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse_packagechange(cur_buf,
					tag_wiretype.wire_type) ?
				res.package_changes << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse_appchange(cur_buf,
					tag_wiretype.wire_type) ?
				res.app_changes << v
				i = ii
			}
			6 {
				i, res.force_full_app_update = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.force_full_package_update = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSChangesSinceResponse) eq(b CMsgClientPICSChangesSinceResponse) bool {
	return true && a.current_change_number == b.current_change_number && a.since_change_number ==
		b.since_change_number && a.force_full_update == b.force_full_update && a.package_changes.eq(b.package_changes) &&
		a.app_changes.eq(b.app_changes) && a.force_full_app_update == b.force_full_app_update &&
		a.force_full_package_update == b.force_full_package_update
}

[inline]
pub fn (a CMsgClientPICSChangesSinceResponse) ne(b CMsgClientPICSChangesSinceResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSChangesSinceResponse) eq(b []CMsgClientPICSChangesSinceResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSChangesSinceResponse) ne(b []CMsgClientPICSChangesSinceResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicschangessinceresponse() CMsgClientPICSChangesSinceResponse {
	return CMsgClientPICSChangesSinceResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse(o CMsgClientPICSChangesSinceResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSChangesSinceResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicschangessinceresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoRequest_AppInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	access_token   u64
	only_public    bool
}

pub fn (o &CMsgClientPICSProductInfoRequest_AppInfo) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.access_token != u64(0) {
		res << vproto.pack_uint64_field(o.access_token, 2)
	}
	if o.only_public != false {
		res << vproto.pack_bool_field(o.only_public, 3)
	}
	return res
}

pub fn cmsgclientpicsproductinforequest_appinfo_unpack(buf []byte) ?CMsgClientPICSProductInfoRequest_AppInfo {
	mut res := zzz_vproto_internal_new_cmsgclientpicsproductinforequest_appinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.access_token = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.only_public = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSProductInfoRequest_AppInfo) eq(b CMsgClientPICSProductInfoRequest_AppInfo) bool {
	return true && a.appid == b.appid && a.access_token == b.access_token && a.only_public ==
		b.only_public
}

[inline]
pub fn (a CMsgClientPICSProductInfoRequest_AppInfo) ne(b CMsgClientPICSProductInfoRequest_AppInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSProductInfoRequest_AppInfo) eq(b []CMsgClientPICSProductInfoRequest_AppInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSProductInfoRequest_AppInfo) ne(b []CMsgClientPICSProductInfoRequest_AppInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforequest_appinfo() CMsgClientPICSProductInfoRequest_AppInfo {
	return CMsgClientPICSProductInfoRequest_AppInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforequest_appinfo(o CMsgClientPICSProductInfoRequest_AppInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest_appinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoRequest_AppInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicsproductinforequest_appinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoRequest_PackageInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	packageid      u32
	access_token   u64
}

pub fn (o &CMsgClientPICSProductInfoRequest_PackageInfo) pack() []byte {
	mut res := []byte{}
	if o.packageid != u32(0) {
		res << vproto.pack_uint32_field(o.packageid, 1)
	}
	if o.access_token != u64(0) {
		res << vproto.pack_uint64_field(o.access_token, 2)
	}
	return res
}

pub fn cmsgclientpicsproductinforequest_packageinfo_unpack(buf []byte) ?CMsgClientPICSProductInfoRequest_PackageInfo {
	mut res := zzz_vproto_internal_new_cmsgclientpicsproductinforequest_packageinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.packageid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.access_token = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSProductInfoRequest_PackageInfo) eq(b CMsgClientPICSProductInfoRequest_PackageInfo) bool {
	return true && a.packageid == b.packageid && a.access_token == b.access_token
}

[inline]
pub fn (a CMsgClientPICSProductInfoRequest_PackageInfo) ne(b CMsgClientPICSProductInfoRequest_PackageInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSProductInfoRequest_PackageInfo) eq(b []CMsgClientPICSProductInfoRequest_PackageInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSProductInfoRequest_PackageInfo) ne(b []CMsgClientPICSProductInfoRequest_PackageInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforequest_packageinfo() CMsgClientPICSProductInfoRequest_PackageInfo {
	return CMsgClientPICSProductInfoRequest_PackageInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforequest_packageinfo(o CMsgClientPICSProductInfoRequest_PackageInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest_packageinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoRequest_PackageInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicsproductinforequest_packageinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoRequest {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	packages                []CMsgClientPICSProductInfoRequest_PackageInfo
	apps                    []CMsgClientPICSProductInfoRequest_AppInfo
	meta_data_only          bool
	num_prev_failed         u32
	supports_package_tokens u32
}

pub fn (o &CMsgClientPICSProductInfoRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.packages {
		res <<
			zzz_vproto_internal_pack_cmsgclientpicsproductinforequest_packageinfo(x, 1)
	}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgclientpicsproductinforequest_appinfo(x, 2)
	}
	if o.meta_data_only != false {
		res << vproto.pack_bool_field(o.meta_data_only, 3)
	}
	if o.num_prev_failed != u32(0) {
		res << vproto.pack_uint32_field(o.num_prev_failed, 4)
	}
	if o.supports_package_tokens != u32(0) {
		res << vproto.pack_uint32_field(o.supports_package_tokens, 5)
	}
	return res
}

pub fn cmsgclientpicsproductinforequest_unpack(buf []byte) ?CMsgClientPICSProductInfoRequest {
	mut res := zzz_vproto_internal_new_cmsgclientpicsproductinforequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest_packageinfo(cur_buf,
					tag_wiretype.wire_type) ?
				res.packages << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest_appinfo(cur_buf,
					tag_wiretype.wire_type) ?
				res.apps << v
				i = ii
			}
			3 {
				i, res.meta_data_only = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.num_prev_failed = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.supports_package_tokens = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSProductInfoRequest) eq(b CMsgClientPICSProductInfoRequest) bool {
	return true && a.packages.eq(b.packages) && a.apps.eq(b.apps) && a.meta_data_only == b.meta_data_only &&
		a.num_prev_failed == b.num_prev_failed && a.supports_package_tokens == b.supports_package_tokens
}

[inline]
pub fn (a CMsgClientPICSProductInfoRequest) ne(b CMsgClientPICSProductInfoRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSProductInfoRequest) eq(b []CMsgClientPICSProductInfoRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSProductInfoRequest) ne(b []CMsgClientPICSProductInfoRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforequest() CMsgClientPICSProductInfoRequest {
	return CMsgClientPICSProductInfoRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforequest(o CMsgClientPICSProductInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicsproductinforequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoResponse_AppInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	change_number  u32
	missing_token  bool
	sha            []byte
	buffer         []byte
	only_public    bool
	size           u32
}

pub fn (o &CMsgClientPICSProductInfoResponse_AppInfo) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.change_number != u32(0) {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	if o.missing_token != false {
		res << vproto.pack_bool_field(o.missing_token, 3)
	}
	if o.sha != []byte{} {
		res << vproto.pack_bytes_field(o.sha, 4)
	}
	if o.buffer != []byte{} {
		res << vproto.pack_bytes_field(o.buffer, 5)
	}
	if o.only_public != false {
		res << vproto.pack_bool_field(o.only_public, 6)
	}
	if o.size != u32(0) {
		res << vproto.pack_uint32_field(o.size, 7)
	}
	return res
}

pub fn cmsgclientpicsproductinforesponse_appinfo_unpack(buf []byte) ?CMsgClientPICSProductInfoResponse_AppInfo {
	mut res := zzz_vproto_internal_new_cmsgclientpicsproductinforesponse_appinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.change_number = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.missing_token = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.sha = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.buffer = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.only_public = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSProductInfoResponse_AppInfo) eq(b CMsgClientPICSProductInfoResponse_AppInfo) bool {
	return true && a.appid == b.appid && a.change_number == b.change_number && a.missing_token ==
		b.missing_token && a.sha == b.sha && a.buffer == b.buffer && a.only_public == b.only_public &&
		a.size == b.size
}

[inline]
pub fn (a CMsgClientPICSProductInfoResponse_AppInfo) ne(b CMsgClientPICSProductInfoResponse_AppInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSProductInfoResponse_AppInfo) eq(b []CMsgClientPICSProductInfoResponse_AppInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSProductInfoResponse_AppInfo) ne(b []CMsgClientPICSProductInfoResponse_AppInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforesponse_appinfo() CMsgClientPICSProductInfoResponse_AppInfo {
	return CMsgClientPICSProductInfoResponse_AppInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse_appinfo(o CMsgClientPICSProductInfoResponse_AppInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse_appinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoResponse_AppInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicsproductinforesponse_appinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoResponse_PackageInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	packageid      u32
	change_number  u32
	missing_token  bool
	sha            []byte
	buffer         []byte
	size           u32
}

pub fn (o &CMsgClientPICSProductInfoResponse_PackageInfo) pack() []byte {
	mut res := []byte{}
	if o.packageid != u32(0) {
		res << vproto.pack_uint32_field(o.packageid, 1)
	}
	if o.change_number != u32(0) {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	if o.missing_token != false {
		res << vproto.pack_bool_field(o.missing_token, 3)
	}
	if o.sha != []byte{} {
		res << vproto.pack_bytes_field(o.sha, 4)
	}
	if o.buffer != []byte{} {
		res << vproto.pack_bytes_field(o.buffer, 5)
	}
	if o.size != u32(0) {
		res << vproto.pack_uint32_field(o.size, 6)
	}
	return res
}

pub fn cmsgclientpicsproductinforesponse_packageinfo_unpack(buf []byte) ?CMsgClientPICSProductInfoResponse_PackageInfo {
	mut res := zzz_vproto_internal_new_cmsgclientpicsproductinforesponse_packageinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.packageid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.change_number = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.missing_token = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.sha = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.buffer = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSProductInfoResponse_PackageInfo) eq(b CMsgClientPICSProductInfoResponse_PackageInfo) bool {
	return true && a.packageid == b.packageid && a.change_number == b.change_number &&
		a.missing_token == b.missing_token && a.sha == b.sha && a.buffer == b.buffer && a.size == b.size
}

[inline]
pub fn (a CMsgClientPICSProductInfoResponse_PackageInfo) ne(b CMsgClientPICSProductInfoResponse_PackageInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSProductInfoResponse_PackageInfo) eq(b []CMsgClientPICSProductInfoResponse_PackageInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSProductInfoResponse_PackageInfo) ne(b []CMsgClientPICSProductInfoResponse_PackageInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforesponse_packageinfo() CMsgClientPICSProductInfoResponse_PackageInfo {
	return CMsgClientPICSProductInfoResponse_PackageInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse_packageinfo(o CMsgClientPICSProductInfoResponse_PackageInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse_packageinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoResponse_PackageInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicsproductinforesponse_packageinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	apps               []CMsgClientPICSProductInfoResponse_AppInfo
	unknown_appids     []u32
	packages           []CMsgClientPICSProductInfoResponse_PackageInfo
	unknown_packageids []u32
	meta_data_only     bool
	response_pending   bool
	http_min_size      u32
	http_host          string
}

pub fn (o &CMsgClientPICSProductInfoResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps {
		res <<
			zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse_appinfo(x, 1)
	}
	// [packed=false]
	for _, x in o.unknown_appids {
		res << vproto.pack_uint32_field(x, 2)
	}
	// [packed=false]
	for _, x in o.packages {
		res <<
			zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse_packageinfo(x, 3)
	}
	// [packed=false]
	for _, x in o.unknown_packageids {
		res << vproto.pack_uint32_field(x, 4)
	}
	if o.meta_data_only != false {
		res << vproto.pack_bool_field(o.meta_data_only, 5)
	}
	if o.response_pending != false {
		res << vproto.pack_bool_field(o.response_pending, 6)
	}
	if o.http_min_size != u32(0) {
		res << vproto.pack_uint32_field(o.http_min_size, 7)
	}
	if o.http_host != '' {
		res << vproto.pack_string_field(o.http_host, 8)
	}
	return res
}

pub fn cmsgclientpicsproductinforesponse_unpack(buf []byte) ?CMsgClientPICSProductInfoResponse {
	mut res := zzz_vproto_internal_new_cmsgclientpicsproductinforesponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse_appinfo(cur_buf,
					tag_wiretype.wire_type) ?
				res.apps << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.unknown_appids << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse_packageinfo(cur_buf,
					tag_wiretype.wire_type) ?
				res.packages << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.unknown_packageids << v
				i = ii
			}
			5 {
				i, res.meta_data_only = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.response_pending = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.http_min_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.http_host = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSProductInfoResponse) eq(b CMsgClientPICSProductInfoResponse) bool {
	return true && a.apps.eq(b.apps) && a.unknown_appids == b.unknown_appids && a.packages.eq(b.packages) &&
		a.unknown_packageids == b.unknown_packageids && a.meta_data_only == b.meta_data_only &&
		a.response_pending == b.response_pending && a.http_min_size == b.http_min_size && a.http_host ==
		b.http_host
}

[inline]
pub fn (a CMsgClientPICSProductInfoResponse) ne(b CMsgClientPICSProductInfoResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSProductInfoResponse) eq(b []CMsgClientPICSProductInfoResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSProductInfoResponse) ne(b []CMsgClientPICSProductInfoResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforesponse() CMsgClientPICSProductInfoResponse {
	return CMsgClientPICSProductInfoResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse(o CMsgClientPICSProductInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicsproductinforesponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSAccessTokenRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	packageids     []u32
	appids         []u32
}

pub fn (o &CMsgClientPICSAccessTokenRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.packageids {
		res << vproto.pack_uint32_field(x, 1)
	}
	// [packed=false]
	for _, x in o.appids {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cmsgclientpicsaccesstokenrequest_unpack(buf []byte) ?CMsgClientPICSAccessTokenRequest {
	mut res := zzz_vproto_internal_new_cmsgclientpicsaccesstokenrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.packageids << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSAccessTokenRequest) eq(b CMsgClientPICSAccessTokenRequest) bool {
	return true && a.packageids == b.packageids && a.appids == b.appids
}

[inline]
pub fn (a CMsgClientPICSAccessTokenRequest) ne(b CMsgClientPICSAccessTokenRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSAccessTokenRequest) eq(b []CMsgClientPICSAccessTokenRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSAccessTokenRequest) ne(b []CMsgClientPICSAccessTokenRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenrequest() CMsgClientPICSAccessTokenRequest {
	return CMsgClientPICSAccessTokenRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenrequest(o CMsgClientPICSAccessTokenRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSAccessTokenRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicsaccesstokenrequest_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSAccessTokenResponse_PackageToken {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	packageid      u32
	access_token   u64
}

pub fn (o &CMsgClientPICSAccessTokenResponse_PackageToken) pack() []byte {
	mut res := []byte{}
	if o.packageid != u32(0) {
		res << vproto.pack_uint32_field(o.packageid, 1)
	}
	if o.access_token != u64(0) {
		res << vproto.pack_uint64_field(o.access_token, 2)
	}
	return res
}

pub fn cmsgclientpicsaccesstokenresponse_packagetoken_unpack(buf []byte) ?CMsgClientPICSAccessTokenResponse_PackageToken {
	mut res := zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponse_packagetoken()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.packageid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.access_token = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSAccessTokenResponse_PackageToken) eq(b CMsgClientPICSAccessTokenResponse_PackageToken) bool {
	return true && a.packageid == b.packageid && a.access_token == b.access_token
}

[inline]
pub fn (a CMsgClientPICSAccessTokenResponse_PackageToken) ne(b CMsgClientPICSAccessTokenResponse_PackageToken) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSAccessTokenResponse_PackageToken) eq(b []CMsgClientPICSAccessTokenResponse_PackageToken) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSAccessTokenResponse_PackageToken) ne(b []CMsgClientPICSAccessTokenResponse_PackageToken) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponse_packagetoken() CMsgClientPICSAccessTokenResponse_PackageToken {
	return CMsgClientPICSAccessTokenResponse_PackageToken{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse_packagetoken(o CMsgClientPICSAccessTokenResponse_PackageToken, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse_packagetoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSAccessTokenResponse_PackageToken) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicsaccesstokenresponse_packagetoken_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSAccessTokenResponse_AppToken {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	access_token   u64
}

pub fn (o &CMsgClientPICSAccessTokenResponse_AppToken) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.access_token != u64(0) {
		res << vproto.pack_uint64_field(o.access_token, 2)
	}
	return res
}

pub fn cmsgclientpicsaccesstokenresponse_apptoken_unpack(buf []byte) ?CMsgClientPICSAccessTokenResponse_AppToken {
	mut res := zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponse_apptoken()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.access_token = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSAccessTokenResponse_AppToken) eq(b CMsgClientPICSAccessTokenResponse_AppToken) bool {
	return true && a.appid == b.appid && a.access_token == b.access_token
}

[inline]
pub fn (a CMsgClientPICSAccessTokenResponse_AppToken) ne(b CMsgClientPICSAccessTokenResponse_AppToken) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSAccessTokenResponse_AppToken) eq(b []CMsgClientPICSAccessTokenResponse_AppToken) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSAccessTokenResponse_AppToken) ne(b []CMsgClientPICSAccessTokenResponse_AppToken) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponse_apptoken() CMsgClientPICSAccessTokenResponse_AppToken {
	return CMsgClientPICSAccessTokenResponse_AppToken{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse_apptoken(o CMsgClientPICSAccessTokenResponse_AppToken, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse_apptoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSAccessTokenResponse_AppToken) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicsaccesstokenresponse_apptoken_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientPICSAccessTokenResponse {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	package_access_tokens []CMsgClientPICSAccessTokenResponse_PackageToken
	package_denied_tokens []u32
	app_access_tokens     []CMsgClientPICSAccessTokenResponse_AppToken
	app_denied_tokens     []u32
}

pub fn (o &CMsgClientPICSAccessTokenResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.package_access_tokens {
		res <<
			zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse_packagetoken(x, 1)
	}
	// [packed=false]
	for _, x in o.package_denied_tokens {
		res << vproto.pack_uint32_field(x, 2)
	}
	// [packed=false]
	for _, x in o.app_access_tokens {
		res <<
			zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse_apptoken(x, 3)
	}
	// [packed=false]
	for _, x in o.app_denied_tokens {
		res << vproto.pack_uint32_field(x, 4)
	}
	return res
}

pub fn cmsgclientpicsaccesstokenresponse_unpack(buf []byte) ?CMsgClientPICSAccessTokenResponse {
	mut res := zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse_packagetoken(cur_buf,
					tag_wiretype.wire_type) ?
				res.package_access_tokens << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.package_denied_tokens << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse_apptoken(cur_buf,
					tag_wiretype.wire_type) ?
				res.app_access_tokens << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.app_denied_tokens << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientPICSAccessTokenResponse) eq(b CMsgClientPICSAccessTokenResponse) bool {
	return true && a.package_access_tokens.eq(b.package_access_tokens) && a.package_denied_tokens ==
		b.package_denied_tokens && a.app_access_tokens.eq(b.app_access_tokens) && a.app_denied_tokens ==
		b.app_denied_tokens
}

[inline]
pub fn (a CMsgClientPICSAccessTokenResponse) ne(b CMsgClientPICSAccessTokenResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientPICSAccessTokenResponse) eq(b []CMsgClientPICSAccessTokenResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientPICSAccessTokenResponse) ne(b []CMsgClientPICSAccessTokenResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponse() CMsgClientPICSAccessTokenResponse {
	return CMsgClientPICSAccessTokenResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse(o CMsgClientPICSAccessTokenResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSAccessTokenResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientpicsaccesstokenresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSGetUGCDetails {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	hcontent       u64 = 18446744073709551615
}

pub fn (o &CMsgClientUFSGetUGCDetails) pack() []byte {
	mut res := []byte{}
	if o.hcontent != u64(0) {
		res << vproto.pack_64bit_field(o.hcontent, 1)
	}
	return res
}

pub fn cmsgclientufsgetugcdetails_unpack(buf []byte) ?CMsgClientUFSGetUGCDetails {
	mut res := zzz_vproto_internal_new_cmsgclientufsgetugcdetails()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.hcontent = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSGetUGCDetails) eq(b CMsgClientUFSGetUGCDetails) bool {
	return true && a.hcontent == b.hcontent
}

[inline]
pub fn (a CMsgClientUFSGetUGCDetails) ne(b CMsgClientUFSGetUGCDetails) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSGetUGCDetails) eq(b []CMsgClientUFSGetUGCDetails) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSGetUGCDetails) ne(b []CMsgClientUFSGetUGCDetails) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsgetugcdetails() CMsgClientUFSGetUGCDetails {
	return CMsgClientUFSGetUGCDetails{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsgetugcdetails(o CMsgClientUFSGetUGCDetails, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetugcdetails(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetUGCDetails) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsgetugcdetails_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSGetUGCDetailsResponse {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	eresult              int = 2
	url                  string
	app_id               u32
	filename             string
	steamid_creator      u64
	file_size            u32
	compressed_file_size u32
	rangecheck_host      string
	file_encoded_sha1    string
}

pub fn (o &CMsgClientUFSGetUGCDetailsResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 3)
	}
	if o.filename != '' {
		res << vproto.pack_string_field(o.filename, 4)
	}
	if o.steamid_creator != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_creator, 5)
	}
	if o.file_size != u32(0) {
		res << vproto.pack_uint32_field(o.file_size, 6)
	}
	if o.compressed_file_size != u32(0) {
		res << vproto.pack_uint32_field(o.compressed_file_size, 7)
	}
	if o.rangecheck_host != '' {
		res << vproto.pack_string_field(o.rangecheck_host, 8)
	}
	if o.file_encoded_sha1 != '' {
		res << vproto.pack_string_field(o.file_encoded_sha1, 9)
	}
	return res
}

pub fn cmsgclientufsgetugcdetailsresponse_unpack(buf []byte) ?CMsgClientUFSGetUGCDetailsResponse {
	mut res := zzz_vproto_internal_new_cmsgclientufsgetugcdetailsresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.url = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.filename = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.steamid_creator = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.file_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.compressed_file_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.rangecheck_host = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.file_encoded_sha1 = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSGetUGCDetailsResponse) eq(b CMsgClientUFSGetUGCDetailsResponse) bool {
	return true && a.eresult == b.eresult && a.url == b.url && a.app_id == b.app_id &&
		a.filename == b.filename && a.steamid_creator == b.steamid_creator && a.file_size == b.file_size &&
		a.compressed_file_size == b.compressed_file_size && a.rangecheck_host == b.rangecheck_host &&
		a.file_encoded_sha1 == b.file_encoded_sha1
}

[inline]
pub fn (a CMsgClientUFSGetUGCDetailsResponse) ne(b CMsgClientUFSGetUGCDetailsResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSGetUGCDetailsResponse) eq(b []CMsgClientUFSGetUGCDetailsResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSGetUGCDetailsResponse) ne(b []CMsgClientUFSGetUGCDetailsResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsgetugcdetailsresponse() CMsgClientUFSGetUGCDetailsResponse {
	return CMsgClientUFSGetUGCDetailsResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsgetugcdetailsresponse(o CMsgClientUFSGetUGCDetailsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetugcdetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetUGCDetailsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsgetugcdetailsresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSGetSingleFileInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	file_name      string
}

pub fn (o &CMsgClientUFSGetSingleFileInfo) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.file_name != '' {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	return res
}

pub fn cmsgclientufsgetsinglefileinfo_unpack(buf []byte) ?CMsgClientUFSGetSingleFileInfo {
	mut res := zzz_vproto_internal_new_cmsgclientufsgetsinglefileinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.file_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSGetSingleFileInfo) eq(b CMsgClientUFSGetSingleFileInfo) bool {
	return true && a.app_id == b.app_id && a.file_name == b.file_name
}

[inline]
pub fn (a CMsgClientUFSGetSingleFileInfo) ne(b CMsgClientUFSGetSingleFileInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSGetSingleFileInfo) eq(b []CMsgClientUFSGetSingleFileInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSGetSingleFileInfo) ne(b []CMsgClientUFSGetSingleFileInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsgetsinglefileinfo() CMsgClientUFSGetSingleFileInfo {
	return CMsgClientUFSGetSingleFileInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsgetsinglefileinfo(o CMsgClientUFSGetSingleFileInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetsinglefileinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetSingleFileInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsgetsinglefileinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSGetSingleFileInfoResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	eresult            int = 2
	app_id             u32
	file_name          string
	sha_file           []byte
	time_stamp         u64
	raw_file_size      u32
	is_explicit_delete bool
}

pub fn (o &CMsgClientUFSGetSingleFileInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.file_name != '' {
		res << vproto.pack_string_field(o.file_name, 3)
	}
	if o.sha_file != []byte{} {
		res << vproto.pack_bytes_field(o.sha_file, 4)
	}
	if o.time_stamp != u64(0) {
		res << vproto.pack_uint64_field(o.time_stamp, 5)
	}
	if o.raw_file_size != u32(0) {
		res << vproto.pack_uint32_field(o.raw_file_size, 6)
	}
	if o.is_explicit_delete != false {
		res << vproto.pack_bool_field(o.is_explicit_delete, 7)
	}
	return res
}

pub fn cmsgclientufsgetsinglefileinforesponse_unpack(buf []byte) ?CMsgClientUFSGetSingleFileInfoResponse {
	mut res := zzz_vproto_internal_new_cmsgclientufsgetsinglefileinforesponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.file_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.sha_file = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.time_stamp = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.raw_file_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.is_explicit_delete = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSGetSingleFileInfoResponse) eq(b CMsgClientUFSGetSingleFileInfoResponse) bool {
	return true && a.eresult == b.eresult && a.app_id == b.app_id && a.file_name == b.file_name &&
		a.sha_file == b.sha_file && a.time_stamp == b.time_stamp && a.raw_file_size == b.raw_file_size &&
		a.is_explicit_delete == b.is_explicit_delete
}

[inline]
pub fn (a CMsgClientUFSGetSingleFileInfoResponse) ne(b CMsgClientUFSGetSingleFileInfoResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSGetSingleFileInfoResponse) eq(b []CMsgClientUFSGetSingleFileInfoResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSGetSingleFileInfoResponse) ne(b []CMsgClientUFSGetSingleFileInfoResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufsgetsinglefileinforesponse() CMsgClientUFSGetSingleFileInfoResponse {
	return CMsgClientUFSGetSingleFileInfoResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufsgetsinglefileinforesponse(o CMsgClientUFSGetSingleFileInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetsinglefileinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetSingleFileInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufsgetsinglefileinforesponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSShareFile {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	file_name      string
}

pub fn (o &CMsgClientUFSShareFile) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.file_name != '' {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	return res
}

pub fn cmsgclientufssharefile_unpack(buf []byte) ?CMsgClientUFSShareFile {
	mut res := zzz_vproto_internal_new_cmsgclientufssharefile()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.file_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSShareFile) eq(b CMsgClientUFSShareFile) bool {
	return true && a.app_id == b.app_id && a.file_name == b.file_name
}

[inline]
pub fn (a CMsgClientUFSShareFile) ne(b CMsgClientUFSShareFile) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSShareFile) eq(b []CMsgClientUFSShareFile) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSShareFile) ne(b []CMsgClientUFSShareFile) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufssharefile() CMsgClientUFSShareFile {
	return CMsgClientUFSShareFile{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufssharefile(o CMsgClientUFSShareFile, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufssharefile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSShareFile) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufssharefile_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUFSShareFileResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	hcontent       u64 = 18446744073709551615
}

pub fn (o &CMsgClientUFSShareFileResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.hcontent != u64(0) {
		res << vproto.pack_64bit_field(o.hcontent, 2)
	}
	return res
}

pub fn cmsgclientufssharefileresponse_unpack(buf []byte) ?CMsgClientUFSShareFileResponse {
	mut res := zzz_vproto_internal_new_cmsgclientufssharefileresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.hcontent = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUFSShareFileResponse) eq(b CMsgClientUFSShareFileResponse) bool {
	return true && a.eresult == b.eresult && a.hcontent == b.hcontent
}

[inline]
pub fn (a CMsgClientUFSShareFileResponse) ne(b CMsgClientUFSShareFileResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUFSShareFileResponse) eq(b []CMsgClientUFSShareFileResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUFSShareFileResponse) ne(b []CMsgClientUFSShareFileResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientufssharefileresponse() CMsgClientUFSShareFileResponse {
	return CMsgClientUFSShareFileResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientufssharefileresponse(o CMsgClientUFSShareFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientufssharefileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSShareFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientufssharefileresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAMGetClanOfficers {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid_clan   u64
}

pub fn (o &CMsgClientAMGetClanOfficers) pack() []byte {
	mut res := []byte{}
	if o.steamid_clan != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_clan, 1)
	}
	return res
}

pub fn cmsgclientamgetclanofficers_unpack(buf []byte) ?CMsgClientAMGetClanOfficers {
	mut res := zzz_vproto_internal_new_cmsgclientamgetclanofficers()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid_clan = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAMGetClanOfficers) eq(b CMsgClientAMGetClanOfficers) bool {
	return true && a.steamid_clan == b.steamid_clan
}

[inline]
pub fn (a CMsgClientAMGetClanOfficers) ne(b CMsgClientAMGetClanOfficers) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAMGetClanOfficers) eq(b []CMsgClientAMGetClanOfficers) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAMGetClanOfficers) ne(b []CMsgClientAMGetClanOfficers) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientamgetclanofficers() CMsgClientAMGetClanOfficers {
	return CMsgClientAMGetClanOfficers{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientamgetclanofficers(o CMsgClientAMGetClanOfficers, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientamgetclanofficers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetClanOfficers) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientamgetclanofficers_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAMGetClanOfficersResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	steamid_clan   u64
	officer_count  int
}

pub fn (o &CMsgClientAMGetClanOfficersResponse) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.steamid_clan != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_clan, 2)
	}
	if o.officer_count != int(0) {
		res << vproto.pack_int32_field(o.officer_count, 3)
	}
	return res
}

pub fn cmsgclientamgetclanofficersresponse_unpack(buf []byte) ?CMsgClientAMGetClanOfficersResponse {
	mut res := zzz_vproto_internal_new_cmsgclientamgetclanofficersresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steamid_clan = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.officer_count = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAMGetClanOfficersResponse) eq(b CMsgClientAMGetClanOfficersResponse) bool {
	return true && a.eresult == b.eresult && a.steamid_clan == b.steamid_clan && a.officer_count ==
		b.officer_count
}

[inline]
pub fn (a CMsgClientAMGetClanOfficersResponse) ne(b CMsgClientAMGetClanOfficersResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAMGetClanOfficersResponse) eq(b []CMsgClientAMGetClanOfficersResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAMGetClanOfficersResponse) ne(b []CMsgClientAMGetClanOfficersResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientamgetclanofficersresponse() CMsgClientAMGetClanOfficersResponse {
	return CMsgClientAMGetClanOfficersResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientamgetclanofficersresponse(o CMsgClientAMGetClanOfficersResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientamgetclanofficersresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetClanOfficersResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientamgetclanofficersresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAMGetPersonaNameHistory_IdInstance {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
}

pub fn (o &CMsgClientAMGetPersonaNameHistory_IdInstance) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cmsgclientamgetpersonanamehistory_idinstance_unpack(buf []byte) ?CMsgClientAMGetPersonaNameHistory_IdInstance {
	mut res := zzz_vproto_internal_new_cmsgclientamgetpersonanamehistory_idinstance()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAMGetPersonaNameHistory_IdInstance) eq(b CMsgClientAMGetPersonaNameHistory_IdInstance) bool {
	return true && a.steamid == b.steamid
}

[inline]
pub fn (a CMsgClientAMGetPersonaNameHistory_IdInstance) ne(b CMsgClientAMGetPersonaNameHistory_IdInstance) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAMGetPersonaNameHistory_IdInstance) eq(b []CMsgClientAMGetPersonaNameHistory_IdInstance) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAMGetPersonaNameHistory_IdInstance) ne(b []CMsgClientAMGetPersonaNameHistory_IdInstance) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistory_idinstance() CMsgClientAMGetPersonaNameHistory_IdInstance {
	return CMsgClientAMGetPersonaNameHistory_IdInstance{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistory_idinstance(o CMsgClientAMGetPersonaNameHistory_IdInstance, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistory_idinstance(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetPersonaNameHistory_IdInstance) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientamgetpersonanamehistory_idinstance_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAMGetPersonaNameHistory {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	id_count       int
	ids            []CMsgClientAMGetPersonaNameHistory_IdInstance
}

pub fn (o &CMsgClientAMGetPersonaNameHistory) pack() []byte {
	mut res := []byte{}
	if o.id_count != int(0) {
		res << vproto.pack_int32_field(o.id_count, 1)
	}
	// [packed=false]
	for _, x in o.ids {
		res <<
			zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistory_idinstance(x, 2)
	}
	return res
}

pub fn cmsgclientamgetpersonanamehistory_unpack(buf []byte) ?CMsgClientAMGetPersonaNameHistory {
	mut res := zzz_vproto_internal_new_cmsgclientamgetpersonanamehistory()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.id_count = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistory_idinstance(cur_buf,
					tag_wiretype.wire_type) ?
				res.ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAMGetPersonaNameHistory) eq(b CMsgClientAMGetPersonaNameHistory) bool {
	return true && a.id_count == b.id_count && a.ids.eq(b.ids)
}

[inline]
pub fn (a CMsgClientAMGetPersonaNameHistory) ne(b CMsgClientAMGetPersonaNameHistory) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAMGetPersonaNameHistory) eq(b []CMsgClientAMGetPersonaNameHistory) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAMGetPersonaNameHistory) ne(b []CMsgClientAMGetPersonaNameHistory) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistory() CMsgClientAMGetPersonaNameHistory {
	return CMsgClientAMGetPersonaNameHistory{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistory(o CMsgClientAMGetPersonaNameHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetPersonaNameHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientamgetpersonanamehistory_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name_since     u32
	name           string
}

pub fn (o &CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) pack() []byte {
	mut res := []byte{}
	if o.name_since != u32(0) {
		res << vproto.pack_32bit_field(o.name_since, 1)
	}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance_unpack(buf []byte) ?CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance {
	mut res := zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.name_since = vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) eq(b CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) bool {
	return true && a.name_since == b.name_since && a.name == b.name
}

[inline]
pub fn (a CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) ne(b CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) eq(b []CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) ne(b []CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance() CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance {
	return CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance(o CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int = 2
	steamid        u64
	names          []CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance
}

pub fn (o &CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) pack() []byte {
	mut res := []byte{}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	// [packed=false]
	for _, x in o.names {
		res <<
			zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance(x, 3)
	}
	return res
}

pub fn cmsgclientamgetpersonanamehistoryresponse_nametableinstance_unpack(buf []byte) ?CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
	mut res := zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponse_nametableinstance()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eresult = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance(cur_buf,
					tag_wiretype.wire_type) ?
				res.names << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) eq(b CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) bool {
	return true && a.eresult == b.eresult && a.steamid == b.steamid && a.names.eq(b.names)
}

[inline]
pub fn (a CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) ne(b CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) eq(b []CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) ne(b []CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponse_nametableinstance() CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
	return CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponse_nametableinstance(o CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponse_nametableinstance(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientamgetpersonanamehistoryresponse_nametableinstance_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientAMGetPersonaNameHistoryResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	responses      []CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance
}

pub fn (o &CMsgClientAMGetPersonaNameHistoryResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.responses {
		res <<
			zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponse_nametableinstance(x, 2)
	}
	return res
}

pub fn cmsgclientamgetpersonanamehistoryresponse_unpack(buf []byte) ?CMsgClientAMGetPersonaNameHistoryResponse {
	mut res := zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponse_nametableinstance(cur_buf,
					tag_wiretype.wire_type) ?
				res.responses << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientAMGetPersonaNameHistoryResponse) eq(b CMsgClientAMGetPersonaNameHistoryResponse) bool {
	return true && a.responses.eq(b.responses)
}

[inline]
pub fn (a CMsgClientAMGetPersonaNameHistoryResponse) ne(b CMsgClientAMGetPersonaNameHistoryResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientAMGetPersonaNameHistoryResponse) eq(b []CMsgClientAMGetPersonaNameHistoryResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientAMGetPersonaNameHistoryResponse) ne(b []CMsgClientAMGetPersonaNameHistoryResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponse() CMsgClientAMGetPersonaNameHistoryResponse {
	return CMsgClientAMGetPersonaNameHistoryResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponse(o CMsgClientAMGetPersonaNameHistoryResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetPersonaNameHistoryResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientamgetpersonanamehistoryresponse_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientDeregisterWithServer {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eservertype    u32
	app_id         u32
}

pub fn (o &CMsgClientDeregisterWithServer) pack() []byte {
	mut res := []byte{}
	if o.eservertype != u32(0) {
		res << vproto.pack_uint32_field(o.eservertype, 1)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	return res
}

pub fn cmsgclientderegisterwithserver_unpack(buf []byte) ?CMsgClientDeregisterWithServer {
	mut res := zzz_vproto_internal_new_cmsgclientderegisterwithserver()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.eservertype = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientDeregisterWithServer) eq(b CMsgClientDeregisterWithServer) bool {
	return true && a.eservertype == b.eservertype && a.app_id == b.app_id
}

[inline]
pub fn (a CMsgClientDeregisterWithServer) ne(b CMsgClientDeregisterWithServer) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientDeregisterWithServer) eq(b []CMsgClientDeregisterWithServer) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientDeregisterWithServer) ne(b []CMsgClientDeregisterWithServer) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientderegisterwithserver() CMsgClientDeregisterWithServer {
	return CMsgClientDeregisterWithServer{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientderegisterwithserver(o CMsgClientDeregisterWithServer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientderegisterwithserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeregisterWithServer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientderegisterwithserver_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientClanState_NameInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	clan_name      string
	sha_avatar     []byte
}

pub fn (o &CMsgClientClanState_NameInfo) pack() []byte {
	mut res := []byte{}
	if o.clan_name != '' {
		res << vproto.pack_string_field(o.clan_name, 1)
	}
	if o.sha_avatar != []byte{} {
		res << vproto.pack_bytes_field(o.sha_avatar, 2)
	}
	return res
}

pub fn cmsgclientclanstate_nameinfo_unpack(buf []byte) ?CMsgClientClanState_NameInfo {
	mut res := zzz_vproto_internal_new_cmsgclientclanstate_nameinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.clan_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.sha_avatar = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientClanState_NameInfo) eq(b CMsgClientClanState_NameInfo) bool {
	return true && a.clan_name == b.clan_name && a.sha_avatar == b.sha_avatar
}

[inline]
pub fn (a CMsgClientClanState_NameInfo) ne(b CMsgClientClanState_NameInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientClanState_NameInfo) eq(b []CMsgClientClanState_NameInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientClanState_NameInfo) ne(b []CMsgClientClanState_NameInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientclanstate_nameinfo() CMsgClientClanState_NameInfo {
	return CMsgClientClanState_NameInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientclanstate_nameinfo(o CMsgClientClanState_NameInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientclanstate_nameinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanState_NameInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientclanstate_nameinfo_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientClanState_UserCounts {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	members           u32
	online            u32
	chatting          u32
	in_game           u32
	chat_room_members u32
}

pub fn (o &CMsgClientClanState_UserCounts) pack() []byte {
	mut res := []byte{}
	if o.members != u32(0) {
		res << vproto.pack_uint32_field(o.members, 1)
	}
	if o.online != u32(0) {
		res << vproto.pack_uint32_field(o.online, 2)
	}
	if o.chatting != u32(0) {
		res << vproto.pack_uint32_field(o.chatting, 3)
	}
	if o.in_game != u32(0) {
		res << vproto.pack_uint32_field(o.in_game, 4)
	}
	if o.chat_room_members != u32(0) {
		res << vproto.pack_uint32_field(o.chat_room_members, 5)
	}
	return res
}

pub fn cmsgclientclanstate_usercounts_unpack(buf []byte) ?CMsgClientClanState_UserCounts {
	mut res := zzz_vproto_internal_new_cmsgclientclanstate_usercounts()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.members = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.online = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.chatting = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.in_game = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.chat_room_members = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientClanState_UserCounts) eq(b CMsgClientClanState_UserCounts) bool {
	return true && a.members == b.members && a.online == b.online && a.chatting == b.chatting &&
		a.in_game == b.in_game && a.chat_room_members == b.chat_room_members
}

[inline]
pub fn (a CMsgClientClanState_UserCounts) ne(b CMsgClientClanState_UserCounts) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientClanState_UserCounts) eq(b []CMsgClientClanState_UserCounts) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientClanState_UserCounts) ne(b []CMsgClientClanState_UserCounts) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientclanstate_usercounts() CMsgClientClanState_UserCounts {
	return CMsgClientClanState_UserCounts{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientclanstate_usercounts(o CMsgClientClanState_UserCounts, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientclanstate_usercounts(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanState_UserCounts) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientclanstate_usercounts_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientClanState_Event {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	gid            u64
	event_time     u32
	headline       string
	game_id        u64
	just_posted    bool
}

pub fn (o &CMsgClientClanState_Event) pack() []byte {
	mut res := []byte{}
	if o.gid != u64(0) {
		res << vproto.pack_64bit_field(o.gid, 1)
	}
	if o.event_time != u32(0) {
		res << vproto.pack_uint32_field(o.event_time, 2)
	}
	if o.headline != '' {
		res << vproto.pack_string_field(o.headline, 3)
	}
	if o.game_id != u64(0) {
		res << vproto.pack_64bit_field(o.game_id, 4)
	}
	if o.just_posted != false {
		res << vproto.pack_bool_field(o.just_posted, 5)
	}
	return res
}

pub fn cmsgclientclanstate_event_unpack(buf []byte) ?CMsgClientClanState_Event {
	mut res := zzz_vproto_internal_new_cmsgclientclanstate_event()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.gid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.event_time = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.headline = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.game_id = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.just_posted = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientClanState_Event) eq(b CMsgClientClanState_Event) bool {
	return true && a.gid == b.gid && a.event_time == b.event_time && a.headline == b.headline &&
		a.game_id == b.game_id && a.just_posted == b.just_posted
}

[inline]
pub fn (a CMsgClientClanState_Event) ne(b CMsgClientClanState_Event) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientClanState_Event) eq(b []CMsgClientClanState_Event) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientClanState_Event) ne(b []CMsgClientClanState_Event) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientclanstate_event() CMsgClientClanState_Event {
	return CMsgClientClanState_Event{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientclanstate_event(o CMsgClientClanState_Event, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientclanstate_event(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanState_Event) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientclanstate_event_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientClanState {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steamid_clan       u64
	clan_account_flags u32
	name_info          CMsgClientClanState_NameInfo
	user_counts        CMsgClientClanState_UserCounts
	events             []CMsgClientClanState_Event
	announcements      []CMsgClientClanState_Event
	chat_room_private  bool
}

pub fn (o &CMsgClientClanState) pack() []byte {
	mut res := []byte{}
	if o.steamid_clan != u64(0) {
		res << vproto.pack_64bit_field(o.steamid_clan, 1)
	}
	if o.clan_account_flags != u32(0) {
		res << vproto.pack_uint32_field(o.clan_account_flags, 3)
	}
	if o.name_info.ne(zzz_vproto_internal_new_cmsgclientclanstate_nameinfo()) {
		res << zzz_vproto_internal_pack_cmsgclientclanstate_nameinfo(o.name_info, 4)
	}
	if o.user_counts.ne(zzz_vproto_internal_new_cmsgclientclanstate_usercounts()) {
		res <<
			zzz_vproto_internal_pack_cmsgclientclanstate_usercounts(o.user_counts, 5)
	}
	// [packed=false]
	for _, x in o.events {
		res << zzz_vproto_internal_pack_cmsgclientclanstate_event(x, 6)
	}
	// [packed=false]
	for _, x in o.announcements {
		res << zzz_vproto_internal_pack_cmsgclientclanstate_event(x, 7)
	}
	if o.chat_room_private != false {
		res << vproto.pack_bool_field(o.chat_room_private, 8)
	}
	return res
}

pub fn cmsgclientclanstate_unpack(buf []byte) ?CMsgClientClanState {
	mut res := zzz_vproto_internal_new_cmsgclientclanstate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid_clan = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.clan_account_flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.name_info = zzz_vproto_internal_unpack_cmsgclientclanstate_nameinfo(cur_buf,
					tag_wiretype.wire_type) ?
			}
			5 {
				i, res.user_counts = zzz_vproto_internal_unpack_cmsgclientclanstate_usercounts(cur_buf,
					tag_wiretype.wire_type) ?
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientclanstate_event(cur_buf,
					tag_wiretype.wire_type) ?
				res.events << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientclanstate_event(cur_buf,
					tag_wiretype.wire_type) ?
				res.announcements << v
				i = ii
			}
			8 {
				i, res.chat_room_private = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientClanState) eq(b CMsgClientClanState) bool {
	return true && a.steamid_clan == b.steamid_clan && a.clan_account_flags == b.clan_account_flags &&
		a.name_info.eq(b.name_info) && a.user_counts.eq(b.user_counts) && a.events.eq(b.events) && a.announcements.eq(b.announcements) &&
		a.chat_room_private == b.chat_room_private
}

[inline]
pub fn (a CMsgClientClanState) ne(b CMsgClientClanState) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientClanState) eq(b []CMsgClientClanState) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientClanState) ne(b []CMsgClientClanState) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientclanstate() CMsgClientClanState {
	return CMsgClientClanState{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientclanstate(o CMsgClientClanState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientclanstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientclanstate_unpack(v) ?
	return i, unpacked
}

pub struct CMsgClientUnsignedInstallScript {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	app_id           u32
	file_name        string
	file_size        u32
	signature_broken bool
	depot_id         u32
	manifest_id      u64
	file_flags       u32
}

pub fn (o &CMsgClientUnsignedInstallScript) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.file_name != '' {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	if o.file_size != u32(0) {
		res << vproto.pack_uint32_field(o.file_size, 3)
	}
	if o.signature_broken != false {
		res << vproto.pack_bool_field(o.signature_broken, 4)
	}
	if o.depot_id != u32(0) {
		res << vproto.pack_uint32_field(o.depot_id, 5)
	}
	if o.manifest_id != u64(0) {
		res << vproto.pack_uint64_field(o.manifest_id, 6)
	}
	if o.file_flags != u32(0) {
		res << vproto.pack_uint32_field(o.file_flags, 7)
	}
	return res
}

pub fn cmsgclientunsignedinstallscript_unpack(buf []byte) ?CMsgClientUnsignedInstallScript {
	mut res := zzz_vproto_internal_new_cmsgclientunsignedinstallscript()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.app_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.file_name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.file_size = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.signature_broken = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.depot_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.manifest_id = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.file_flags = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClientUnsignedInstallScript) eq(b CMsgClientUnsignedInstallScript) bool {
	return true && a.app_id == b.app_id && a.file_name == b.file_name && a.file_size == b.file_size &&
		a.signature_broken == b.signature_broken && a.depot_id == b.depot_id && a.manifest_id == b.manifest_id &&
		a.file_flags == b.file_flags
}

[inline]
pub fn (a CMsgClientUnsignedInstallScript) ne(b CMsgClientUnsignedInstallScript) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClientUnsignedInstallScript) eq(b []CMsgClientUnsignedInstallScript) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClientUnsignedInstallScript) ne(b []CMsgClientUnsignedInstallScript) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclientunsignedinstallscript() CMsgClientUnsignedInstallScript {
	return CMsgClientUnsignedInstallScript{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclientunsignedinstallscript(o CMsgClientUnsignedInstallScript, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclientunsignedinstallscript(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUnsignedInstallScript) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cmsgclientunsignedinstallscript_unpack(v) ?
	return i, unpacked
}
