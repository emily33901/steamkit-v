// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CFileVerification_SignatureCheck_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	steamid                u64
	appid                  u32
	file_size              u64
	file_timestamp         u32
	file_timestamp2        u32
	signature_result       u32
	filename               string
	client_package_version u32
	sha1hash               []byte
}

pub fn (o &CFileVerification_SignatureCheck_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.file_size != u64(0) {
		res << vproto.pack_uint64_field(o.file_size, 3)
	}
	if o.file_timestamp != u32(0) {
		res << vproto.pack_uint32_field(o.file_timestamp, 4)
	}
	if o.file_timestamp2 != u32(0) {
		res << vproto.pack_uint32_field(o.file_timestamp2, 5)
	}
	if o.signature_result != u32(0) {
		res << vproto.pack_uint32_field(o.signature_result, 6)
	}
	if o.filename != '' {
		res << vproto.pack_string_field(o.filename, 7)
	}
	if o.client_package_version != u32(0) {
		res << vproto.pack_uint32_field(o.client_package_version, 8)
	}
	if o.sha1hash != []byte{} {
		res << vproto.pack_bytes_field(o.sha1hash, 9)
	}
	return res
}

pub fn cfileverification_signaturecheck_request_unpack(buf []byte) ?CFileVerification_SignatureCheck_Request {
	mut res := zzz_vproto_internal_new_cfileverification_signaturecheck_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.steamid = vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
			}
			2 {
				i, res.appid = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.file_size = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.file_timestamp = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.file_timestamp2 = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.signature_result = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			7 {
				i, res.filename = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
			}
			8 {
				i, res.client_package_version = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			9 {
				i, res.sha1hash = vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CFileVerification_SignatureCheck_Request) eq(b CFileVerification_SignatureCheck_Request) bool {
	return true && a.steamid == b.steamid && a.appid == b.appid && a.file_size == b.file_size &&
		a.file_timestamp == b.file_timestamp && a.file_timestamp2 == b.file_timestamp2 && a.signature_result ==
		b.signature_result && a.filename == b.filename && a.client_package_version == b.client_package_version &&
		a.sha1hash == b.sha1hash
}

[inline]
pub fn (a CFileVerification_SignatureCheck_Request) ne(b CFileVerification_SignatureCheck_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CFileVerification_SignatureCheck_Request) eq(b []CFileVerification_SignatureCheck_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CFileVerification_SignatureCheck_Request) ne(b []CFileVerification_SignatureCheck_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cfileverification_signaturecheck_request() CFileVerification_SignatureCheck_Request {
	return CFileVerification_SignatureCheck_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cfileverification_signaturecheck_request(o CFileVerification_SignatureCheck_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cfileverification_signaturecheck_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CFileVerification_SignatureCheck_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cfileverification_signaturecheck_request_unpack(v) ?
	return i, unpacked
}

pub struct CFileVerification_SignatureCheck_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	deny_operation bool
}

pub fn (o &CFileVerification_SignatureCheck_Response) pack() []byte {
	mut res := []byte{}
	if o.deny_operation != false {
		res << vproto.pack_bool_field(o.deny_operation, 1)
	}
	return res
}

pub fn cfileverification_signaturecheck_response_unpack(buf []byte) ?CFileVerification_SignatureCheck_Response {
	mut res := zzz_vproto_internal_new_cfileverification_signaturecheck_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.deny_operation = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CFileVerification_SignatureCheck_Response) eq(b CFileVerification_SignatureCheck_Response) bool {
	return true && a.deny_operation == b.deny_operation
}

[inline]
pub fn (a CFileVerification_SignatureCheck_Response) ne(b CFileVerification_SignatureCheck_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CFileVerification_SignatureCheck_Response) eq(b []CFileVerification_SignatureCheck_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CFileVerification_SignatureCheck_Response) ne(b []CFileVerification_SignatureCheck_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cfileverification_signaturecheck_response() CFileVerification_SignatureCheck_Response {
	return CFileVerification_SignatureCheck_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cfileverification_signaturecheck_response(o CFileVerification_SignatureCheck_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cfileverification_signaturecheck_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CFileVerification_SignatureCheck_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cfileverification_signaturecheck_response_unpack(v) ?
	return i, unpacked
}

pub struct CFileVerification_SteamServiceCheck_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	service_status         u32
	client_package_version u32
	launcher_type          u32
	os_type                u32
	service_repair         u32
}

pub fn (o &CFileVerification_SteamServiceCheck_Request) pack() []byte {
	mut res := []byte{}
	if o.service_status != u32(0) {
		res << vproto.pack_uint32_field(o.service_status, 2)
	}
	if o.client_package_version != u32(0) {
		res << vproto.pack_uint32_field(o.client_package_version, 3)
	}
	if o.launcher_type != u32(0) {
		res << vproto.pack_uint32_field(o.launcher_type, 4)
	}
	if o.os_type != u32(0) {
		res << vproto.pack_uint32_field(o.os_type, 5)
	}
	if o.service_repair != u32(0) {
		res << vproto.pack_uint32_field(o.service_repair, 6)
	}
	return res
}

pub fn cfileverification_steamservicecheck_request_unpack(buf []byte) ?CFileVerification_SteamServiceCheck_Request {
	mut res := zzz_vproto_internal_new_cfileverification_steamservicecheck_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				i, res.service_status = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			3 {
				i, res.client_package_version = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			4 {
				i, res.launcher_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			5 {
				i, res.os_type = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			6 {
				i, res.service_repair = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CFileVerification_SteamServiceCheck_Request) eq(b CFileVerification_SteamServiceCheck_Request) bool {
	return true && a.service_status == b.service_status && a.client_package_version == b.client_package_version &&
		a.launcher_type == b.launcher_type && a.os_type == b.os_type && a.service_repair == b.service_repair
}

[inline]
pub fn (a CFileVerification_SteamServiceCheck_Request) ne(b CFileVerification_SteamServiceCheck_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CFileVerification_SteamServiceCheck_Request) eq(b []CFileVerification_SteamServiceCheck_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CFileVerification_SteamServiceCheck_Request) ne(b []CFileVerification_SteamServiceCheck_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cfileverification_steamservicecheck_request() CFileVerification_SteamServiceCheck_Request {
	return CFileVerification_SteamServiceCheck_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cfileverification_steamservicecheck_request(o CFileVerification_SteamServiceCheck_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cfileverification_steamservicecheck_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CFileVerification_SteamServiceCheck_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cfileverification_steamservicecheck_request_unpack(v) ?
	return i, unpacked
}

pub struct CFileVerification_SteamServiceCheck_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	attempt_repair bool
}

pub fn (o &CFileVerification_SteamServiceCheck_Response) pack() []byte {
	mut res := []byte{}
	if o.attempt_repair != false {
		res << vproto.pack_bool_field(o.attempt_repair, 1)
	}
	return res
}

pub fn cfileverification_steamservicecheck_response_unpack(buf []byte) ?CFileVerification_SteamServiceCheck_Response {
	mut res := zzz_vproto_internal_new_cfileverification_steamservicecheck_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.attempt_repair = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CFileVerification_SteamServiceCheck_Response) eq(b CFileVerification_SteamServiceCheck_Response) bool {
	return true && a.attempt_repair == b.attempt_repair
}

[inline]
pub fn (a CFileVerification_SteamServiceCheck_Response) ne(b CFileVerification_SteamServiceCheck_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CFileVerification_SteamServiceCheck_Response) eq(b []CFileVerification_SteamServiceCheck_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CFileVerification_SteamServiceCheck_Response) ne(b []CFileVerification_SteamServiceCheck_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cfileverification_steamservicecheck_response() CFileVerification_SteamServiceCheck_Response {
	return CFileVerification_SteamServiceCheck_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cfileverification_steamservicecheck_response(o CFileVerification_SteamServiceCheck_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cfileverification_steamservicecheck_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CFileVerification_SteamServiceCheck_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cfileverification_steamservicecheck_response_unpack(v) ?
	return i, unpacked
}
