// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct ParentalApp {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	is_allowed     bool
}

pub fn (o &ParentalApp) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.is_allowed != false {
		res << vproto.pack_bool_field(o.is_allowed, 2)
	}
	return res
}

pub fn parentalapp_unpack(buf []byte) ?ParentalApp {
	mut res := zzz_vproto_internal_new_parentalapp()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.is_allowed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ParentalApp) eq(b ParentalApp) bool {
	return true && a.appid == b.appid && a.is_allowed == b.is_allowed
}

[inline]
pub fn (a ParentalApp) ne(b ParentalApp) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ParentalApp) eq(b []ParentalApp) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ParentalApp) ne(b []ParentalApp) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_parentalapp() ParentalApp {
	return ParentalApp{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_parentalapp(o ParentalApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_parentalapp(buf []byte, tag_wiretype vproto.WireType) ?(int, ParentalApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := parentalapp_unpack(v) ?
	return i, unpacked
}

pub struct ParentalSettings {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	steamid                  u64
	applist_base_id          u32
	applist_base_description string
	applist_base             []ParentalApp
	applist_custom           []ParentalApp
	passwordhashtype         u32
	salt                     []byte
	passwordhash             []byte
	is_enabled               bool
	enabled_features         u32
	recovery_email           string
	is_site_license_lock     bool
}

pub fn (o &ParentalSettings) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.applist_base_id != u32(0) {
		res << vproto.pack_uint32_field(o.applist_base_id, 2)
	}
	if o.applist_base_description != '' {
		res << vproto.pack_string_field(o.applist_base_description, 3)
	}
	// [packed=false]
	for _, x in o.applist_base {
		res << zzz_vproto_internal_pack_parentalapp(x, 4)
	}
	// [packed=false]
	for _, x in o.applist_custom {
		res << zzz_vproto_internal_pack_parentalapp(x, 5)
	}
	if o.passwordhashtype != u32(0) {
		res << vproto.pack_uint32_field(o.passwordhashtype, 6)
	}
	if o.salt != []byte{} {
		res << vproto.pack_bytes_field(o.salt, 7)
	}
	if o.passwordhash != []byte{} {
		res << vproto.pack_bytes_field(o.passwordhash, 8)
	}
	if o.is_enabled != false {
		res << vproto.pack_bool_field(o.is_enabled, 9)
	}
	if o.enabled_features != u32(0) {
		res << vproto.pack_uint32_field(o.enabled_features, 10)
	}
	if o.recovery_email != '' {
		res << vproto.pack_string_field(o.recovery_email, 11)
	}
	if o.is_site_license_lock != false {
		res << vproto.pack_bool_field(o.is_site_license_lock, 12)
	}
	return res
}

pub fn parentalsettings_unpack(buf []byte) ?ParentalSettings {
	mut res := zzz_vproto_internal_new_parentalsettings()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.applist_base_id = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.applist_base_description = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_parentalapp(cur_buf, tag_wiretype.wire_type) ?
				res.applist_base << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_parentalapp(cur_buf, tag_wiretype.wire_type) ?
				res.applist_custom << v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.passwordhashtype = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.salt = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.passwordhash = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.is_enabled = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.enabled_features = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.recovery_email = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.is_site_license_lock = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a ParentalSettings) eq(b ParentalSettings) bool {
	return true && a.steamid == b.steamid && a.applist_base_id == b.applist_base_id &&
		a.applist_base_description == b.applist_base_description && a.applist_base.eq(b.applist_base) &&
		a.applist_custom.eq(b.applist_custom) && a.passwordhashtype == b.passwordhashtype && a.salt ==
		b.salt && a.passwordhash == b.passwordhash && a.is_enabled == b.is_enabled && a.enabled_features ==
		b.enabled_features && a.recovery_email == b.recovery_email && a.is_site_license_lock == b.is_site_license_lock
}

[inline]
pub fn (a ParentalSettings) ne(b ParentalSettings) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []ParentalSettings) eq(b []ParentalSettings) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []ParentalSettings) ne(b []ParentalSettings) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_parentalsettings() ParentalSettings {
	return ParentalSettings{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_parentalsettings(o ParentalSettings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_parentalsettings(buf []byte, tag_wiretype vproto.WireType) ?(int, ParentalSettings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := parentalsettings_unpack(v) ?
	return i, unpacked
}

pub struct CParental_EnableParentalSettings_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	password       string
	settings       ParentalSettings
	sessionid      string
	enablecode     u32
	steamid        u64
}

pub fn (o &CParental_EnableParentalSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.password != '' {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.settings.ne(zzz_vproto_internal_new_parentalsettings()) {
		res << zzz_vproto_internal_pack_parentalsettings(o.settings, 2)
	}
	if o.sessionid != '' {
		res << vproto.pack_string_field(o.sessionid, 3)
	}
	if o.enablecode != u32(0) {
		res << vproto.pack_uint32_field(o.enablecode, 4)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 10)
	}
	return res
}

pub fn cparental_enableparentalsettings_request_unpack(buf []byte) ?CParental_EnableParentalSettings_Request {
	mut res := zzz_vproto_internal_new_cparental_enableparentalsettings_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.password = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_parentalsettings(cur_buf, tag_wiretype.wire_type) ?
				res.settings = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.sessionid = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.enablecode = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_EnableParentalSettings_Request) eq(b CParental_EnableParentalSettings_Request) bool {
	return true && a.password == b.password && a.settings.eq(b.settings) && a.sessionid == b.sessionid &&
		a.enablecode == b.enablecode && a.steamid == b.steamid
}

[inline]
pub fn (a CParental_EnableParentalSettings_Request) ne(b CParental_EnableParentalSettings_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_EnableParentalSettings_Request) eq(b []CParental_EnableParentalSettings_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_EnableParentalSettings_Request) ne(b []CParental_EnableParentalSettings_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_enableparentalsettings_request() CParental_EnableParentalSettings_Request {
	return CParental_EnableParentalSettings_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_enableparentalsettings_request(o CParental_EnableParentalSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_enableparentalsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_EnableParentalSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_enableparentalsettings_request_unpack(v) ?
	return i, unpacked
}

pub struct CParental_EnableParentalSettings_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_EnableParentalSettings_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_enableparentalsettings_response_unpack(buf []byte) ?CParental_EnableParentalSettings_Response {
	res := zzz_vproto_internal_new_cparental_enableparentalsettings_response()
	return res
}

[inline]
pub fn (a CParental_EnableParentalSettings_Response) eq(b CParental_EnableParentalSettings_Response) bool {
	return true
}

[inline]
pub fn (a CParental_EnableParentalSettings_Response) ne(b CParental_EnableParentalSettings_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_EnableParentalSettings_Response) eq(b []CParental_EnableParentalSettings_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_EnableParentalSettings_Response) ne(b []CParental_EnableParentalSettings_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_enableparentalsettings_response() CParental_EnableParentalSettings_Response {
	return CParental_EnableParentalSettings_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_enableparentalsettings_response(o CParental_EnableParentalSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_enableparentalsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_EnableParentalSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_enableparentalsettings_response_unpack(v) ?
	return i, unpacked
}

pub struct CParental_DisableParentalSettings_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	password       string
	steamid        u64
}

pub fn (o &CParental_DisableParentalSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.password != '' {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 10)
	}
	return res
}

pub fn cparental_disableparentalsettings_request_unpack(buf []byte) ?CParental_DisableParentalSettings_Request {
	mut res := zzz_vproto_internal_new_cparental_disableparentalsettings_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.password = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_DisableParentalSettings_Request) eq(b CParental_DisableParentalSettings_Request) bool {
	return true && a.password == b.password && a.steamid == b.steamid
}

[inline]
pub fn (a CParental_DisableParentalSettings_Request) ne(b CParental_DisableParentalSettings_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_DisableParentalSettings_Request) eq(b []CParental_DisableParentalSettings_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_DisableParentalSettings_Request) ne(b []CParental_DisableParentalSettings_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_disableparentalsettings_request() CParental_DisableParentalSettings_Request {
	return CParental_DisableParentalSettings_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_disableparentalsettings_request(o CParental_DisableParentalSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_disableparentalsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_DisableParentalSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_disableparentalsettings_request_unpack(v) ?
	return i, unpacked
}

pub struct CParental_DisableParentalSettings_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_DisableParentalSettings_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_disableparentalsettings_response_unpack(buf []byte) ?CParental_DisableParentalSettings_Response {
	res := zzz_vproto_internal_new_cparental_disableparentalsettings_response()
	return res
}

[inline]
pub fn (a CParental_DisableParentalSettings_Response) eq(b CParental_DisableParentalSettings_Response) bool {
	return true
}

[inline]
pub fn (a CParental_DisableParentalSettings_Response) ne(b CParental_DisableParentalSettings_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_DisableParentalSettings_Response) eq(b []CParental_DisableParentalSettings_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_DisableParentalSettings_Response) ne(b []CParental_DisableParentalSettings_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_disableparentalsettings_response() CParental_DisableParentalSettings_Response {
	return CParental_DisableParentalSettings_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_disableparentalsettings_response(o CParental_DisableParentalSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_disableparentalsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_DisableParentalSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_disableparentalsettings_response_unpack(v) ?
	return i, unpacked
}

pub struct CParental_GetParentalSettings_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
}

pub fn (o &CParental_GetParentalSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 10)
	}
	return res
}

pub fn cparental_getparentalsettings_request_unpack(buf []byte) ?CParental_GetParentalSettings_Request {
	mut res := zzz_vproto_internal_new_cparental_getparentalsettings_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			10 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_GetParentalSettings_Request) eq(b CParental_GetParentalSettings_Request) bool {
	return true && a.steamid == b.steamid
}

[inline]
pub fn (a CParental_GetParentalSettings_Request) ne(b CParental_GetParentalSettings_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_GetParentalSettings_Request) eq(b []CParental_GetParentalSettings_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_GetParentalSettings_Request) ne(b []CParental_GetParentalSettings_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_getparentalsettings_request() CParental_GetParentalSettings_Request {
	return CParental_GetParentalSettings_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_getparentalsettings_request(o CParental_GetParentalSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_getparentalsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_GetParentalSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_getparentalsettings_request_unpack(v) ?
	return i, unpacked
}

pub struct CParental_GetParentalSettings_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	settings       ParentalSettings
}

pub fn (o &CParental_GetParentalSettings_Response) pack() []byte {
	mut res := []byte{}
	if o.settings.ne(zzz_vproto_internal_new_parentalsettings()) {
		res << zzz_vproto_internal_pack_parentalsettings(o.settings, 1)
	}
	return res
}

pub fn cparental_getparentalsettings_response_unpack(buf []byte) ?CParental_GetParentalSettings_Response {
	mut res := zzz_vproto_internal_new_cparental_getparentalsettings_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_parentalsettings(cur_buf, tag_wiretype.wire_type) ?
				res.settings = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_GetParentalSettings_Response) eq(b CParental_GetParentalSettings_Response) bool {
	return true && a.settings.eq(b.settings)
}

[inline]
pub fn (a CParental_GetParentalSettings_Response) ne(b CParental_GetParentalSettings_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_GetParentalSettings_Response) eq(b []CParental_GetParentalSettings_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_GetParentalSettings_Response) ne(b []CParental_GetParentalSettings_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_getparentalsettings_response() CParental_GetParentalSettings_Response {
	return CParental_GetParentalSettings_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_getparentalsettings_response(o CParental_GetParentalSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_getparentalsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_GetParentalSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_getparentalsettings_response_unpack(v) ?
	return i, unpacked
}

pub struct CParental_GetSignedParentalSettings_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	priority       u32
}

pub fn (o &CParental_GetSignedParentalSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.priority != u32(0) {
		res << vproto.pack_uint32_field(o.priority, 1)
	}
	return res
}

pub fn cparental_getsignedparentalsettings_request_unpack(buf []byte) ?CParental_GetSignedParentalSettings_Request {
	mut res := zzz_vproto_internal_new_cparental_getsignedparentalsettings_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.priority = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_GetSignedParentalSettings_Request) eq(b CParental_GetSignedParentalSettings_Request) bool {
	return true && a.priority == b.priority
}

[inline]
pub fn (a CParental_GetSignedParentalSettings_Request) ne(b CParental_GetSignedParentalSettings_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_GetSignedParentalSettings_Request) eq(b []CParental_GetSignedParentalSettings_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_GetSignedParentalSettings_Request) ne(b []CParental_GetSignedParentalSettings_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_getsignedparentalsettings_request() CParental_GetSignedParentalSettings_Request {
	return CParental_GetSignedParentalSettings_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_getsignedparentalsettings_request(o CParental_GetSignedParentalSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_getsignedparentalsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_GetSignedParentalSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_getsignedparentalsettings_request_unpack(v) ?
	return i, unpacked
}

pub struct CParental_GetSignedParentalSettings_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serialized_settings []byte
	signature           []byte
}

pub fn (o &CParental_GetSignedParentalSettings_Response) pack() []byte {
	mut res := []byte{}
	if o.serialized_settings != []byte{} {
		res << vproto.pack_bytes_field(o.serialized_settings, 1)
	}
	if o.signature != []byte{} {
		res << vproto.pack_bytes_field(o.signature, 2)
	}
	return res
}

pub fn cparental_getsignedparentalsettings_response_unpack(buf []byte) ?CParental_GetSignedParentalSettings_Response {
	mut res := zzz_vproto_internal_new_cparental_getsignedparentalsettings_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.serialized_settings = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.signature = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_GetSignedParentalSettings_Response) eq(b CParental_GetSignedParentalSettings_Response) bool {
	return true && a.serialized_settings == b.serialized_settings && a.signature == b.signature
}

[inline]
pub fn (a CParental_GetSignedParentalSettings_Response) ne(b CParental_GetSignedParentalSettings_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_GetSignedParentalSettings_Response) eq(b []CParental_GetSignedParentalSettings_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_GetSignedParentalSettings_Response) ne(b []CParental_GetSignedParentalSettings_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_getsignedparentalsettings_response() CParental_GetSignedParentalSettings_Response {
	return CParental_GetSignedParentalSettings_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_getsignedparentalsettings_response(o CParental_GetSignedParentalSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_getsignedparentalsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_GetSignedParentalSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_getsignedparentalsettings_response_unpack(v) ?
	return i, unpacked
}

pub struct CParental_SetParentalSettings_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	password       string
	settings       ParentalSettings
	new_password   string
	sessionid      string
	steamid        u64
}

pub fn (o &CParental_SetParentalSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.password != '' {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.settings.ne(zzz_vproto_internal_new_parentalsettings()) {
		res << zzz_vproto_internal_pack_parentalsettings(o.settings, 2)
	}
	if o.new_password != '' {
		res << vproto.pack_string_field(o.new_password, 3)
	}
	if o.sessionid != '' {
		res << vproto.pack_string_field(o.sessionid, 4)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 10)
	}
	return res
}

pub fn cparental_setparentalsettings_request_unpack(buf []byte) ?CParental_SetParentalSettings_Request {
	mut res := zzz_vproto_internal_new_cparental_setparentalsettings_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.password = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_parentalsettings(cur_buf, tag_wiretype.wire_type) ?
				res.settings = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.new_password = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.sessionid = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_SetParentalSettings_Request) eq(b CParental_SetParentalSettings_Request) bool {
	return true && a.password == b.password && a.settings.eq(b.settings) && a.new_password ==
		b.new_password && a.sessionid == b.sessionid && a.steamid == b.steamid
}

[inline]
pub fn (a CParental_SetParentalSettings_Request) ne(b CParental_SetParentalSettings_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_SetParentalSettings_Request) eq(b []CParental_SetParentalSettings_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_SetParentalSettings_Request) ne(b []CParental_SetParentalSettings_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_setparentalsettings_request() CParental_SetParentalSettings_Request {
	return CParental_SetParentalSettings_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_setparentalsettings_request(o CParental_SetParentalSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_setparentalsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_SetParentalSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_setparentalsettings_request_unpack(v) ?
	return i, unpacked
}

pub struct CParental_SetParentalSettings_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_SetParentalSettings_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_setparentalsettings_response_unpack(buf []byte) ?CParental_SetParentalSettings_Response {
	res := zzz_vproto_internal_new_cparental_setparentalsettings_response()
	return res
}

[inline]
pub fn (a CParental_SetParentalSettings_Response) eq(b CParental_SetParentalSettings_Response) bool {
	return true
}

[inline]
pub fn (a CParental_SetParentalSettings_Response) ne(b CParental_SetParentalSettings_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_SetParentalSettings_Response) eq(b []CParental_SetParentalSettings_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_SetParentalSettings_Response) ne(b []CParental_SetParentalSettings_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_setparentalsettings_response() CParental_SetParentalSettings_Response {
	return CParental_SetParentalSettings_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_setparentalsettings_response(o CParental_SetParentalSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_setparentalsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_SetParentalSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_setparentalsettings_response_unpack(v) ?
	return i, unpacked
}

pub struct CParental_ValidateToken_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	unlock_token   string
}

pub fn (o &CParental_ValidateToken_Request) pack() []byte {
	mut res := []byte{}
	if o.unlock_token != '' {
		res << vproto.pack_string_field(o.unlock_token, 1)
	}
	return res
}

pub fn cparental_validatetoken_request_unpack(buf []byte) ?CParental_ValidateToken_Request {
	mut res := zzz_vproto_internal_new_cparental_validatetoken_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.unlock_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_ValidateToken_Request) eq(b CParental_ValidateToken_Request) bool {
	return true && a.unlock_token == b.unlock_token
}

[inline]
pub fn (a CParental_ValidateToken_Request) ne(b CParental_ValidateToken_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_ValidateToken_Request) eq(b []CParental_ValidateToken_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_ValidateToken_Request) ne(b []CParental_ValidateToken_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_validatetoken_request() CParental_ValidateToken_Request {
	return CParental_ValidateToken_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_validatetoken_request(o CParental_ValidateToken_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_validatetoken_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ValidateToken_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_validatetoken_request_unpack(v) ?
	return i, unpacked
}

pub struct CParental_ValidateToken_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_ValidateToken_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_validatetoken_response_unpack(buf []byte) ?CParental_ValidateToken_Response {
	res := zzz_vproto_internal_new_cparental_validatetoken_response()
	return res
}

[inline]
pub fn (a CParental_ValidateToken_Response) eq(b CParental_ValidateToken_Response) bool {
	return true
}

[inline]
pub fn (a CParental_ValidateToken_Response) ne(b CParental_ValidateToken_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_ValidateToken_Response) eq(b []CParental_ValidateToken_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_ValidateToken_Response) ne(b []CParental_ValidateToken_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_validatetoken_response() CParental_ValidateToken_Response {
	return CParental_ValidateToken_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_validatetoken_response(o CParental_ValidateToken_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_validatetoken_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ValidateToken_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_validatetoken_response_unpack(v) ?
	return i, unpacked
}

pub struct CParental_ValidatePassword_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	password               string
	session                string
	send_unlock_on_success bool
}

pub fn (o &CParental_ValidatePassword_Request) pack() []byte {
	mut res := []byte{}
	if o.password != '' {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.session != '' {
		res << vproto.pack_string_field(o.session, 2)
	}
	if o.send_unlock_on_success != false {
		res << vproto.pack_bool_field(o.send_unlock_on_success, 3)
	}
	return res
}

pub fn cparental_validatepassword_request_unpack(buf []byte) ?CParental_ValidatePassword_Request {
	mut res := zzz_vproto_internal_new_cparental_validatepassword_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.password = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.session = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type) ?
				res.send_unlock_on_success = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_ValidatePassword_Request) eq(b CParental_ValidatePassword_Request) bool {
	return true && a.password == b.password && a.session == b.session && a.send_unlock_on_success ==
		b.send_unlock_on_success
}

[inline]
pub fn (a CParental_ValidatePassword_Request) ne(b CParental_ValidatePassword_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_ValidatePassword_Request) eq(b []CParental_ValidatePassword_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_ValidatePassword_Request) ne(b []CParental_ValidatePassword_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_validatepassword_request() CParental_ValidatePassword_Request {
	return CParental_ValidatePassword_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_validatepassword_request(o CParental_ValidatePassword_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_validatepassword_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ValidatePassword_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_validatepassword_request_unpack(v) ?
	return i, unpacked
}

pub struct CParental_ValidatePassword_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	token          string
}

pub fn (o &CParental_ValidatePassword_Response) pack() []byte {
	mut res := []byte{}
	if o.token != '' {
		res << vproto.pack_string_field(o.token, 1)
	}
	return res
}

pub fn cparental_validatepassword_response_unpack(buf []byte) ?CParental_ValidatePassword_Response {
	mut res := zzz_vproto_internal_new_cparental_validatepassword_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_ValidatePassword_Response) eq(b CParental_ValidatePassword_Response) bool {
	return true && a.token == b.token
}

[inline]
pub fn (a CParental_ValidatePassword_Response) ne(b CParental_ValidatePassword_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_ValidatePassword_Response) eq(b []CParental_ValidatePassword_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_ValidatePassword_Response) ne(b []CParental_ValidatePassword_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_validatepassword_response() CParental_ValidatePassword_Response {
	return CParental_ValidatePassword_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_validatepassword_response(o CParental_ValidatePassword_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_validatepassword_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ValidatePassword_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_validatepassword_response_unpack(v) ?
	return i, unpacked
}

pub struct CParental_LockClient_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session        string
}

pub fn (o &CParental_LockClient_Request) pack() []byte {
	mut res := []byte{}
	if o.session != '' {
		res << vproto.pack_string_field(o.session, 1)
	}
	return res
}

pub fn cparental_lockclient_request_unpack(buf []byte) ?CParental_LockClient_Request {
	mut res := zzz_vproto_internal_new_cparental_lockclient_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.session = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_LockClient_Request) eq(b CParental_LockClient_Request) bool {
	return true && a.session == b.session
}

[inline]
pub fn (a CParental_LockClient_Request) ne(b CParental_LockClient_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_LockClient_Request) eq(b []CParental_LockClient_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_LockClient_Request) ne(b []CParental_LockClient_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_lockclient_request() CParental_LockClient_Request {
	return CParental_LockClient_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_lockclient_request(o CParental_LockClient_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_lockclient_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_LockClient_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_lockclient_request_unpack(v) ?
	return i, unpacked
}

pub struct CParental_LockClient_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_LockClient_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_lockclient_response_unpack(buf []byte) ?CParental_LockClient_Response {
	res := zzz_vproto_internal_new_cparental_lockclient_response()
	return res
}

[inline]
pub fn (a CParental_LockClient_Response) eq(b CParental_LockClient_Response) bool {
	return true
}

[inline]
pub fn (a CParental_LockClient_Response) ne(b CParental_LockClient_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_LockClient_Response) eq(b []CParental_LockClient_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_LockClient_Response) ne(b []CParental_LockClient_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_lockclient_response() CParental_LockClient_Response {
	return CParental_LockClient_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_lockclient_response(o CParental_LockClient_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_lockclient_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_LockClient_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_lockclient_response_unpack(v) ?
	return i, unpacked
}

pub struct CParental_RequestRecoveryCode_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_RequestRecoveryCode_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_requestrecoverycode_request_unpack(buf []byte) ?CParental_RequestRecoveryCode_Request {
	res := zzz_vproto_internal_new_cparental_requestrecoverycode_request()
	return res
}

[inline]
pub fn (a CParental_RequestRecoveryCode_Request) eq(b CParental_RequestRecoveryCode_Request) bool {
	return true
}

[inline]
pub fn (a CParental_RequestRecoveryCode_Request) ne(b CParental_RequestRecoveryCode_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_RequestRecoveryCode_Request) eq(b []CParental_RequestRecoveryCode_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_RequestRecoveryCode_Request) ne(b []CParental_RequestRecoveryCode_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_requestrecoverycode_request() CParental_RequestRecoveryCode_Request {
	return CParental_RequestRecoveryCode_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_requestrecoverycode_request(o CParental_RequestRecoveryCode_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_requestrecoverycode_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_RequestRecoveryCode_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_requestrecoverycode_request_unpack(v) ?
	return i, unpacked
}

pub struct CParental_RequestRecoveryCode_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_RequestRecoveryCode_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_requestrecoverycode_response_unpack(buf []byte) ?CParental_RequestRecoveryCode_Response {
	res := zzz_vproto_internal_new_cparental_requestrecoverycode_response()
	return res
}

[inline]
pub fn (a CParental_RequestRecoveryCode_Response) eq(b CParental_RequestRecoveryCode_Response) bool {
	return true
}

[inline]
pub fn (a CParental_RequestRecoveryCode_Response) ne(b CParental_RequestRecoveryCode_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_RequestRecoveryCode_Response) eq(b []CParental_RequestRecoveryCode_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_RequestRecoveryCode_Response) ne(b []CParental_RequestRecoveryCode_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_requestrecoverycode_response() CParental_RequestRecoveryCode_Response {
	return CParental_RequestRecoveryCode_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_requestrecoverycode_response(o CParental_RequestRecoveryCode_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_requestrecoverycode_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_RequestRecoveryCode_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_requestrecoverycode_response_unpack(v) ?
	return i, unpacked
}

pub struct CParental_DisableWithRecoveryCode_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	recovery_code  u32
	steamid        u64
}

pub fn (o &CParental_DisableWithRecoveryCode_Request) pack() []byte {
	mut res := []byte{}
	if o.recovery_code != u32(0) {
		res << vproto.pack_uint32_field(o.recovery_code, 1)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 10)
	}
	return res
}

pub fn cparental_disablewithrecoverycode_request_unpack(buf []byte) ?CParental_DisableWithRecoveryCode_Request {
	mut res := zzz_vproto_internal_new_cparental_disablewithrecoverycode_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type) ?
				res.recovery_code = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type) ?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_DisableWithRecoveryCode_Request) eq(b CParental_DisableWithRecoveryCode_Request) bool {
	return true && a.recovery_code == b.recovery_code && a.steamid == b.steamid
}

[inline]
pub fn (a CParental_DisableWithRecoveryCode_Request) ne(b CParental_DisableWithRecoveryCode_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_DisableWithRecoveryCode_Request) eq(b []CParental_DisableWithRecoveryCode_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_DisableWithRecoveryCode_Request) ne(b []CParental_DisableWithRecoveryCode_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_disablewithrecoverycode_request() CParental_DisableWithRecoveryCode_Request {
	return CParental_DisableWithRecoveryCode_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_disablewithrecoverycode_request(o CParental_DisableWithRecoveryCode_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_disablewithrecoverycode_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_DisableWithRecoveryCode_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_disablewithrecoverycode_request_unpack(v) ?
	return i, unpacked
}

pub struct CParental_DisableWithRecoveryCode_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_DisableWithRecoveryCode_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_disablewithrecoverycode_response_unpack(buf []byte) ?CParental_DisableWithRecoveryCode_Response {
	res := zzz_vproto_internal_new_cparental_disablewithrecoverycode_response()
	return res
}

[inline]
pub fn (a CParental_DisableWithRecoveryCode_Response) eq(b CParental_DisableWithRecoveryCode_Response) bool {
	return true
}

[inline]
pub fn (a CParental_DisableWithRecoveryCode_Response) ne(b CParental_DisableWithRecoveryCode_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_DisableWithRecoveryCode_Response) eq(b []CParental_DisableWithRecoveryCode_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_DisableWithRecoveryCode_Response) ne(b []CParental_DisableWithRecoveryCode_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_disablewithrecoverycode_response() CParental_DisableWithRecoveryCode_Response {
	return CParental_DisableWithRecoveryCode_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_disablewithrecoverycode_response(o CParental_DisableWithRecoveryCode_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_disablewithrecoverycode_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_DisableWithRecoveryCode_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_disablewithrecoverycode_response_unpack(v) ?
	return i, unpacked
}

pub struct CParental_ParentalSettingsChange_Notification {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serialized_settings []byte
	signature           []byte
	password            string
	sessionid           string
}

pub fn (o &CParental_ParentalSettingsChange_Notification) pack() []byte {
	mut res := []byte{}
	if o.serialized_settings != []byte{} {
		res << vproto.pack_bytes_field(o.serialized_settings, 1)
	}
	if o.signature != []byte{} {
		res << vproto.pack_bytes_field(o.signature, 2)
	}
	if o.password != '' {
		res << vproto.pack_string_field(o.password, 3)
	}
	if o.sessionid != '' {
		res << vproto.pack_string_field(o.sessionid, 4)
	}
	return res
}

pub fn cparental_parentalsettingschange_notification_unpack(buf []byte) ?CParental_ParentalSettingsChange_Notification {
	mut res := zzz_vproto_internal_new_cparental_parentalsettingschange_notification()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.serialized_settings = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type) ?
				res.signature = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.password = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.sessionid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_ParentalSettingsChange_Notification) eq(b CParental_ParentalSettingsChange_Notification) bool {
	return true && a.serialized_settings == b.serialized_settings && a.signature == b.signature &&
		a.password == b.password && a.sessionid == b.sessionid
}

[inline]
pub fn (a CParental_ParentalSettingsChange_Notification) ne(b CParental_ParentalSettingsChange_Notification) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_ParentalSettingsChange_Notification) eq(b []CParental_ParentalSettingsChange_Notification) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_ParentalSettingsChange_Notification) ne(b []CParental_ParentalSettingsChange_Notification) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_parentalsettingschange_notification() CParental_ParentalSettingsChange_Notification {
	return CParental_ParentalSettingsChange_Notification{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_parentalsettingschange_notification(o CParental_ParentalSettingsChange_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_parentalsettingschange_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ParentalSettingsChange_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_parentalsettingschange_notification_unpack(v) ?
	return i, unpacked
}

pub struct CParental_ParentalUnlock_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	password       string
	sessionid      string
}

pub fn (o &CParental_ParentalUnlock_Notification) pack() []byte {
	mut res := []byte{}
	if o.password != '' {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.sessionid != '' {
		res << vproto.pack_string_field(o.sessionid, 2)
	}
	return res
}

pub fn cparental_parentalunlock_notification_unpack(buf []byte) ?CParental_ParentalUnlock_Notification {
	mut res := zzz_vproto_internal_new_cparental_parentalunlock_notification()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.password = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.sessionid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_ParentalUnlock_Notification) eq(b CParental_ParentalUnlock_Notification) bool {
	return true && a.password == b.password && a.sessionid == b.sessionid
}

[inline]
pub fn (a CParental_ParentalUnlock_Notification) ne(b CParental_ParentalUnlock_Notification) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_ParentalUnlock_Notification) eq(b []CParental_ParentalUnlock_Notification) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_ParentalUnlock_Notification) ne(b []CParental_ParentalUnlock_Notification) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_parentalunlock_notification() CParental_ParentalUnlock_Notification {
	return CParental_ParentalUnlock_Notification{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_parentalunlock_notification(o CParental_ParentalUnlock_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_parentalunlock_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ParentalUnlock_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_parentalunlock_notification_unpack(v) ?
	return i, unpacked
}

pub struct CParental_ParentalLock_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessionid      string
}

pub fn (o &CParental_ParentalLock_Notification) pack() []byte {
	mut res := []byte{}
	if o.sessionid != '' {
		res << vproto.pack_string_field(o.sessionid, 1)
	}
	return res
}

pub fn cparental_parentallock_notification_unpack(buf []byte) ?CParental_ParentalLock_Notification {
	mut res := zzz_vproto_internal_new_cparental_parentallock_notification()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type) ?
				res.sessionid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CParental_ParentalLock_Notification) eq(b CParental_ParentalLock_Notification) bool {
	return true && a.sessionid == b.sessionid
}

[inline]
pub fn (a CParental_ParentalLock_Notification) ne(b CParental_ParentalLock_Notification) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CParental_ParentalLock_Notification) eq(b []CParental_ParentalLock_Notification) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CParental_ParentalLock_Notification) ne(b []CParental_ParentalLock_Notification) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cparental_parentallock_notification() CParental_ParentalLock_Notification {
	return CParental_ParentalLock_Notification{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cparental_parentallock_notification(o CParental_ParentalLock_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cparental_parentallock_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ParentalLock_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := cparental_parentallock_notification_unpack(v) ?
	return i, unpacked
}
